# Wrapped Types Analysis in pg-proto-parser

## Overview

The `isWrappedType` function and wrapped types concept are fundamental to how pg-proto-parser handles PostgreSQL AST node types. This document explains how they work and where they're used.

## What are Wrapped Types?

Wrapped types are protobuf message types that can be contained within the `Node` union type. In PostgreSQL's protobuf schema, the `Node` message has a `oneof` field that can contain various AST node types. Any type that appears in this union is considered a "wrapped type."

## How Wrapped Types are Detected

### 1. **RuntimeSchemaGenerator** (`src/runtime-schema/generator.ts`)

The detection happens in the `extractWrappedTypes()` method:

```typescript
private extractWrappedTypes(): void {
  const nodeType = this.root.lookupType('Node');
  if (nodeType && nodeType.oneofs && nodeType.oneofs.node) {
    const oneof = nodeType.oneofs.node;
    for (const fieldName of oneof.fieldsArray.map(f => f.name)) {
      const field = nodeType.fields[fieldName];
      if (field && field.type) {
        this.wrappedTypes.add(field.type);
      }
    }
  }
}
```

This method:
- Looks up the `Node` type in the protobuf schema
- Iterates through all fields in the `node` oneof
- Adds each field's type to the `wrappedTypes` Set

### 2. **ProtoStore** (`src/store.ts`)

The `isWrappedType()` method:

```typescript
isWrappedType(typeName: string): boolean {
  const schema = this.getRuntimeSchema();
  const nodeSpec = schema.find(spec => spec.name === typeName);
  return nodeSpec ? nodeSpec.wrapped : false;
}
```

This method:
- Gets the runtime schema (generated by RuntimeSchemaGenerator)
- Looks up the type by name
- Returns the `wrapped` boolean flag

## Where Wrapped Types are Used

### 1. **Type Generation**

In `src/store.ts`, wrapped types are handled differently when generating TypeScript interfaces:

```typescript
const wrappedTypes = this.types.reduce((m, type) => {
  if (this.isWrappedType(type.name)) {
    return [...m, convertTypeToWrappedTsInterface(type, this.options, (typeName: string) => this.isWrappedType(typeName))]
  }
  return m;
}, []);
```

### 2. **Runtime Schema**

Each node spec in the runtime schema includes a `wrapped` boolean:

```typescript
return {
  name: type.name,
  wrapped: this.wrappedTypes.has(type.name),
  fields: fields.sort((a, b) => a.name.localeCompare(b.name))
};
```

### 3. **Field Specifications**

When creating field specs, the generator checks if a field type is a Node or wrapped type:

```typescript
const isNode = fieldType === 'Node' || this.wrappedTypes.has(fieldType);
```

## Configuration Options

### 1. **types.wrapped**

```typescript
wrapped?: {
  enabled?: boolean;      // Enable wrapped types generation
  enumsSource?: string;   // Source for enum imports
  filename?: string;      // Output filename for wrapped types
}
```

### 2. **types.wrappedNodeTypeExport**

A simpler option for user cases where full wrapped type handling is too advanced:
- If enabled, exports Node type references
- Meant for simpler use cases

### 3. **utils.astHelpers.wrappedTypesSource**

Specifies the import source for wrapped types in AST helpers:
```typescript
astHelpers?: {
  wrappedTypesSource?: string;  // Default: './wrapped'
}
```

## Example Usage

When the parser encounters types like:
- `SelectStmt`
- `InsertStmt`
- `UpdateStmt`
- `DeleteStmt`
- etc.

It checks if they're wrapped types (i.e., can be contained in a Node union). This affects:
1. How TypeScript interfaces are generated
2. How AST helper functions are created
3. How the runtime schema represents the type

## Runtime Schema Output

The runtime schema includes wrapped type information:

```json
{
  "name": "SelectStmt",
  "wrapped": true,
  "fields": [...]
}
```

## Current Implementation Status

The `convertTypeToWrappedTsInterface` function currently just calls `convertTypeToTsInterface`, with a TODO comment indicating that wrapped type-specific handling is planned but not yet implemented:

```typescript
export const convertTypeToWrappedTsInterface = (
  type: Type,
  options: PgProtoParserOptions,
  isWrappedTypeFn: (typeName: string) => boolean
) => {
  const typeName = type.name;
  // if (!isWrappedTypeFn(typeName)) return convertTypeToTsInterface(type, options);
  return convertTypeToTsInterface(type, options);

  // TODO bring this back to life...
  // [commented out code for nested interface generation]
}
```

## Summary

The wrapped types system in pg-proto-parser:
1. Identifies which protobuf message types can be contained in the Node union
2. Tracks this information in the runtime schema
3. Provides the `isWrappedType()` method to query this information
4. Uses this information to potentially generate different TypeScript interfaces (though currently not fully implemented)
5. Helps in understanding the AST structure and relationships between node types