{
  "misc.sql": "CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;\nCREATE EXTENSION IF NOT EXISTS plpgsql;\n\nCREATE INDEX index_email_logs_on_created_at ON public.email_logs USING btree (created_at DESC);\nCREATE INDEX index_email_logs_on_created_at ON public.email_logs USING btree (created_at DESC, another_prop ASC);\n\n\nALTER TABLE \"Customer\" ADD CONSTRAINT myconstraint\n  FOREIGN KEY (\"SupportRepId\") REFERENCES \"Employee\" (\"EmployeeId\") ON DELETE NO ACTION ON UPDATE NO ACTION;\n\n\nALTER FUNCTION public.delayed_jobs_after_delete_row_tr_fn() OWNER TO prisma;\nALTER FUNCTION public.delayed_jobs_after_delete_row_tr_fn OWNER TO prisma;\n\n\ncreate table if not exists users (\n  id uuid primary key not null default gen_random_uuid(),\n  \"name\" text not null,\n  handle text not null,\n  created_at timestamp not null default now(),\n  updated_at timestamp not null default now()\n);\n\nCREATE INDEX CONCURRENTLY IF NOT EXISTS index_email_logs_on_created_at ON public.email_logs USING btree (created_at DESC);",
  "call.sql": "CALL do_db_maintenance(a := 1);\nCALL do_db_maintenance();\nCALL do_db_maintenance(1, 2);",
  "copy.sql": "COPY (SELECT 1) TO 'test.csv' WITH (FORMAT CSV);",
  "privs-and-defaults.sql": "ALTER DEFAULT PRIVILEGES IN SCHEMA schema_name GRANT SELECT ON TABLES TO your_user;\nALTER DEFAULT PRIVILEGES IN SCHEMA schema_name GRANT ALL ON TABLES TO your_user;\nALTER DEFAULT PRIVILEGES IN SCHEMA schema_name GRANT ALL ON SEQUENCES TO your_user;\nALTER DEFAULT PRIVILEGES IN SCHEMA schema_name GRANT ALL ON FUNCTIONS TO your_user;\nALTER DEFAULT PRIVILEGES IN SCHEMA schema_name GRANT USAGE, SELECT ON SEQUENCES TO grantee_name;\n\nGRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA schema_name TO your_user;\nGRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA schema_name TO your_user;\nGRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA schema_name TO your_user;\n",
  "preceeding.sql": "WITH timestamp_measurement AS (SELECT count(t1.id) AS count_num\n                                    , date_trunc('month', t1.start_date) AS timestamp\n                               FROM trip AS t1\n                               GROUP BY timestamp)\n\n  SELECT t2.timestamp AS timestamp\n       , avg(t2.count_num) OVER (ORDER BY t2.timestamp ASC RANGE BETWEEN '3 months' PRECEDING AND CURRENT ROW) AS moving_count_num\n  FROM timestamp_measurement AS t2",
  "parens.sql": "select node->'relation'->'RangeVar' IS NOT NULL\nFROM my_json_store;\n\nselect node->'relation'->'RangeVar' IS NOT NULL AND\n        node->'relation'->'RangeVar'->>'inh' IS NULL\nFROM my_json_store;\n\nselect a IS NOT NULL AND\n        b IS NULL OR\n        (c IS NOT NULL AND\n        (a->'inh')::bool IS FALSE)\nFROM my_json_store;\n\nselect node->'relation'->'RangeVar' IS NOT NULL AND\n        node->'relation'->'RangeVar'->'inh' IS NULL OR\n        (node->'relation'->'RangeVar'->'inh' IS NOT NULL AND\n        (node->'relation'->'RangeVar'->'inh')::bool IS FALSE)\nFROM my_json_store;\n\nSELECT \nA AND B \nAND C OR D\nFROM t;\n\nSELECT \nA AND B \nAND C OR D OR (E AND F OR G)\nFROM t;\n\nSELECT \nA AND B \nAND (C)::bool IS TRUE OR D OR (E AND F OR G)\nFROM t;\n\nSELECT \nNOT (A AND B)\nAND C OR NOT D\nFROM t;\n\nSELECT \nNOT (A AND B)\nAND C\nFROM t;\n\nSELECT (NOT ((a AND b)) AND c) FROM t;\n\nSELECT (field=1 OR field=2) IS TRUE;\n\nSELECT field=1 OR field=2 IS TRUE;",
  "comment.sql": "comment on column my_schema.my_table.my_column is\n  E'@name meta\\n@isImportant\\n@jsonField date timestamp\\n@jsonField name text\\n@jsonField episode enum ONE=1 TWO=2\\nThis field has a load of arbitrary tags.';\n\ncomment on table my_schema.my_table is\n  E'@name my_new_table_name\\n@omit update,delete\\nThis is the documentation.';\n\ncomment on view my_schema.mv_view is\n  E'@name my_new_view_name\\n@omit update,delete\\nThis is the documentation.';\n\ncomment on materialized view my_schema.mv_view is\n  E'@name my_new_view_name\\n@omit update,delete\\nThis is the documentation.';\n\ncomment on type my_schema.my_type is\n  E'@name my_new_type_name\\nThis is the documentation.';\n\ncomment on column my_schema.my_table.my_column is\n  E'@name my_new_column\\n@omit create,update\\nThis is the documentation.';\n\ncomment on constraint my_constraint on my_schema.my_table is\n  E'@foreignFieldName foos\\n@fieldName bar\\nDocumentation here.';\n\ncomment on function my_function(arg_type_1, arg_type_2) is\n  E'@name my_new_function_name\\nDocumentation here.';\n\n-- test out the raw vs non-raw\n\ncomment on function my_function(arg_type_1, arg_type_2) is\n  E'\\ninmycomment';\n\ncomment on function my_function(arg_type_1, arg_type_2) is\n  'inmycomment';",
  "drops.sql": "DROP POLICY policy_name ON schema_name.table_name;\nDROP POLICY policy_name ON table_name;\n\nREVOKE DELETE ON TABLE schema_name.table_name FROM authenticated;\nREVOKE DELETE ON TABLE table_name FROM authenticated;\n\nDROP TABLE table_name;\nDROP TABLE schema_name.table_name;\n\nALTER TABLE schema_name.table_name DROP COLUMN column_name;\nALTER TABLE \"schema-name\".table_name DROP COLUMN column_name;\nALTER TABLE \"schema-name\".\"aa-bdd\" DROP COLUMN \"sdf-sdf\";\nALTER TABLE \"table-name\" DROP COLUMN column_name;\nALTER TABLE table_name DROP COLUMN column_name;\n\nDROP sequence if exists hsseq;\nDROP sequence if exists \"some-thing\".hsseq;\n\nALTER TABLE schemaname.table_name RENAME column_name1 TO new_column_name1;\nALTER TABLE table_name RENAME column_name1 TO new_column_name1;\n\nDROP TYPE test_type;\nDROP TYPE schema_name.test_type;\nDROP TYPE \"schema-name\".test_type;\nDROP TYPE \"schema-name\".\"test-type\";\nDROP TYPE IF EXISTS test_type_exists;\nDROP TYPE IF EXISTS \"aa-bb\".test_type_exists;\ndrop type eitype cascade;\n\n-- DROP AGGREGATE testagg1b(testdomain1);\nDROP DOMAIN testdomain2b;\nDROP DOMAIN schema_name.testdomain2b;\n-- DROP OPERATOR !! (NONE, testdomain1);\nDROP FUNCTION testfunc5b(a testdomain1);\nDROP FUNCTION \"my-schema\".testfunc5b(a testdomain1);\nDROP FUNCTION testfunc6b(b int);\nDROP FUNCTION \"my-schema\".testfunc6b(b int);\nDROP FUNCTION \"my-schema\".\"test-func6b\"(b int);\nDROP FUNCTION testfunc7777;\nDROP FUNCTION \"my-schema\".testfunc7777;\n\n-- DROP CAST (testdomain1 AS testdomain3b);\n\nDROP TRIGGER trigger_name ON table_name;\nDROP TRIGGER IF EXISTS trigger_name ON table_name;\n\nDROP TRIGGER trigger_name ON schema_name.table_name;\nDROP TRIGGER IF EXISTS trigger_name ON schema_name.table_name;\n\nDROP RULE rule_name ON table_name;\nDROP RULE IF EXISTS rule_name ON table_name;\n\nDROP RULE rule_name ON schema_name.table_name;\nDROP RULE IF EXISTS rule_name ON schema_name.table_name;\n\nDROP VIEW IF EXISTS test_view_exists;\n\nDROP VIEW test_view_exists;\n\n-- DROP USER tu2;\n-- DROP USER IF EXISTS tu1, tu2;\n\nDROP EXTENSION test_extension_exists;\nDROP EXTENSION IF EXISTS test_extension_exists;\n\nDROP FOREIGN DATA WRAPPER test_fdw_exists;\nDROP FOREIGN DATA WRAPPER IF EXISTS test_fdw_exists;\n\nDROP AGGREGATE IF EXISTS no_such_schema.foo(int);\nDROP AGGREGATE IF EXISTS foo(no_such_type);\nDROP AGGREGATE IF EXISTS foo(no_such_schema.no_such_type);\n\nDROP CAST IF EXISTS (INTEGER AS no_such_type2);\nDROP CAST IF EXISTS (no_such_type1 AS INTEGER);\nDROP CAST IF EXISTS (INTEGER AS no_such_schema.bar);\nDROP CAST IF EXISTS (no_such_schema.foo AS INTEGER);\n\nDROP COLLATION IF EXISTS no_such_schema.foo;\nDROP CONVERSION IF EXISTS no_such_schema.foo;\nDROP DOMAIN IF EXISTS no_such_schema.foo;\nDROP FOREIGN TABLE IF EXISTS no_such_schema.foo;\n\nDROP INDEX IF EXISTS no_such_schema.foo;\nDROP INDEX my_index;\nDROP INDEX CONCURRENTLY my_index;\nDROP INDEX IF EXISTS my_index;\nDROP INDEX CONCURRENTLY IF EXISTS my_index;\nDROP INDEX schema.my_index;\nDROP INDEX CONCURRENTLY schema.my_index;\nDROP INDEX CONCURRENTLY IF EXISTS schema.my_index;\nDROP INDEX my_index CASCADE;\nDROP INDEX CONCURRENTLY my_index CASCADE;\nDROP INDEX CONCURRENTLY IF EXISTS my_index CASCADE;\nDROP MATERIALIZED VIEW IF EXISTS no_such_schema.foo;\n\n-- DROP OPERATOR IF EXISTS no_such_schema.+ (int, int);\n-- DROP OPERATOR IF EXISTS + (no_such_type, no_such_type);\n-- DROP OPERATOR IF EXISTS + (no_such_schema.no_such_type, no_such_schema.no_such_type);\n-- DROP OPERATOR IF EXISTS # (NONE, no_such_schema.no_such_type);\n",
  "a_expr.sql": "CREATE VIEW superschema.app_authorized_grants AS\n      SELECT\n        coalesce(nullif(s[1], ''), 'PUBLIC') as grantee,\n        relname as table_name,\n        nspname as table_schema,\n        string_agg(s[2], ', ') as privileges,\n        relkind as table_type\n      FROM\n        pg_class c\n        join pg_namespace n on n.oid = relnamespace\n        join pg_roles r on r.oid = relowner,\n        unnest(coalesce(relacl::text[], format('{%%s=arwdDxt/%%s}', rolname, rolname)::text[])) acl, \n        regexp_split_to_array(acl, '=|/') s\n      WHERE (s[1] = 'authenticated' or s[1] is null) and nspname not in ('pg_catalog', 'information_schema', 'pg_toast')\n      GROUP BY grantee, table_name, table_schema, relkind\n      ORDER BY relkind != 'r', relkind != 'v', relkind != 'm', relkind != 'i', relkind, nspname, relname;\n\n-- AEXPR_OP\nselect a = b;\n\n-- AEXPR_OP_ANY\nSELECT foo = ANY(x) FROM vtable;\n\n-- AEXPR_OP_ALL\nSELECT foo = ALL(x) FROM vtable;\n\n-- AEXPR_DISTINCT\n-- AEXPR_NOT_DISTINCT\n\nSELECT foo,bar FROM vtable WHERE foo IS DISTINCT FROM bar;\nSELECT foo,bar FROM vtable WHERE foo IS NOT DISTINCT FROM bar;\n\nSELECT t1.foo,t1.bar,t1.baz\nFROM t1\nLEFT OUTER JOIN t2 ON (\n t1.foo IS NOT DISTINCT FROM t2.foo\n AND t1.bar IS NOT DISTINCT FROM t2.bar\n AND t1.baz IS NOT DISTINCT FROM t2.baz\n)\nWHERE ( t2.foo IS NULL );\n\n\n\n-- AEXPR_NULLIF\n\nselect nullif(null, '');\n\n-- AEXPR_OF\n\nSELECT x, x IS OF (text) AS is_text FROM q;\nSELECT x, x IS NOT OF (text) AS is_text FROM q;\nSELECT COALESCE(4::domainint4, 7::domainint4) IS OF ( domainint4 ) AS t;\n\n-- AEXPR_IN\n\nSELECT\n    value IN (SELECT column_name FROM table_name);\n\nSELECT\n    value NOT IN (SELECT column_name FROM table_name);\n\nSELECT customer_id,\n\trental_id,\n\treturn_date\nFROM\n\trental\nWHERE\n\tcustomer_id IN (1, 2)\nORDER BY\n\treturn_date DESC;\n\n\nSELECT\n\tcustomer_id,\n\trental_id,\n\treturn_date\nFROM\n\trental\nWHERE\n\tcustomer_id NOT IN (1, 2);\n\nSELECT\n\tcustomer_id,\n\trental_id,\n\treturn_date\nFROM\n\trental\nWHERE\n\tcustomer_id <> 1\nAND customer_id <> 2;\n\nSELECT *\nFROM Employees\nWHERE name IN ('James John', 'Mercy Bush', 'Kate Joel');\n\nSELECT *\nFROM Employees\nWHERE name NOT IN ('James John', 'Mercy Bush', 'Kate Joel');\n\nSELECT customer_id\nFROM rental\nWHERE CAST (return_date AS DATE) = '2005-05-27'\nORDER BY customer_id;\n\nSELECT\n\tcustomer_id,\n\tfirst_name,\n\tlast_name\nFROM\n\tcustomer\nWHERE\n\tcustomer_id IN (\n\t\tSELECT customer_id\n\t\tFROM rental\n\t\tWHERE CAST (return_date AS DATE) = '2005-05-27'\n\t)\nORDER BY customer_id;\n\n-- AEXPR_LIKE\n\nSELECT * FROM student WHERE name LIKE 'a%';\nSELECT * FROM student WHERE name NOT LIKE 'a%';\nSELECT\n\t'foo' LIKE 'foo', \n\t'foo' LIKE 'f%', \n\t'foo' LIKE '_o_', \n\t'bar' LIKE 'b_'; \n\n-- AEXPR_ILIKE\n\nSELECT * FROM student WHERE name ILIKE 'a%';\nSELECT * FROM student WHERE name NOT ILIKE 'a%';\n\n\n-- AEXPR_SIMILAR\n\nselect 'xyz' SIMILAR TO 'xyz'; \nselect 'xyz' SIMILAR TO 'x';    \nselect 'xyz' SIMILAR TO '%(y|a)%'; \nselect 'xyz' SIMILAR TO '(y|z)%';\n\nselect 'xyz' SIMILAR TO 'xyz' ESCAPE 'x'; \nselect 'xyz' SIMILAR TO 'x' ESCAPE 'x';    \nselect 'xyz' SIMILAR TO '%(y|a)%' ESCAPE 'x'; \nselect 'xyz' SIMILAR TO '(y|z)%' ESCAPE 'x';\n\nselect 'xyz' NOT SIMILAR TO 'xyz'; \nselect 'xyz' NOT SIMILAR TO 'x';    \nselect 'xyz' NOT SIMILAR TO '%(y|a)%'; \nselect 'xyz' NOT SIMILAR TO '(y|z)%';\n\nselect 'xyz' NOT SIMILAR TO 'xyz' ESCAPE 'x'; \nselect 'xyz' NOT SIMILAR TO 'x' ESCAPE 'x';    \nselect 'xyz' NOT SIMILAR TO '%(y|a)%' ESCAPE 'x'; \nselect 'xyz' NOT SIMILAR TO '(y|z)%' ESCAPE 'x';\n\n-- AEXPR_BETWEEN\n-- AEXPR_NOT_BETWEEN\n-- AEXPR_BETWEEN_SYM\n-- AEXPR_NOT_BETWEEN_SYM\n\nselect * from generate_series(1,10) as numbers(a)\n    where numbers.a between symmetric 6 and 3;\n\nselect * from generate_series(1,10) as numbers(a)\n    where numbers.a between 6 and 3;\n\nselect * from generate_series(1,10) as numbers(a)\n    where numbers.a not between symmetric 6 and 3;\n\nselect * from generate_series(1,10) as numbers(a)\n    where numbers.a not between 6 and 3;\n",
  "pg_catalog.sql": "   CREATE TABLE table_without_pg_catalog (\n        bigint_type bigint,\n        bigserial_type bigserial,\n        bit_opt_1_type bit(1),\n        bit_opt_2_type bit(2),\n        bit_opt_16_type bit(16),\n        bit_varying_opt_1_type varbit(1),\n        bit_varying_opt_2_type varbit(2),\n        bool_type bool,\n        boolean_type boolean,\n        box_type box,\n        bytea_type bytea,\n        char_opt_1_type char(1),\n        char_opt_140_type char(140),\n        char_opt_1000_type char(1000),\n        char_type char(1),\n        character_type char(1),\n        character_varying_opt_1_type varchar(1),\n        character_varying_opt_10_type varchar(10),\n        character_varying_opt_140_type varchar(140),\n        character_varying_opt_1000_type varchar(1000),\n        character_varying_type varchar,\n        cidr_type cidr,\n        circle_type circle,\n        date_type date,\n        double_precision_type pg_catalog.float8,\n        float_4_type float4,\n        float_8_type float8,\n        float_type pg_catalog.float8,\n        float_opt_1_type pg_catalog.float4,\n        float_opt_2_type pg_catalog.float4,\n        float_opt_3_type pg_catalog.float4,\n        float_opt_4_type pg_catalog.float4,\n        float_opt_5_type pg_catalog.float4,\n        float_opt_6_type pg_catalog.float4,\n        float_opt_7_type pg_catalog.float4,\n        float_opt_8_type pg_catalog.float4,\n        inet_type inet,\n        int_type int,\n        int2_type int2,\n        int4_type int4,\n        int8_type int8,\n        interval_year_type interval year,\n        interval_month_type interval month,\n        interval_day_type interval day,\n        interval_hour_type interval hour,\n        interval_minute_type interval minute,\n        interval_type interval,\n        json_type json,\n        jsonb_type jsonb,\n        line_type line,\n        lseg_type lseg,\n        macaddr_type macaddr,\n        money_type money,\n        numeric_type numeric,\n        numeric_opt_type numeric(10, 10),\n        path_type path,\n        pg_lsn_type pg_lsn,\n        point_type point,\n        polygon_type polygon,\n        real_type pg_catalog.float4,\n        serial_type serial,\n        serial4_type serial4,\n        serial8_type serial8,\n        smallint_type smallint,\n        text_type text,\n        time_opt_2_type time(2),\n        time_type time,\n        timestamp_type timestamp,\n        timestamptz_type timestamptz,\n        timetz_opt_2_type pg_catalog.timetz(2),\n        timetz_type timetz,\n        tsquery_type tsquery,\n        tsvector_type tsvector,\n        uuid_type uuid,\n        varbit_1_type varbit(1),\n        varbit_2_type varbit(2),\n        varbit_16_type varbit(16),\n        varbit_type varbit,\n        varchar_opt_1_type varchar(1),\n        varchar_opt_140_type varchar(140),\n        varchar_opt_1000_type varchar(1000),\n        varchar_type varchar,\n        xml_type xml \n    );\n    \n    CREATE TABLE table_with_pg_catalog (\n        bigint_type bigint,\n        bigserial_type bigserial,\n        bit_opt_1_type bit(1),\n        bit_opt_2_type bit(2),\n        bit_opt_16_type bit(16),\n        bit_varying_opt_1_type pg_catalog.varbit(1),\n        bit_varying_opt_2_type pg_catalog.varbit(2),\n        bool_type boolean,\n        boolean_type pg_catalog.bool,     \n        box_type pg_catalog.box,\n        bytea_type pg_catalog.bytea,\n        char_opt_1_type char(1),\n        char_opt_140_type char(140),\n        char_opt_1000_type char(1000),\n        char_type pg_catalog.char,\n        character_type character,\n        character_varying_opt_1_type varchar(1),\n        character_varying_opt_10_type varchar(10),\n        character_varying_opt_140_type varchar(140),\n        character_varying_opt_1000_type varchar(1000),\n        character_varying_type varchar,\n        cidr_type pg_catalog.cidr,\n        circle_type pg_catalog.circle,\n        date_type pg_catalog.date,\n        float_4_type pg_catalog.float4,\n        float_8_type pg_catalog.float8,\n        float_type float,\n        float_opt_1_type float(1),\n        float_opt_2_type float(2),\n        float_opt_3_type float(3),\n        float_opt_4_type float(4),\n        float_opt_5_type float(5),\n        float_opt_6_type float(6),\n        float_opt_7_type float(7),\n        float_opt_8_type float(8),\n        inet_type pg_catalog.inet,\n        int_type int,\n        int2_type smallint,\n        int4_type int,\n        int8_type bigint,\n        interval_year_type interval year,\n        interval_month_type interval month,\n        interval_day_type interval day,\n        interval_hour_type interval hour,\n        interval_minute_type interval minute,\n        interval_type interval,\n        json_type pg_catalog.json,\n        jsonb_type pg_catalog.jsonb,\n        line_type pg_catalog.line,\n        lseg_type pg_catalog.lseg,\n        macaddr_type pg_catalog.macaddr,\n        money_type pg_catalog.money,\n        numeric_type numeric,\n        numeric_opt_type numeric(10, 10),\n        path_type pg_catalog.path,\n        pg_lsn_type pg_catalog.pg_lsn,\n        point_type pg_catalog.point,\n        polygon_type pg_catalog.polygon,\n        serial_type serial,\n        serial4_type serial4,\n        serial8_type serial8,\n        smallint_type smallint,\n        text_type pg_catalog.text,\n        time_opt_2_type time(2),\n        time_type time,\n        time_type_mod time(2),\n        timestamp_type timestamp,\n        timestamptz_type pg_catalog.timestamptz,\n        timetz_opt_2_type pg_catalog.timetz(2),\n        timetz_type pg_catalog.timetz,\n        tsquery_type pg_catalog.tsquery,\n        tsvector_type pg_catalog.tsvector,\n        uuid_type uuid,\n        varbit_1_type pg_catalog.varbit(1),\n        varbit_2_type pg_catalog.varbit(2),\n        varbit_16_type pg_catalog.varbit(16),\n        varbit_type pg_catalog.varbit,\n        varchar_opt_1_type varchar(1),\n        varchar_opt_140_type varchar(140),\n        varchar_opt_1000_type varchar(1000),\n        varchar_type varchar,\n        xml_type pg_catalog.xml \n    );\n    \n    CREATE TABLE table_with_pg_catalog_chars (\n        a char(1),\n        b bpchar \n    );\n\n\n\nCREATE FUNCTION charfunc(\n  a pg_catalog.\"char\",\n  b \"char\",\n  c char\n) returns void as $$\nBEGIN\n\n \nEND;\n$$\nLANGUAGE 'plpgsql' VOLATILE;\n",
  "alter/alter.sql": "CREATE SCHEMA IF NOT EXISTS app_jobs;\n\nCREATE TABLE app_jobs.job_queues (\n  queue_name varchar NOT NULL PRIMARY KEY,\n  job_count int DEFAULT 0 NOT NULL,\n  locked_at timestamp with time zone,\n  locked_by varchar\n);\n\nALTER TABLE app_jobs.job_queues ENABLE ROW LEVEL SECURITY;\n\nCREATE TABLE foo (\n  name text,\n  foo_timestamp timestampz DEFAULT CURRENT_DATE\n);\n\nALTER TABLE foo RENAME COLUMN name TO city;\n\nALTER TABLE foo\n    ALTER COLUMN foo_timestamp DROP DEFAULT,\n    ALTER COLUMN foo_timestamp TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',\n    ALTER COLUMN foo_timestamp SET DEFAULT now();\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id);\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE CASCADE;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE RESTRICT;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE NO ACTION;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON DELETE SET NULL;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON UPDATE SET DEFAULT;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON UPDATE CASCADE;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON UPDATE RESTRICT;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON UPDATE NO ACTION;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON UPDATE SET NULL;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) ON UPDATE SET DEFAULT;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (order_id) REFERENCES othr.orders (id) \n    ON UPDATE SET DEFAULT\n    ON DELETE SET NULL\n    ;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (a,b) REFERENCES othr.orders (c,d) MATCH FULL;\n\nALTER TABLE scha.foo \n  ADD CONSTRAINT my_constraint_fey\n  FOREIGN KEY (a, b) REFERENCES othr.orders (c,d) MATCH SIMPLE;\n\nALTER TABLE ONLY collections.mfield\n    ADD CONSTRAINT col_field_pkey PRIMARY KEY (id);\n\nALTER TABLE collections.mfield\n    ADD CONSTRAINT col_field_pkey PRIMARY KEY (id);\n\n\n-- TODO MATCH after upgrading to newer engine: https://github.com/lfittl/libpg_query/issues/66\n\n-- ALTER TABLE scha.foo \n--   ADD CONSTRAINT my_constraint_fey\n--   FOREIGN KEY (order_id) REFERENCES othr.orders (id) \n--     MATCH FULL\n--     ON UPDATE SET DEFAULT\n--     ON DELETE SET NULL\n--     ;\n\n-- MATCH PARTIAL not yet implemented\n\n-- ALTER TABLE scha.foo \n--   ADD CONSTRAINT my_constraint_fey\n--   FOREIGN KEY (a,b) REFERENCES othr.orders (c,d) MATCH PARTIAL;\n\nALTER TABLE schema_name.table_name ALTER COLUMN column_name SET DATA TYPE new_column_type USING column_name::new_column_type;\nALTER TABLE schema_name.table_name ALTER COLUMN column_name TYPE new_column_type USING column_name::new_column_type;\n\nALTER TABLE schema_name.table_name ADD COLUMN column_name column_type;\nALTER TABLE schema_name.table_name ADD COLUMN column_name Geometry(Polygon, 4326);\nALTER TABLE schema_name.table_name ADD COLUMN \"column-name\" Geometry(Polygon, 4326);\nALTER TABLE schema_name.table_name ADD COLUMN column_name int;\n\nALTER TABLE schema_name.table_name DROP COLUMN column_name;\n\n\n\nALTER TABLE mytable OWNER TO regtest_alter_user2;\n\nALTER FUNCTION alt_func3(int) RENAME TO alt_func4;\nALTER FUNCTION alt_func1(int) RENAME TO alt_func4;\nALTER FUNCTION alt_func3(int) OWNER TO regtest_alter_user2;\nALTER FUNCTION alt_func2(int) OWNER TO regtest_alter_user3;\nALTER FUNCTION alt_func3(int) SET SCHEMA alt_nsp2;      \nALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;\n\nALTER TABLE old_schema_name.table_name\n    SET SCHEMA new_schema_name;\n\nALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2; \nALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;  \n\nALTER SERVER alt_fserv1 RENAME TO alt_fserv2;  \nALTER SERVER alt_fserv1 RENAME TO alt_fserv3;   \n\n\nALTER TYPE test_type2 ADD ATTRIBUTE c text; \nALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;\nALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; \nALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;\nALTER TYPE test_type2 DROP ATTRIBUTE b; \nALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;\nALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; \nALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;\n\nALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;\nCREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));\nALTER TYPE tt_t0 DROP ATTRIBUTE z;\n\n-- CREATE TABLE tt7 (x int, q text, y numeric(8,2)) WITH OIDS;\nALTER TABLE tt7 DROP q;\t\t\t\t\t\t\t\t\n\nALTER TABLE tt1 OF tt_t0;\nALTER TABLE tt7 NOT OF;\n\nALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT \"test_drop_constr_parent_c_check\";\n\nALTER TABLE IF EXISTS tt8 ADD COLUMN f int;\nALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);\nALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);\nALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;\nALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;\nALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;\n\nALTER TABLE IF EXISTS tt8 ADD COLUMN f int;\nALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);\nALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);\nALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;\nALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;\nALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;\n\nALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE int;\nALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE text;\n\nALTER TABLE test_add_column\n\tADD COLUMN IF NOT EXISTS c2 integer,\n\tADD COLUMN IF NOT EXISTS c3 integer,\n\tADD COLUMN c4 integer;\n\nALTER TYPE bogus ADD VALUE 'good';\nALTER TYPE schemaname.bogus ADD VALUE 'good';\nALTER TYPE \"schema-name\".bogus ADD VALUE 'good';\nALTER TYPE \"schema-name\".\"bog-us\" ADD VALUE 'good';\nALTER TYPE \"schema-name\".\"bog-us\" ADD VALUE 'goo''d';\n\nALTER TYPE bogus RENAME TO bogon;\nALTER TYPE test8b ADD ATTRIBUTE c testdomain1;\nALTER TYPE test8b ALTER ATTRIBUTE b TYPE testdomain1;\nREVOKE ALL ON TYPE testtype1 FROM PUBLIC;\n\nALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11);\nALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID;\nALTER DOMAIN things VALIDATE CONSTRAINT meow;\n\nalter domain con add constraint t check (VALUE < 1); -- fails\n\nalter domain con add constraint t check (VALUE < 34);\nalter domain con add check (VALUE > 0);\n\ncreate domain dinter vchar4 check (substring(VALUE, 1, 1) = 'x');\ncreate domain dtop dinter check (substring(VALUE, 2, 1) = '1');\n\nalter domain testdomain1 rename to testdomain2;\nalter type testdomain2 rename to testdomain3;  -- alter type also works\n\ncreate domain testdomain1 as int constraint unsigned check (value > 0);\nalter domain testdomain1 rename constraint unsigned to unsigned_foo;\nalter domain testdomain1 drop constraint unsigned_foo;\ndrop domain testdomain1;\n\nALTER TABLE mytable ADD COLUMN height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED;\n\nALTER SCHEMA schemaname RENAME TO newname;\nALTER SCHEMA schemaname OWNER TO newowner;",
  "alter/default-privs.sql": "ALTER DEFAULT PRIVILEGES IN SCHEMA objects_public\n    GRANT EXECUTE ON FUNCTIONS\n    TO authenticated;\n\nALTER DEFAULT privileges REVOKE EXECUTE ON functions\nFROM\n    public;\n\n\nALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT ON TABLES TO PUBLIC;\n\nALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT INSERT ON TABLES TO webuser;\n\n\nALTER DEFAULT PRIVILEGES IN SCHEMA myschema REVOKE SELECT ON TABLES FROM PUBLIC;\nALTER DEFAULT PRIVILEGES IN SCHEMA myschema REVOKE INSERT ON TABLES FROM webuser;\n\nALTER DEFAULT PRIVILEGES FOR ROLE admin REVOKE EXECUTE ON FUNCTIONS FROM PUBLIC;\n",
  "alter/alter-table-column.sql": "ALTER TABLE public.table1 ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (\n        SEQUENCE NAME public.table1\n        START WITH 1\n        INCREMENT BY 1\n        NO MINVALUE\n        NO MAXVALUE\n        CACHE 1\n    )",
  "define.sql": "CREATE AGGREGATE group_concat(text) (\n    SFUNC = _group_concat,\n    STYPE = text\n);",
  "set/custom.sql": "SET var FROM CURRENT;\n\nRESET client_min_messages;\n\nSET search_path = alt_nsp1, public;\n\nSET SESSION AUTHORIZATION regtest_alter_user1;\n\nSET client_encoding='UNICODE';\n\nSET client_encoding TO 'UNICODE';\n\nSET client_min_messages=notice;\n\nRESET SESSION AUTHORIZATION;\n",
  "comments/custom.sql": "\nCOMMENT ON CONSTRAINT memberships_membership_id_fkey ON roles_public.memberships IS E'@fieldName parent';\nCOMMENT ON DATABASE my_database IS 'Development Database';\nCOMMENT ON DOMAIN my_domain IS 'Email Address Domain';\nCOMMENT ON EXTENSION hstore IS 'implements the hstore data type';\nCOMMENT ON FOREIGN DATA WRAPPER mywrapper IS 'my foreign data wrapper';\nCOMMENT ON FOREIGN TABLE my_foreign_table IS 'Employee Information in other database';\nCOMMENT ON FUNCTION my_function (timestamp) IS 'Returns Roman Numeral';\nCOMMENT ON INDEX my_index IS 'Enforces uniqueness on employee ID';\nCOMMENT ON LANGUAGE plpython IS 'Python support for stored procedures';\nCOMMENT ON LARGE OBJECT 346344 IS 'Planning document';\nCOMMENT ON MATERIALIZED VIEW my_matview IS 'Summary of order history';\nCOMMENT ON OPERATOR ^ (text, text) IS 'Performs intersection of two texts';\nCOMMENT ON OPERATOR - (NONE, integer) IS 'Unary minus';\nCOMMENT ON OPERATOR CLASS int4ops USING btree IS '4 byte integer operators for btrees';\nCOMMENT ON OPERATOR FAMILY integer_ops USING btree IS 'all integer operators for btrees';\nCOMMENT ON POLICY my_policy ON mytable IS 'Filter rows by users';\nCOMMENT ON ROLE my_role IS 'Administration group for finance tables';\nCOMMENT ON RULE my_rule ON my_table IS 'Logs updates of employee records';\nCOMMENT ON SCHEMA my_schema IS 'Departmental data';\nCOMMENT ON SEQUENCE my_sequence IS 'Used to generate primary keys';\nCOMMENT ON SERVER myserver IS 'my foreign server';\nCOMMENT ON STATISTICS my_statistics IS 'Improves planner row estimations';\nCOMMENT ON TABLE my_schema.my_table IS 'Employee Information';\nCOMMENT ON TABLESPACE my_tablespace IS 'Tablespace for indexes';\nCOMMENT ON TEXT SEARCH CONFIGURATION my_config IS 'Special word filtering';\nCOMMENT ON TEXT SEARCH DICTIONARY swedish IS 'Snowball stemmer for Swedish language';\nCOMMENT ON TEXT SEARCH PARSER my_parser IS 'Splits text into words';\nCOMMENT ON TEXT SEARCH TEMPLATE snowball IS 'Snowball stemmer';\nCOMMENT ON TRANSFORM FOR hstore LANGUAGE plpythonu IS 'Transform between hstore and Python dict';\nCOMMENT ON TRIGGER my_trigger ON my_table IS 'Used for RI';\nCOMMENT ON TYPE complex IS 'Complex number data type';\nCOMMENT ON VIEW my_view IS 'View of departmental costs';\n\n\nCOMMENT ON TABLE mytable IS NULL;\n",
  "sequences/sequences.sql": "create sequence foo.bar;\n\nCREATE SEQUENCE mysequence\nINCREMENT 5\nSTART 100;\n\nCREATE SEQUENCE three\nINCREMENT -1\nMINVALUE 1 \nMAXVALUE 3\nSTART 3\nCYCLE;\n\nCREATE SEQUENCE three3\nINCREMENT -1\nMINVALUE 1 \nMAXVALUE 3\nSTART 3\nNO CYCLE;\n\nCREATE SEQUENCE app_jobs.jobs_id_seq\nSTART WITH 1\nINCREMENT BY 1\nNO MINVALUE\nNO MAXVALUE\nCACHE 1;",
  "policies/custom.sql": "CREATE POLICY delete_user ON users.user\nFOR DELETE\nTO authenticated\nUSING (\n    id = current_setting('user.id')::uuid\n);\n\nCREATE POLICY delete_user_no_to ON users.user\nFOR DELETE\nUSING (\n    id = current_setting('user.id')::uuid\n);\n\nCREATE POLICY delete_user_no_to ON users.user\nFOR DELETE\nWITH CHECK (\n    id = current_setting('user.id')::uuid\n);\n\nCREATE POLICY delete_user ON users.\"user\" FOR DELETE TO authenticated USING ((id) = (current_setting('user.id')::uuid));\nCREATE POLICY select_user ON users.\"user\" FOR SELECT TO PUBLIC USING (TRUE);\n\nCREATE POLICY delete_own ON myschema.mytable FOR DELETE TO PUBLIC USING (group_id = ANY (otherschema.my_policy_fn()));\nCREATE POLICY insert_own ON myschema.mytable FOR ALL TO PUBLIC WITH CHECK (group_id = ANY (otherschema.my_policy_fn()));\nCREATE POLICY select_any ON myschema.mytable FOR SELECT TO PUBLIC USING (TRUE);\nCREATE POLICY update_own ON myschema.mytable FOR UPDATE TO PUBLIC USING (group_id = ANY (otherschema.my_policy_fn()));\n\n\nCREATE POLICY delete_pol_permissive ON users.user\nAS PERMISSIVE\nFOR DELETE\nWITH CHECK (\n    id = current_setting('user.id')::uuid\n);\n\nCREATE POLICY delete_pol_restrictive ON users.user\nAS RESTRICTIVE\nFOR DELETE\nWITH CHECK (\n    id = current_setting('user.id')::uuid\n);\n\nALTER POLICY authenticated_can_select_on_user_permissions_select\n    ON perm_schema.user_permissions\n    TO authenticated\n\n    USING ((EXISTS ( SELECT 1\n   FROM acl_schema.mbr_acl acl\n  WHERE (acl.actor_id = jwt_public.current_user_id()))))\n  ;\n\n\nALTER POLICY authenticated_can_select_on_user_permissions_select\n    ON perm_schema.user_permissions\n    TO authenticated\n\n    WITH CHECK ((EXISTS ( SELECT 1\n   FROM acl_schema.mbr_acl acl\n  WHERE (acl.actor_id = jwt_public.current_user_id()))))\n  ;\n\n\nALTER POLICY authenticated_can_select_on_user_permissions_select\n    ON perm_schema.user_permissions\n    TO authenticated\n\n    USING ((EXISTS ( SELECT 1\n   FROM acl_schema.mbr_acl acl\n  WHERE (acl.actor_id = jwt_public.current_user_id()))))\n\n    WITH CHECK ((EXISTS ( SELECT 1\n   FROM acl_schema.mbr_acl acl\n  WHERE (acl.actor_id = jwt_public.current_user_id()))))\n  ;\n\n",
  "grants/custom.sql": "GRANT USAGE ON SCHEMA users TO administrator;\nGRANT EXECUTE ON FUNCTION auth.authenticate TO anonymous;\nGRANT SELECT,INSERT,UPDATE,DELETE ON TABLE auth.token TO administrator;\n\nREVOKE USAGE ON SCHEMA users FROM administrator;\nREVOKE EXECUTE ON FUNCTION auth.authenticate FROM anonymous;\nREVOKE SELECT,INSERT,UPDATE,DELETE ON TABLE auth.token FROM administrator;\n\nGRANT SELECT, INSERT ON someschema.sometable2 TO somerole; \n\nGRANT UPDATE (col2) ON someschema.sometable2 TO somerole;\nGRANT UPDATE (col2,col3) ON someschema.sometable2 TO somerole;\nGRANT UPDATE (col2,\"another-column\") ON someschema.sometable2 TO somerole;\nGRANT INSERT (col2), UPDATE (col2,\"another-column\"), DELETE ON someschema.sometable2 TO somerole;\nGRANT INSERT (col2,col3) ON someschema.sometable2 TO somerole;\nGRANT INSERT (col2,\"another-column\") ON someschema.sometable2 TO somerole;\n",
  "types/composite.sql": "CREATE TYPE myschema.mycustomtype AS (\n  id uuid,\n  verify_code text,\n  verify_code_expires_on TIMESTAMPTZ,\n  actor_id uuid\n);\n",
  "domains/create.sql": "CREATE DOMAIN v8.json AS json;\n\nCREATE DOMAIN email AS citext\n  CHECK ( value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$' );\n",
  "indexes/custom.sql": "CREATE INDEX CONCURRENTLY boom_merkle_tree_tag_created_reference_idx ON boom.merkle_tree (tag, created, reference);\n\nCREATE UNIQUE INDEX databases_database_unique_name_idx ON databases.database (\n  tenant_id, database_name_hash(name)\n);\n\nCREATE UNIQUE INDEX boom_worktree_idx ON boom.worktree (tag, reference, created, DECODE(MD5(LOWER(path)), 'hex'));\n\nCREATE UNIQUE INDEX uniq_service_when_not_null\n  ON schema2.table3 (uid, svc)\n  WHERE svc IS NOT NULL;\n\nCREATE UNIQUE INDEX new_unique_idx ON new_example(a, b) INCLUDE (c);\n\nCREATE INDEX CONCURRENTLY idx_with_operator ON boom.merkle_tree USING GIN ( name gin_trgm_ops ( param1 = 32, param2 = true) );\n",
  "enums/create.sql": "CREATE TYPE myschema.special_type AS enum (\n  'oh',\n  'yea'\n);",
  "enums/alter.sql": "ALTER TYPE electronic_mail RENAME TO email;\n\nALTER TYPE email OWNER TO joe;\nALTER TYPE email SET SCHEMA customers;\nALTER TYPE compfoo ADD ATTRIBUTE f3 int;\nALTER TYPE colors ADD VALUE 'orange' AFTER 'red';\nALTER TYPE colors ADD VALUE 'orange' BEFORE 'red';\n\nALTER TYPE enum_type ADD VALUE 'new_value';\n\n",
  "do/custom.sql": "DO $$\nBEGIN\n    IF NOT EXISTS (\n            SELECT\n                1\n            FROM\n                pg_roles\n            WHERE\n                rolname = 'administrator') THEN\n            CREATE ROLE administrator;\n            COMMENT ON ROLE administrator IS 'Administration group';\n    END IF;\nEND $$;\n",
  "statements/insert.sql": "INSERT INTO shoelace_data\n  VALUES (1, 2, 3, 'truth', TRUE);\n\nINSERT INTO shoelace_data (id, col1, col2, val1, bl2)\n  VALUES (1, 2, 3, 'truth', TRUE);\n\nINSERT INTO shoelace_data DEFAULT VALUES;\n\nINSERT INTO foo (f2,f3)\n  VALUES ('test', DEFAULT), ('More', 11), (upper('more'), 7+9)\n  RETURNING *, f1+f3 AS sum;\n\nINSERT INTO customers (name, email)\nVALUES\n\t(\n\t\t'Microsoft',\n\t\t'hotline@microsoft.com'\n\t) \nON CONFLICT (id, project_id) \nDO\n\t\tUPDATE\n\t  SET \n        email = EXCLUDED.email || ';' || customers.email,\n        level = customers.level + 1,\n        other = EXCLUDED.other\n    RETURNING *;\n\n\nINSERT INTO v8.modules (name, code)\n  VALUES ('ajv', $code$ (function () { var module = { exports: { } };\nvar exports = module.exports;\n\n/* plv8 bundle begins */\n\n/* plv8 bundle ends */\nreturn module; \n\n})(); $code$);\n",
  "statements/update.sql": "UPDATE update_test SET c = repeat('x', 10000) WHERE c = 'car';\n\nUPDATE update_test SET (b,a) = (select a+1,b from update_test where a = 1000)\n  WHERE a = 11;\n\nUPDATE something SET (b,a) = (1,2)\n  WHERE a = 11;\n\n\nUPDATE update_test SET (c,b,a) = ('bugle', b+11, DEFAULT) WHERE c = 'foo';\n\nUPDATE shoelace_data\n       SET sl_name = NEW.sl_name,\n           sl_avail = NEW.sl_avail,\n           sl_color = NEW.sl_color,\n           sl_len = NEW.sl_len,\n           sl_unit = NEW.sl_unit\n     WHERE sl_name = OLD.sl_name;\n\nUPDATE something SET a = 1\nRETURNING a;\n\nUPDATE something SET a = 1\nRETURNING a AS b, c;\n\nUPDATE something SET a = 1\nFROM b;\n\nUPDATE something SET a = 1, b = 'b'\nFROM c JOIN d ON (x = d.y), (SELECT * FROM e) f\nWHERE something.x = d.x AND LEAST(something.y, 0) = f.z + 1;\n\nUPDATE something SET a = 1\nRETURNING b AS \"b#1\";\n\nUPDATE something SET a = 1\nFROM b\nWHERE c\nRETURNING *;\n\nUPDATE foo SET f2 = lower(f2), f3 = DEFAULT RETURNING foo.*, f1+f3 AS sum13;\n",
  "statements/select.sql": "WITH regional_sales AS (\n        SELECT region, SUM(amount) AS total_sales\n        FROM orders\n        GROUP BY region\n     ), top_regions AS (\n        SELECT region\n        FROM regional_sales\n        WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)\n     )\nSELECT region,\n       product,\n       SUM(quantity) AS product_units,\n       SUM(amount) AS product_sales\nFROM orders\nWHERE region IN (SELECT region FROM top_regions)\nGROUP BY region, product;\n\nwith chars2bits AS (\n    select\n        character,\n        (index - 1)::bit(5)::text AS index\n    from unnest('{a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,2,3,4,5,6,7}'::text[]) with ordinality as t (character, index)\n)\nselect string_agg(c.index, '')\nfrom regexp_split_to_table('abcde', '') s\ninner join chars2bits c ON (s = c.character);\n\nselect\n        character,\n        (index - 1)::bit(5)::text AS index\n    from unnest('{a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,2,3,4,5,6,7}'::text[]) with ordinality as t (character, index);",
  "statements/cte.sql": "WITH regional_sales AS (\n        SELECT region, SUM(amount) AS total_sales\n        FROM orders\n        GROUP BY region\n     ), top_regions AS NOT MATERIALIZED (\n        SELECT region\n        FROM regional_sales\n        WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)\n     ), flop_regions AS MATERIALIZED (\n        SELECT region\n        FROM regional_sales\n        WHERE total_sales < (SELECT SUM(total_sales)/10 FROM regional_sales)\n     )\nSELECT region,\n       product,\n       SUM(quantity) AS product_units,\n       SUM(amount) AS product_sales\nFROM orders\nWHERE region IN (SELECT region FROM top_regions) OR region IN (SELECT region FROM flop_regions)\nGROUP BY region, product;\n",
  "statements/conflicts.sql": "INSERT INTO yo.table (project_id, name, field_name)\n  VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value)\n  ON CONFLICT (project_id, name)\n  DO\n  UPDATE\n  SET\n    field_name = EXCLUDED.field_name;\n\n\nINSERT INTO yo.table (project_id, name, field_name)\n  VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value)\n  ON CONFLICT (project_id, name)\n  DO\n  UPDATE\n  SET\n    field_name = EXCLUDED.field_name\n  WHERE prop = 1;\n\nINSERT INTO yo.table (project_id, name, field_name)\n  VALUES (v_obj_key_id, v_secret_name::bytea, v_secret_value)\n  ON CONFLICT (project_id, name)\n  DO NOTHING;\n\nINSERT INTO customers (NAME, email)\nVALUES\n\t(\n\t\t'Microsoft',\n\t\t'hotline@microsoft.com'\n\t) \nON CONFLICT \nON CONSTRAINT customers_name_key \nDO NOTHING;\n\n\nINSERT INTO customers (name, email)\nVALUES\n\t(\n\t\t'Microsoft',\n\t\t'hotline@microsoft.com'\n\t) \nON CONFLICT (name) \nDO\n\t\tUPDATE\n\t  SET email = EXCLUDED.email || ';' || customers.email;",
  "statements/delete.sql": "DELETE FROM shoelace_data\n     WHERE sl_name = OLD.sl_name;\n\nDELETE FROM delete_test AS dt WHERE dt.a > 75;\n\nDELETE FROM delete_test dt WHERE delete_test.a > 25;\n\nDELETE FROM delete_test WHERE a > 25;",
  "statements/alias.sql": "SELECT * FROM generate_series(1, 1) \"a#b\";\n\nSELECT * FROM generate_series(1, 1) \"a#b\"(\"c#d\");\n\n\nSELECT * FROM generate_series(1, 1) \"aba\";\n\nSELECT * FROM generate_series(1, 1) \"aba\"(\"ccd\");\n",
  "tables/match.sql": "-- this works in postgres, just NOT here, maybe need to upgrade the binary?\n\nDROP TABLE IF EXISTS users CASCADE;\nCREATE TABLE users (\n  id integer NOT NULL PRIMARY KEY\n);\n\nDROP TABLE IF EXISTS post_type CASCADE;\nCREATE TABLE post_type (\n  id integer NOT NULL PRIMARY KEY\n);\n\nDROP TABLE IF EXISTS assembly_seat CASCADE;\nCREATE TABLE assembly_seat (\n  id integer NOT NULL PRIMARY KEY\n);\n\n-- TODO MATCH after upgrading to newer engine: https://github.com/lfittl/libpg_query/issues/66\n-- DROP TABLE IF EXISTS post CASCADE;\n-- CREATE TABLE post (\n--   post_id serial NOT NULL\n--  ,revision integer NOT NULL DEFAULT 0\n--  ,summary text NOT NULL\n--  ,description text NOT NULL\n--  ,user_id integer NOT NULL\n--     REFERENCES users (id) MATCH FULL ON UPDATE CASCADE ON DELETE RESTRICT\n--  ,post_type_id integer NOT NULL\n--     REFERENCES post_type (id) MATCH FULL ON UPDATE CASCADE ON DELETE RESTRICT\n--  ,ctime timestamptz DEFAULT NOW()\n--  ,PRIMARY KEY(post_id, revision)\n-- );\n\n-- DROP TABLE IF EXISTS post_state CASCADE;\n-- CREATE TABLE post_state (\n--   post_id integer NOT NULL\n--  ,revision integer NOT NULL\n--  ,assembly_seat_id integer NOT NULL\n--     REFERENCES assembly_seat (id) MATCH FULL ON UPDATE CASCADE ON DELETE RESTRICT\n--  ,PRIMARY KEY(post_id, revision)\n--  ,FOREIGN KEY (post_id, revision) REFERENCES post (post_id, revision)\n-- );",
  "tables/temp.sql": "\nDROP TABLE IF EXISTS users CASCADE;\nCREATE TEMP TABLE users (\n  id integer NOT NULL PRIMARY KEY\n);\n\nDROP TABLE IF EXISTS post_type CASCADE;\nCREATE TEMP TABLE post_type (\n  id integer NOT NULL PRIMARY KEY\n);\n\nDROP TABLE IF EXISTS assembly_seat CASCADE;\nCREATE TEMP TABLE assembly_seat (\n  id integer NOT NULL PRIMARY KEY\n);\n\n-- TODO MATCH after upgrading to newer engine: https://github.com/lfittl/libpg_query/issues/66\n\n-- DROP TABLE IF EXISTS post CASCADE;\n-- CREATE TEMP TABLE post (\n--   post_id serial NOT NULL\n--  ,revision integer NOT NULL DEFAULT 0\n--  ,summary text NOT NULL\n--  ,description text NOT NULL\n--  ,user_id integer NOT NULL\n--     REFERENCES users (id) MATCH FULL ON UPDATE CASCADE ON DELETE RESTRICT\n--  ,post_type_id integer NOT NULL\n--     REFERENCES post_type (id) MATCH FULL ON UPDATE CASCADE ON DELETE RESTRICT\n--  ,ctime timestamptz DEFAULT NOW()\n--  ,PRIMARY KEY(post_id, revision)\n-- );\n\n-- DROP TABLE IF EXISTS post_state CASCADE;\n-- CREATE TEMP TABLE post_state (\n--   post_id integer NOT NULL\n--  ,revision integer NOT NULL\n--  ,assembly_seat_id integer NOT NULL\n--     REFERENCES assembly_seat (id) MATCH FULL ON UPDATE CASCADE ON DELETE RESTRICT\n--  ,PRIMARY KEY(post_id, revision)\n--  ,FOREIGN KEY (post_id, revision) REFERENCES post (post_id, revision)\n-- );",
  "tables/custom.sql": "ALTER TABLE myschema.role\n    ADD CONSTRAINT fk_myschema_role_actor_id\n    FOREIGN KEY (actor_id)\n    REFERENCES actors.actor (id)\n    ON DELETE CASCADE;\n\nCREATE TABLE circles (\n    c circle,\n    EXCLUDE USING gist (c WITH &&)\n);\n\nCREATE TABLE actors_private.actor_info (\n    actor_id uuid PRIMARY KEY REFERENCES actors.actor (id) ON DELETE CASCADE,\n    email text NOT NULL UNIQUE CHECK (email ~* '^.+@.+\\..+$'),\n    password_hash text NOT NULL\n);\n\n\n-- one row with (1,1)\nCREATE TABLE foo ( a int, b int,\n  PRIMARY KEY (a,b)\n);\n\n--\n-- two child tables to reference it\n-- \nCREATE TABLE t_full ( a int, b int,\n  FOREIGN KEY (a,b) REFERENCES foo MATCH FULL\n);\n\nCREATE TABLE t_simple ( a int, b int,\n  FOREIGN KEY (a,b) REFERENCES foo MATCH SIMPLE\n);\n\n\nCREATE TABLE people(\n    color_id int GENERATED ALWAYS AS IDENTITY (START WITH 17 INCREMENT BY 21),\n    height_cm numeric,\n    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED,\n    gen_def_identity numeric GENERATED BY DEFAULT AS IDENTITY,\n    gen_alw_identity numeric GENERATED ALWAYS AS IDENTITY\n);",
  "tables/check.sql": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0)\n);\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CONSTRAINT positive_price CHECK (price > 0)\n);\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0),\n    discounted_price numeric CHECK (discounted_price > 0),\n    CHECK (price > discounted_price)\n);\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0),\n    discounted_price numeric CONSTRAINT check_price CHECK (discounted_price > 0),\n    CHECK (price > discounted_price)\n);\n\nCREATE TABLE boomin (d date, CHECK (false) NO INHERIT NOT VALID);\nCREATE TABLE boomin (d date, CHECK (true) NO INHERIT NOT VALID);\n\nALTER TABLE checkitout\n  ADD CHECK (d between '2010-01-01'::date and '2010-12-31'::date) NOT VALID;\n\nALTER TABLE checkitout2\n  ADD CHECK (d NOT BETWEEN '2010-01-01'::date and '2010-12-31'::date) NOT VALID;\n\ncreate table atacc3 (test3 int) inherits (atacc1, atacc2);\n",
  "tables/defaults.sql": "CREATE TABLE \"customer_product_categories\" (\n  id serial PRIMARY KEY,\n  name text NOT NULL,\n  effective tstzrange DEFAULT '[-infinity,infinity]'\n)\n",
  "tables/exclude.sql": "CREATE TABLE circles (\n    c circle,\n    EXCLUDE USING gist (c WITH &&)\n);\nCREATE TABLE \"customer_product_categories\" (\n  \"id\" serial PRIMARY KEY,\n  \"name\" text NOT NULL,\n  \"effective\" tstzrange DEFAULT '[-infinity,infinity]',\n  EXCLUDE USING gist (LOWER(\"name\") WITH =, \"effective\" WITH &&)\n)\n",
  "tables/foreign.sql": "CREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    product_no integer REFERENCES products (product_no),\n    quantity integer\n);\nCREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    product_no integer REFERENCES products,\n    quantity integer\n);\nCREATE TABLE t1 (\n  a integer PRIMARY KEY,\n  b integer,\n  c integer,\n  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)\n);\nCREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);\nCREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    shipping_address text\n);\nCREATE TABLE order_items (\n    product_no integer REFERENCES products,\n    order_id integer REFERENCES orders,\n    quantity integer,\n    PRIMARY KEY (product_no, order_id)\n);\n",
  "tables/nulls.sql": "CREATE TABLE products (\n    product_no integer NOT NULL,\n    name text NOT NULL,\n    price numeric\n);\nCREATE TABLE products (\n    product_no integer NULL,\n    name text NULL,\n    price numeric NULL\n);\nCREATE TABLE products (\n    product_no integer NOT NULL,\n    name text NOT NULL,\n    price numeric NOT NULL CHECK (price > 0)\n);\n",
  "tables/on_delete.sql": "CREATE TABLE order_items (\n    product_no integer REFERENCES products ON DELETE RESTRICT,\n    order_id integer REFERENCES orders ON DELETE CASCADE,\n    quantity integer,\n    PRIMARY KEY (product_no, order_id)\n);\n",
  "tables/on_update.sql": "CREATE TABLE order_items (\n    product_no integer REFERENCES products ON UPDATE RESTRICT,\n    order_id integer REFERENCES orders ON UPDATE CASCADE,\n    quantity integer,\n    PRIMARY KEY (product_no, order_id)\n);\n",
  "tables/unique.sql": "CREATE TABLE products (\n    product_no integer UNIQUE,\n    name text,\n    price numeric\n);\nCREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric,\n    UNIQUE (product_no)\n);\nCREATE TABLE example (\n    a integer,\n    b integer,\n    c integer,\n    UNIQUE (a, c)\n);\nCREATE TABLE products (\n    product_no integer CONSTRAINT must_be_different UNIQUE,\n    name text,\n    price numeric\n);\n",
  "functions/basic.sql": "CREATE OR REPLACE FUNCTION someschema.myfunc (some_id uuid, other_id uuid) RETURNS void\nAS $$\nUPDATE\n    mytable\nSET\n    ref_id = new_ref_id\nWHERE\n    id = some_id;\n$$\nLANGUAGE 'sql' VOLATILE;\n\nCREATE OR REPLACE FUNCTION someschema.myfunc (some_id uuid, other_id uuid) RETURNS obj.geo\nAS $$\nUPDATE\n    mytable\nSET\n    ref_id = new_ref_id\nWHERE\n    id = some_id;\n$$\nLANGUAGE 'sql' VOLATILE;",
  "functions/returns_table.sql": "CREATE OR REPLACE FUNCTION someschema.myfunc (some_id obj.geo_type, other_id obj.geo_type) RETURNS TABLE (path text, name integer)\nAS $$\nSELECT * FROM\n    mytable\n$$\nLANGUAGE 'sql' VOLATILE;\n",
  "functions/returns_trigger.sql": "CREATE OR REPLACE FUNCTION helpers.some_method ()\n    RETURNS TRIGGER\nAS $$\nBEGIN\n    IF tg_op = 'INSERT' THEN\n        NEW.some_prop = helpers.do_magic (NEW.data);\n        RETURN NEW;\n    END IF;\nEND;\n$$\nLANGUAGE 'plpgsql';\n",
  "functions/setof.sql": "CREATE OR REPLACE FUNCTION someschema.myfunc (some_id uuid, other_id uuid) RETURNS SETOF obj.geo\nAS $$\nUPDATE\n    mytable\nSET\n    ref_id = new_ref_id\nWHERE\n    id = some_id\n$$\nLANGUAGE 'sql' VOLATILE;\n\nCREATE OR REPLACE FUNCTION someschema.myfunc (some_id obj.geo_type, other_id obj.geo_type) RETURNS SETOF obj.geo\nAS $$\nUPDATE\n    mytable\nSET\n    ref_id = new_ref_id\nWHERE\n    id = some_id\n$$\nLANGUAGE 'sql' VOLATILE;\n",
  "roles/create.sql": "CREATE ROLE app_anonymous;\nCREATE ROLE app_authenticated;\nCREATE ROLE app_user LOGIN PASSWORD 'xyz';\n\nCREATE ROLE miriam WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';\n\nCREATE ROLE admin1 WITH LOGIN PASSWORD 'jw8s0F4' CREATEDB CREATEROLE INHERIT;\n\nCREATE ROLE admin2 WITH NOLOGIN NOCREATEDB NOCREATEROLE;\n\nCREATE ROLE authy WITH ADMIN app_authenticated;\n",
  "roles/grants.sql": "-- GRANT ALL ON SCHEMA alt_nsp1, alt_nsp2 TO public;\n\nGRANT app_authenticated TO app_user;\nGRANT app_authenticated, app_anonymous TO app_user;\n\nGRANT app_authenticated, app_anonymous TO app_user, super_app_user;\n",
  "rules/create.sql": "CREATE RULE collections_ins_protect AS ON INSERT TO dbs.collections\n    DO INSTEAD\n    NOTHING;\n\nCREATE RULE collections_upd_protect AS ON UPDATE\n    TO dbs.collections\n        DO INSTEAD\n        NOTHING;\n\nCREATE RULE collections_del_protect AS ON DELETE TO dbs.collections\n    DO INSTEAD\n    NOTHING;\n\nCREATE RULE shoelace_upd AS ON UPDATE TO shoelace\n    DO INSTEAD\n    UPDATE shoelace_data\n       SET sl_name = NEW.sl_name,\n           sl_avail = NEW.sl_avail,\n           sl_color = NEW.sl_color,\n           sl_len = NEW.sl_len,\n           sl_unit = NEW.sl_unit\n     WHERE sl_name = OLD.sl_name;\n\nCREATE RULE shoelace_del AS ON DELETE TO shoelace\n    DO INSTEAD\n    DELETE FROM shoelace_data\n     WHERE sl_name = OLD.sl_name;\n\n\nCREATE RULE \"_RETURN\" AS\n    ON SELECT TO t2\n    DO INSTEAD \n        SELECT * FROM t1;\n\nCREATE RULE log_shoelace AS ON UPDATE TO shoelace_data\n    WHERE NEW.sl_avail <> OLD.sl_avail\n    DO INSERT INTO shoelace_log VALUES (\n                                    NEW.sl_name,\n                                    NEW.sl_avail,\n                                    current_user,\n                                    current_timestamp\n                                );\n\nCREATE RULE shoelace_ins AS ON INSERT TO shoelace\n    DO INSTEAD\n    INSERT INTO shoelace_data VALUES (\n           NEW.sl_name,\n           NEW.sl_avail,\n           NEW.sl_color,\n           NEW.sl_len,\n           NEW.sl_unit\n    );\n\n",
  "views/create.sql": "CREATE VIEW collaboration_public.direct_project_permits AS\nSELECT * FROM permits;\n\nCREATE MATERIALIZED VIEW collaboration_public.direct_project_permits AS\nSELECT * FROM permits;\n\nCREATE VIEW superschema.app_columns AS\nSELECT\n    attname AS name,\n    t.typname AS TYPE,\n    c.relname AS table_name,\n    n.nspname AS schema_name\nFROM\n    pg_attribute a\n    JOIN pg_type t ON (t.oid = a.atttypid)\n    JOIN pg_class c ON (c.oid = a.attrelid)\n    JOIN pg_namespace n ON (n.oid = c.relnamespace)\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast')\n    AND attnum > 0\n    AND NOT attisdropped\nORDER BY\n    attnum;\n\nCREATE VIEW superschema.app_columns AS\nSELECT\n    attname AS name,\n    t.typname AS TYPE,\n    c.relname AS table_name,\n    n.nspname AS schema_name\nFROM\n    pg_attribute a\n    JOIN pg_type t ON (t.oid = a.atttypid)\n    JOIN pg_class c ON (c.oid = a.attrelid)\n    JOIN pg_namespace n ON (n.oid = c.relnamespace)\nWHERE\n    n.nspname IN ('pg_catalog', 'information_schema', 'pg_toast')\n    AND attnum > 0\n    AND NOT attisdropped\nORDER BY\n    attnum;\n",
  "views/replace.sql": "CREATE OR REPLACE VIEW public.view_ticket AS\n SELECT a.id,\n    a.name,\n    a.project,\n    a.search,\n    a.labels,\n    a.minutes,\n    b.name AS \"user\",\n    b.email,\n    b.language,\n    b.photo,\n    b.company,\n    a.iduser,\n    a.iduserlast,\n    a.idsolver,\n    a.issolved,\n    a.ispriority,\n    b.isnotification,\n    a.datecreated,\n    a.dateupdated,\n    b.minutes AS minutesuser,\n    a.idsolution,\n    b.\"position\",\n    a.countcomments\n   FROM tbl_ticket a\n     JOIN tbl_user b ON b.id::text = a.iduser::text\n  WHERE a.isremoved = false",
  "transactions/begin_commit.sql": "BEGIN;\nCREATE TABLE products (\n    product_no integer,\n    name text\n);\nCOMMIT;\n",
  "transactions/lock.sql": "CREATE TABLE foo (\n  id SERIAL PRIMARY KEY\n);\n\nCREATE TABLE bar (\n  id SERIAL PRIMARY KEY\n);\n\nBEGIN;\nLOCK foo;\nCOMMIT;\n\nBEGIN;\nLOCK TABLE ONLY foo NOWAIT;\nCOMMIT;\n\nBEGIN;\nLOCK TABLE foo, bar IN ROW SHARE MODE;\nCOMMIT;\n\nBEGIN;\nLOCK TABLE foo, bar IN SHARE MODE;\nCOMMIT;\n\nBEGIN;\nLOCK ONLY bar IN SHARE UPDATE EXCLUSIVE MODE;\nCOMMIT;",
  "triggers/create.sql": "CREATE TRIGGER _100_timestamps BEFORE INSERT OR UPDATE ON app_jobs.jobs\nFOR EACH ROW EXECUTE PROCEDURE app_jobs.update_timestamps();\n\nCREATE TRIGGER _500_increase_job_queue_count AFTER INSERT ON app_jobs.jobs\nFOR EACH ROW EXECUTE PROCEDURE app_jobs.jobs__increase_job_queue_count();\n\nCREATE TRIGGER _500_decrease_job_queue_count BEFORE DELETE ON app_jobs.jobs\nFOR EACH ROW EXECUTE PROCEDURE app_jobs.jobs__decrease_job_queue_count();\n\nCREATE TRIGGER _900_notify_worker AFTER INSERT ON app_jobs.jobs\nFOR EACH STATEMENT EXECUTE PROCEDURE app_jobs.do_notify('jobs:insert');\n\nCREATE TRIGGER check_update\n    BEFORE UPDATE OF balance ON accounts\n    FOR EACH ROW\n    EXECUTE PROCEDURE check_account_update();\n\nCREATE TRIGGER check_update\n    BEFORE UPDATE ON accounts\n    FOR EACH ROW\n    EXECUTE PROCEDURE check_account_update();\n\nCREATE TRIGGER check_update\n    BEFORE UPDATE ON accounts\n    FOR EACH ROW\n    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)\n    EXECUTE PROCEDURE check_account_update();\n\nCREATE TRIGGER log_update\n    AFTER UPDATE ON accounts\n    FOR EACH ROW\n    WHEN (OLD.* IS DISTINCT FROM NEW.*)\n    EXECUTE PROCEDURE log_account_update();\n\nCREATE TRIGGER view_insert\n    INSTEAD OF INSERT ON my_view\n    FOR EACH ROW\n    EXECUTE PROCEDURE view_insert_row();\n\nCREATE TRIGGER transfer_insert\n    AFTER INSERT ON transfer\n    REFERENCING NEW TABLE AS inserted\n    FOR EACH STATEMENT\n    EXECUTE PROCEDURE check_transfer_balances_to_zero();\n\nCREATE TRIGGER paired_items_update\n    AFTER UPDATE ON paired_items\n    REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab\n    FOR EACH ROW\n    EXECUTE PROCEDURE check_matching_pairs();\n\nCREATE TRIGGER paired_items_update\n    AFTER UPDATE ON paired_items\n    REFERENCING OLD TABLE AS oldtab NEW TABLE AS newtab\n    FOR EACH ROW\n    EXECUTE PROCEDURE check_matching_pairs();\n",
  "triggers/custom.sql": "DROP SCHEMA IF EXISTS fb;\nDROP SCHEMA IF EXISTS fb CASCADE;\nCREATE SCHEMA fb;\nSET search_path TO fb,\"$user\",public;\nCREATE EXTENSION \"uuid-ossp\";\n\nCREATE TABLE \"user\" (\n  id            uuid PRIMARY KEY DEFAULT uuid_generate_v4(),\n  created       timestamptz NOT NULL DEFAULT now(),\n  full_name     text NOT NULL DEFAULT ''\n);\n\n\nCREATE TABLE post (\n  id            uuid PRIMARY KEY DEFAULT uuid_generate_v4(),\n  created       timestamptz NOT NULL DEFAULT now(),\n  content       text NOT NULL DEFAULT '',\n  \"user\"        uuid REFERENCES \"user\" NOT NULL\n);\n\n\nCREATE TABLE friendship (\n  first         uuid REFERENCES \"user\" NOT NULL,\n  second        uuid REFERENCES \"user\" NOT NULL,\n  created       timestamptz NOT NULL DEFAULT now(),\n  UNIQUE (first, second)\n);\n\nCREATE FUNCTION check_friendship_symmetry() RETURNS TRIGGER AS $$\nDECLARE\n  link friendship;\nBEGIN\n  SELECT * INTO link FROM friendship\n   WHERE second = NEW.first AND first = NEW.second;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Friendships must be INSERTed as pairs.';\n  END IF;\n  RETURN NEW;\nEND\n$$ LANGUAGE plpgsql\n   SET search_path FROM CURRENT;\n\nCREATE CONSTRAINT TRIGGER friendship_symmetry\nAFTER INSERT ON friendship\nDEFERRABLE INITIALLY DEFERRED\nFOR EACH ROW\nEXECUTE PROCEDURE check_friendship_symmetry();\n\ncreate trigger _500_increase_job_queue_count_update\nafter update of queue_name on app.jobs\nfor each row execute procedure app.jobs__increase_job_queue_count();\n",
  "complex.sql": "SELECT\n  p1.playerid,\n  f1.playername,\n  p2.playerid,\n  f2.playername\nFROM\n  player f1,\n  player f2,\n  plays p1 FULL OUTER JOIN plays p2 ON p1.playerid < p2.playerid AND p1.teamid = p2.teamid\nGROUP BY\n  p1.playerid,\n  f1.playerid,\n  p2.playerid,\n  f2.playerid\nHAVING\n  count(p1.playerid) = count(*) AND count(p2.playerid) = count(*) AND p1.playerid = f1.playerid AND p2.playerid = f2.playerid;\n",
  "custom.sql": "SELECT * FROM tab ORDER BY col USING <;\n\nSELECT * FROM tab ORDER BY col USING >;\n\nSELECT * FROM tab ORDER BY col USING =;\n\nSELECT * FROM tab ORDER BY col USING = NULLS FIRST, col2 USING < NULLS LAST;\n\nSELECT mleast(VARIADIC arr := ARRAY[10, -1, 5, 4.4]);\n\nSELECT encode(E'''123\\\\000\\\\001', 'base64');\n\nSELECT U&'\\0441\\043B\\043E\\043D';\n\nSELECT U&'d\\0061t\\+000061';\n\nSELECT 3 OPERATOR(pg_catalog.+) 4;\n\nSELECT * FROM ROWS FROM( getfoo6(1) AS (fooid int, foosubid int, fooname text), getfoo7(1) as (fooid int, foosubid int, fooname text) ) AS (fooid int, foosubid int, fooname text);\n\nselect a from b where a < (select 1);\n\nselect a from b where a < all (select 1);\n\nselect a from b where a < any (select 1);\n\nselect a from b where exists (select 1);\n\nselect a from b where a < ARRAY (select distinct (select 1), (select distinct 1 group by 7 having 1 < (select 1)));\n\nSELECT 1 WHERE 'abc' SIMILAR TO 'abc';\n\nSELECT 1 WHERE 'abc' SIMILAR TO test('test');\n\nSELECT 1 WHERE 'abc' SIMILAR TO test('test') ESCAPE 't';\n\nselect 1::bit;\n\nSET client_encoding='UNICODE';\n\nSET client_encoding TO 'UNICODE';\n\nSET client_min_messages=notice;\n\nSHOW client_encoding;\n",
  "param-ref.sql": "SELECT\n  *\nFROM\n  table_name\nWHERE\n  name = ?;\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  name = $1;\n\nSELECT\n  $1::text as name;\n",
  "query-001.sql": "SELECT\n  array_agg(players),\n  player_teams\nFROM\n  (SELECT DISTINCT\n    t1.t1player AS players_dist,\n    t1.player_teams\n  FROM\n    (SELECT\n      p.playerid AS t1id,\n      concat(p.playerid, ':', p.playername, ' ') AS t1player,\n      array_agg(pl.teamid ORDER BY pl.teamid) AS player_teams\n    FROM player p\n    LEFT JOIN plays pl ON p.playerid = pl.playerid\n    GROUP BY p.playerid, p.playername\n    ) t1\nINNER JOIN (\n  SELECT\n    p.playerid AS t2id,\n    array_agg(pl.teamid ORDER BY pl.teamid) AS player_teams\n  FROM player p\n  LEFT JOIN plays pl ON p.playerid = pl.playerid\n  GROUP BY p.playerid, p.playername\n) t2 ON t1.player_teams=t2.player_teams AND t1.t1id <> t2.t2id\n) innerQuery\nGROUP BY player_teams;\n",
  "query-002.sql": "SELECT * from \"Foo\" f1\nWHERE f1.\"FooUID\" = (\n   SELECT f2.\"FooUID\" FROM \"Foo\" f2\n   LEFT JOIN \"Bar\" b ON f2.\"BarUID\" = b.\"BarUID\"\n   WHERE f2.\"BarUID\" IS NOT NULL AND b.\"BarUID\" IS NULL\n   LIMIT 1\n)",
  "query-003.sql": "SELECT ((SELECT ROW(1,1,1,1)::test)::test).*;",
  "simple.sql": "SELECT\n  *\nFROM\n  table_name\nWHERE\n  name = 'test' AND num > 7 AND\n  last_name LIKE '%''test''%';\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  name = 'test' AND num > 7 AND\n  last_name NOT LIKE '%''test''%';\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  name = 'test' AND num > 7 AND\n  last_name ILIKE '%''test''%';\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  name = 'test' AND num > 7 AND\n  last_name NOT ILIKE '%''test''%';\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  last_name SIMILAR TO '%(b|d)%';\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  last_name SIMILAR TO '%(b|d)%' ESCAPE 'a';\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  last_name NOT SIMILAR TO '%(b|d)%';\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  last_name NOT SIMILAR TO '%(b|d)%' ESCAPE 'a';\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  last_name > first_name;\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  last_name <> first_name;\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  last_name = ANY (stuff);\n\nSELECT\n  *\nFROM\n  table_name\nWHERE\n  last_name = ALL (stuff);\n\nSELECT\n    title,\n    category_id\nFROM\n    film\nINNER JOIN film_category\n        USING(film_id)\nWHERE\n    category_id = ANY(\n        SELECT\n            category_id\n        FROM\n            category\n        WHERE\n            NAME = 'Action'\n            OR NAME = 'Drama'\n    );\n\nSELECT\n    title,\n    category_id\nFROM\n    film\nINNER JOIN film_category\n        USING(film_id)\nWHERE\n    category_id IN(\n        SELECT\n            category_id\n        FROM\n            category\n        WHERE\n            NAME = 'Action'\n            OR NAME = 'Drama'\n    );\n\n    SELECT\n    title,\n    category_id\nFROM\n    film\nINNER JOIN film_category\n        USING(film_id)\nWHERE\n    category_id NOT IN(\n        SELECT\n            category_id\n        FROM\n            category\n        WHERE\n            NAME = 'Action'\n            OR NAME = 'Drama'\n    );\n\nSELECT title\nFROM film\nWHERE length >= ANY(\n    SELECT MAX( length )\n    FROM film\n    INNER JOIN film_category USING(film_id)\n    GROUP BY  category_id );\n\nSELECT * FROM transactions.transaction\n  WHERE\ntransaction_date\nBETWEEN to_date('2020-01-01','YYYY-MM-DD') AND to_date('2020-12-31','YYYY-MM-DD')\nAND owner=0;\n\nSELECT * FROM transactions.transaction\n  WHERE\ntransaction_date\nNOT BETWEEN to_date('2020-01-01','YYYY-MM-DD') AND to_date('2020-12-31','YYYY-MM-DD')\nAND owner=0;",
  "upstream/abstime.sql": "--\n-- ABSTIME\n-- testing built-in time type abstime\n-- uses reltime and tinterval\n--\n\n--\n-- timezones may vary based not only on location but the operating\n-- system.  the main correctness issue is that the OS may not get\n-- daylight savings time right for times prior to Unix epoch (jan 1 1970).\n--\n\nCREATE TABLE ABSTIME_TBL (f1 abstime);\n\nBEGIN;\nINSERT INTO ABSTIME_TBL (f1) VALUES (abstime 'now');\nINSERT INTO ABSTIME_TBL (f1) VALUES (abstime 'now');\nSELECT count(*) AS two FROM ABSTIME_TBL WHERE f1 = 'now' ;\nEND;\n\nDELETE FROM ABSTIME_TBL;\n\nINSERT INTO ABSTIME_TBL (f1) VALUES ('Jan 14, 1973 03:14:21');\nINSERT INTO ABSTIME_TBL (f1) VALUES (abstime 'Mon May  1 00:30:30 1995');\nINSERT INTO ABSTIME_TBL (f1) VALUES (abstime 'epoch');\nINSERT INTO ABSTIME_TBL (f1) VALUES (abstime 'infinity');\nINSERT INTO ABSTIME_TBL (f1) VALUES (abstime '-infinity');\nINSERT INTO ABSTIME_TBL (f1) VALUES (abstime 'May 10, 1947 23:59:12');\n\n-- what happens if we specify slightly misformatted abstime?\nINSERT INTO ABSTIME_TBL (f1) VALUES ('Feb 35, 1946 10:00:00');\nINSERT INTO ABSTIME_TBL (f1) VALUES ('Feb 28, 1984 25:08:10');\n\n-- badly formatted abstimes:  these should result in invalid abstimes\nINSERT INTO ABSTIME_TBL (f1) VALUES ('bad date format');\nINSERT INTO ABSTIME_TBL (f1) VALUES ('Jun 10, 1843');\n\n-- test abstime operators\n\nSELECT '' AS eight, * FROM ABSTIME_TBL;\n\nSELECT '' AS six, * FROM ABSTIME_TBL\n   WHERE ABSTIME_TBL.f1 < abstime 'Jun 30, 2001';\n\nSELECT '' AS six, * FROM ABSTIME_TBL\n   WHERE ABSTIME_TBL.f1 > abstime '-infinity';\n\nSELECT '' AS six, * FROM ABSTIME_TBL\n   WHERE abstime 'May 10, 1947 23:59:12' <> ABSTIME_TBL.f1;\n\nSELECT '' AS three, * FROM ABSTIME_TBL\n   WHERE abstime 'epoch' >= ABSTIME_TBL.f1;\n\nSELECT '' AS four, * FROM ABSTIME_TBL\n   WHERE ABSTIME_TBL.f1 <= abstime 'Jan 14, 1973 03:14:21';\n\n-- SELECT '' AS four, * FROM ABSTIME_TBL\n--   WHERE ABSTIME_TBL.f1 <?>\n-- \ttinterval '[\"Apr 1 1950 00:00:00\" \"Dec 30 1999 23:00:00\"]';\n\nSELECT '' AS four, f1 AS abstime,\n  date_part('year', f1) AS year, date_part('month', f1) AS month,\n  date_part('day',f1) AS day, date_part('hour', f1) AS hour,\n  date_part('minute', f1) AS minute, date_part('second', f1) AS second\n  FROM ABSTIME_TBL\n  WHERE isfinite(f1)\n  ORDER BY abstime;\n",
  "upstream/advisory_lock.sql": "--\n-- ADVISORY LOCKS\n--\n\nBEGIN;\n\nSELECT\n\tpg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),\n\tpg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);\n\nSELECT locktype, classid, objid, objsubid, mode, granted\n\tFROM pg_locks WHERE locktype = 'advisory'\n\tORDER BY classid, objid, objsubid;\n\n\n-- pg_advisory_unlock_all() shouldn't release xact locks\nSELECT pg_advisory_unlock_all();\n\nSELECT count(*) FROM pg_locks WHERE locktype = 'advisory';\n\n\n-- can't unlock xact locks\nSELECT\n\tpg_advisory_unlock(1), pg_advisory_unlock_shared(2),\n\tpg_advisory_unlock(1, 1), pg_advisory_unlock_shared(2, 2);\n\n\n-- automatically release xact locks at commit\nCOMMIT;\n\nSELECT count(*) FROM pg_locks WHERE locktype = 'advisory';\n\n\nBEGIN;\n\n-- holding both session and xact locks on the same objects, xact first\nSELECT\n\tpg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),\n\tpg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);\n\nSELECT locktype, classid, objid, objsubid, mode, granted\n\tFROM pg_locks WHERE locktype = 'advisory'\n\tORDER BY classid, objid, objsubid;\n\nSELECT\n\tpg_advisory_lock(1), pg_advisory_lock_shared(2),\n\tpg_advisory_lock(1, 1), pg_advisory_lock_shared(2, 2);\n\nROLLBACK;\n\nSELECT locktype, classid, objid, objsubid, mode, granted\n\tFROM pg_locks WHERE locktype = 'advisory'\n\tORDER BY classid, objid, objsubid;\n\n\n-- unlocking session locks\nSELECT\n\tpg_advisory_unlock(1), pg_advisory_unlock(1),\n\tpg_advisory_unlock_shared(2), pg_advisory_unlock_shared(2),\n\tpg_advisory_unlock(1, 1), pg_advisory_unlock(1, 1),\n\tpg_advisory_unlock_shared(2, 2), pg_advisory_unlock_shared(2, 2);\n\nSELECT count(*) FROM pg_locks WHERE locktype = 'advisory';\n\n\nBEGIN;\n\n-- holding both session and xact locks on the same objects, session first\nSELECT\n\tpg_advisory_lock(1), pg_advisory_lock_shared(2),\n\tpg_advisory_lock(1, 1), pg_advisory_lock_shared(2, 2);\n\nSELECT locktype, classid, objid, objsubid, mode, granted\n\tFROM pg_locks WHERE locktype = 'advisory'\n\tORDER BY classid, objid, objsubid;\n\nSELECT\n\tpg_advisory_xact_lock(1), pg_advisory_xact_lock_shared(2),\n\tpg_advisory_xact_lock(1, 1), pg_advisory_xact_lock_shared(2, 2);\n\nROLLBACK;\n\nSELECT locktype, classid, objid, objsubid, mode, granted\n\tFROM pg_locks WHERE locktype = 'advisory'\n\tORDER BY classid, objid, objsubid;\n\n\n-- releasing all session locks\nSELECT pg_advisory_unlock_all();\n\nSELECT count(*) FROM pg_locks WHERE locktype = 'advisory';\n\n\nBEGIN;\n\n-- grabbing txn locks multiple times\n\nSELECT\n\tpg_advisory_xact_lock(1), pg_advisory_xact_lock(1),\n\tpg_advisory_xact_lock_shared(2), pg_advisory_xact_lock_shared(2),\n\tpg_advisory_xact_lock(1, 1), pg_advisory_xact_lock(1, 1),\n\tpg_advisory_xact_lock_shared(2, 2), pg_advisory_xact_lock_shared(2, 2);\n\nSELECT locktype, classid, objid, objsubid, mode, granted\n\tFROM pg_locks WHERE locktype = 'advisory'\n\tORDER BY classid, objid, objsubid;\n\nCOMMIT;\n\nSELECT count(*) FROM pg_locks WHERE locktype = 'advisory';\n\n-- grabbing session locks multiple times\n\nSELECT\n\tpg_advisory_lock(1), pg_advisory_lock(1),\n\tpg_advisory_lock_shared(2), pg_advisory_lock_shared(2),\n\tpg_advisory_lock(1, 1), pg_advisory_lock(1, 1),\n\tpg_advisory_lock_shared(2, 2), pg_advisory_lock_shared(2, 2);\n\nSELECT locktype, classid, objid, objsubid, mode, granted\n\tFROM pg_locks WHERE locktype = 'advisory'\n\tORDER BY classid, objid, objsubid;\n\nSELECT\n\tpg_advisory_unlock(1), pg_advisory_unlock(1),\n\tpg_advisory_unlock_shared(2), pg_advisory_unlock_shared(2),\n\tpg_advisory_unlock(1, 1), pg_advisory_unlock(1, 1),\n\tpg_advisory_unlock_shared(2, 2), pg_advisory_unlock_shared(2, 2);\n\nSELECT count(*) FROM pg_locks WHERE locktype = 'advisory';\n\n-- .. and releasing them all at once\n\nSELECT\n\tpg_advisory_lock(1), pg_advisory_lock(1),\n\tpg_advisory_lock_shared(2), pg_advisory_lock_shared(2),\n\tpg_advisory_lock(1, 1), pg_advisory_lock(1, 1),\n\tpg_advisory_lock_shared(2, 2), pg_advisory_lock_shared(2, 2);\n\nSELECT locktype, classid, objid, objsubid, mode, granted\n\tFROM pg_locks WHERE locktype = 'advisory'\n\tORDER BY classid, objid, objsubid;\n\nSELECT pg_advisory_unlock_all();\n\nSELECT count(*) FROM pg_locks WHERE locktype = 'advisory';\n",
  "upstream/bitmapops.sql": "-- Test bitmap AND and OR\n\n\n-- Generate enough data that we can test the lossy bitmaps.\n\n-- There's 55 tuples per page in the table. 53 is just\n-- below 55, so that an index scan with qual a = constant\n-- will return at least one hit per page. 59 is just above\n-- 55, so that an index scan with qual b = constant will return\n-- hits on most but not all pages. 53 and 59 are prime, so that\n-- there's a maximum number of a,b combinations in the table.\n-- That allows us to test all the different combinations of\n-- lossy and non-lossy pages with the minimum amount of data\n\nCREATE TABLE bmscantest (a int, b int, t text);\n\nINSERT INTO bmscantest\n  SELECT (r%53), (r%59), 'foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'\n  FROM generate_series(1,70000) r;\n\nCREATE INDEX i_bmtest_a ON bmscantest(a);\nCREATE INDEX i_bmtest_b ON bmscantest(b);\n\n-- We want to use bitmapscans. With default settings, the planner currently\n-- chooses a bitmap scan for the queries below anyway, but let's make sure.\nset enable_indexscan=false;\nset enable_seqscan=false;\n\n-- Lower work_mem to trigger use of lossy bitmaps\nset work_mem = 64;\n\n\n-- Test bitmap-and.\nSELECT count(*) FROM bmscantest WHERE a = 1 AND b = 1;\n\n-- Test bitmap-or.\nSELECT count(*) FROM bmscantest WHERE a = 1 OR b = 1;\n\n\n-- clean up\nDROP TABLE bmscantest;\n",
  "upstream/boolean.sql": "--\n-- BOOLEAN\n--\n\n--\n-- sanity check - if this fails go insane!\n--\nSELECT 1 AS one;\n\n\n-- ******************testing built-in type bool********************\n\n-- check bool input syntax\n\nSELECT true AS true;\n\nSELECT false AS false;\n\nSELECT bool 't' AS true;\n\nSELECT bool '   f           ' AS false;\n\nSELECT bool 'true' AS true;\n\nSELECT bool 'test' AS error;\n\nSELECT bool 'false' AS false;\n\nSELECT bool 'foo' AS error;\n\nSELECT bool 'y' AS true;\n\nSELECT bool 'yes' AS true;\n\nSELECT bool 'yeah' AS error;\n\nSELECT bool 'n' AS false;\n\nSELECT bool 'no' AS false;\n\nSELECT bool 'nay' AS error;\n\nSELECT bool 'on' AS true;\n\nSELECT bool 'off' AS false;\n\nSELECT bool 'of' AS false;\n\nSELECT bool 'o' AS error;\n\nSELECT bool 'on_' AS error;\n\nSELECT bool 'off_' AS error;\n\nSELECT bool '1' AS true;\n\nSELECT bool '11' AS error;\n\nSELECT bool '0' AS false;\n\nSELECT bool '000' AS error;\n\nSELECT bool '' AS error;\n\n-- and, or, not in qualifications\n\nSELECT bool 't' or bool 'f' AS true;\n\nSELECT bool 't' and bool 'f' AS false;\n\nSELECT not bool 'f' AS true;\n\nSELECT bool 't' = bool 'f' AS false;\n\nSELECT bool 't' <> bool 'f' AS true;\n\nSELECT bool 't' > bool 'f' AS true;\n\nSELECT bool 't' >= bool 'f' AS true;\n\nSELECT bool 'f' < bool 't' AS true;\n\nSELECT bool 'f' <= bool 't' AS true;\n\n-- explicit casts to/from text\nSELECT 'TrUe'::text::boolean AS true, 'fAlse'::text::boolean AS false;\nSELECT '    true   '::text::boolean AS true,\n       '     FALSE'::text::boolean AS false;\nSELECT true::boolean::text AS true, false::boolean::text AS false;\n\nSELECT '  tru e '::text::boolean AS invalid;    -- error\nSELECT ''::text::boolean AS invalid;            -- error\n\nCREATE TABLE BOOLTBL1 (f1 bool);\n\nINSERT INTO BOOLTBL1 (f1) VALUES (bool 't');\n\nINSERT INTO BOOLTBL1 (f1) VALUES (bool 'True');\n\nINSERT INTO BOOLTBL1 (f1) VALUES (bool 'true');\n\n\n-- BOOLTBL1 should be full of true's at this point\nSELECT '' AS t_3, BOOLTBL1.* FROM BOOLTBL1;\n\n\nSELECT '' AS t_3, BOOLTBL1.*\n   FROM BOOLTBL1\n   WHERE f1 = bool 'true';\n\n\nSELECT '' AS t_3, BOOLTBL1.*\n   FROM BOOLTBL1\n   WHERE f1 <> bool 'false';\n\nSELECT '' AS zero, BOOLTBL1.*\n   FROM BOOLTBL1\n   WHERE booleq(bool 'false', f1);\n\nINSERT INTO BOOLTBL1 (f1) VALUES (bool 'f');\n\nSELECT '' AS f_1, BOOLTBL1.*\n   FROM BOOLTBL1\n   WHERE f1 = bool 'false';\n\n\nCREATE TABLE BOOLTBL2 (f1 bool);\n\nINSERT INTO BOOLTBL2 (f1) VALUES (bool 'f');\n\nINSERT INTO BOOLTBL2 (f1) VALUES (bool 'false');\n\nINSERT INTO BOOLTBL2 (f1) VALUES (bool 'False');\n\nINSERT INTO BOOLTBL2 (f1) VALUES (bool 'FALSE');\n\n-- This is now an invalid expression\n-- For pre-v6.3 this evaluated to false - thomas 1997-10-23\nINSERT INTO BOOLTBL2 (f1)\n   VALUES (bool 'XXX');\n\n-- BOOLTBL2 should be full of false's at this point\nSELECT '' AS f_4, BOOLTBL2.* FROM BOOLTBL2;\n\n\nSELECT '' AS tf_12, BOOLTBL1.*, BOOLTBL2.*\n   FROM BOOLTBL1, BOOLTBL2\n   WHERE BOOLTBL2.f1 <> BOOLTBL1.f1;\n\n\nSELECT '' AS tf_12, BOOLTBL1.*, BOOLTBL2.*\n   FROM BOOLTBL1, BOOLTBL2\n   WHERE boolne(BOOLTBL2.f1,BOOLTBL1.f1);\n\n\nSELECT '' AS ff_4, BOOLTBL1.*, BOOLTBL2.*\n   FROM BOOLTBL1, BOOLTBL2\n   WHERE BOOLTBL2.f1 = BOOLTBL1.f1 and BOOLTBL1.f1 = bool 'false';\n\n\nSELECT '' AS tf_12_ff_4, BOOLTBL1.*, BOOLTBL2.*\n   FROM BOOLTBL1, BOOLTBL2\n   WHERE BOOLTBL2.f1 = BOOLTBL1.f1 or BOOLTBL1.f1 = bool 'true'\n   ORDER BY BOOLTBL1.f1, BOOLTBL2.f1;\n\n--\n-- SQL syntax\n-- Try all combinations to ensure that we get nothing when we expect nothing\n-- - thomas 2000-01-04\n--\n\nSELECT '' AS \"True\", f1\n   FROM BOOLTBL1\n   WHERE f1 IS TRUE;\n\nSELECT '' AS \"Not False\", f1\n   FROM BOOLTBL1\n   WHERE f1 IS NOT FALSE;\n\nSELECT '' AS \"False\", f1\n   FROM BOOLTBL1\n   WHERE f1 IS FALSE;\n\nSELECT '' AS \"Not True\", f1\n   FROM BOOLTBL1\n   WHERE f1 IS NOT TRUE;\n\nSELECT '' AS \"True\", f1\n   FROM BOOLTBL2\n   WHERE f1 IS TRUE;\n\nSELECT '' AS \"Not False\", f1\n   FROM BOOLTBL2\n   WHERE f1 IS NOT FALSE;\n\nSELECT '' AS \"False\", f1\n   FROM BOOLTBL2\n   WHERE f1 IS FALSE;\n\nSELECT '' AS \"Not True\", f1\n   FROM BOOLTBL2\n   WHERE f1 IS NOT TRUE;\n\n--\n-- Clean up\n-- Many tables are retained by the regression test, but these do not seem\n--  particularly useful so just get rid of them for now.\n--  - thomas 1997-11-30\n--\n\nDROP TABLE  BOOLTBL1;\n\nDROP TABLE  BOOLTBL2;\n",
  "upstream/char.sql": "--\n-- CHAR\n--\n\n-- fixed-length by value\n-- internally passed by value if <= 4 bytes in storage\n\nSELECT char 'c' = char 'c' AS true;\n\n--\n-- Build a table for testing\n--\n\nCREATE TABLE CHAR_TBL(f1 char);\n\nINSERT INTO CHAR_TBL (f1) VALUES ('a');\n\nINSERT INTO CHAR_TBL (f1) VALUES ('A');\n\n-- any of the following three input formats are acceptable\nINSERT INTO CHAR_TBL (f1) VALUES ('1');\n\nINSERT INTO CHAR_TBL (f1) VALUES (2);\n\nINSERT INTO CHAR_TBL (f1) VALUES ('3');\n\n-- zero-length char\nINSERT INTO CHAR_TBL (f1) VALUES ('');\n\n-- try char's of greater than 1 length\nINSERT INTO CHAR_TBL (f1) VALUES ('cd');\nINSERT INTO CHAR_TBL (f1) VALUES ('c     ');\n\n\nSELECT '' AS seven, * FROM CHAR_TBL;\n\nSELECT '' AS six, c.*\n   FROM CHAR_TBL c\n   WHERE c.f1 <> 'a';\n\nSELECT '' AS one, c.*\n   FROM CHAR_TBL c\n   WHERE c.f1 = 'a';\n\nSELECT '' AS five, c.*\n   FROM CHAR_TBL c\n   WHERE c.f1 < 'a';\n\nSELECT '' AS six, c.*\n   FROM CHAR_TBL c\n   WHERE c.f1 <= 'a';\n\nSELECT '' AS one, c.*\n   FROM CHAR_TBL c\n   WHERE c.f1 > 'a';\n\nSELECT '' AS two, c.*\n   FROM CHAR_TBL c\n   WHERE c.f1 >= 'a';\n\nDROP TABLE CHAR_TBL;\n\n--\n-- Now test longer arrays of char\n--\n\nCREATE TABLE CHAR_TBL(f1 char(4));\n\nINSERT INTO CHAR_TBL (f1) VALUES ('a');\nINSERT INTO CHAR_TBL (f1) VALUES ('ab');\nINSERT INTO CHAR_TBL (f1) VALUES ('abcd');\nINSERT INTO CHAR_TBL (f1) VALUES ('abcde');\nINSERT INTO CHAR_TBL (f1) VALUES ('abcd    ');\n\nSELECT '' AS four, * FROM CHAR_TBL;\n",
  "upstream/circle.sql": "--\n-- CIRCLE\n--\n\nCREATE TABLE CIRCLE_TBL (f1 circle);\n\nINSERT INTO CIRCLE_TBL VALUES ('<(5,1),3>');\n\nINSERT INTO CIRCLE_TBL VALUES ('<(1,2),100>');\n\nINSERT INTO CIRCLE_TBL VALUES ('1,3,5');\n\nINSERT INTO CIRCLE_TBL VALUES ('((1,2),3)');\n\nINSERT INTO CIRCLE_TBL VALUES ('<(100,200),10>');\n\nINSERT INTO CIRCLE_TBL VALUES ('<(100,1),115>');\n\n-- bad values\n\nINSERT INTO CIRCLE_TBL VALUES ('<(-100,0),-100>');\n\nINSERT INTO CIRCLE_TBL VALUES ('1abc,3,5');\n\nINSERT INTO CIRCLE_TBL VALUES ('(3,(1,2),3)');\n\nSELECT * FROM CIRCLE_TBL;\n\nSELECT '' AS six, center(f1) AS center\n  FROM CIRCLE_TBL;\n\nSELECT '' AS six, radius(f1) AS radius\n  FROM CIRCLE_TBL;\n\nSELECT '' AS six, diameter(f1) AS diameter\n  FROM CIRCLE_TBL;\n\nSELECT '' AS two, f1 FROM CIRCLE_TBL WHERE radius(f1) < 5;\n\nSELECT '' AS four, f1 FROM CIRCLE_TBL WHERE diameter(f1) >= 10;\n\nSELECT '' as five, c1.f1 AS one, c2.f1 AS two, (c1.f1 <-> c2.f1) AS distance\n  FROM CIRCLE_TBL c1, CIRCLE_TBL c2\n  WHERE (c1.f1 < c2.f1) AND ((c1.f1 <-> c2.f1) > 0)\n  ORDER BY distance, area(c1.f1), area(c2.f1);\n",
  "upstream/comments.sql": "--\n-- COMMENTS\n--\n\nSELECT 'trailing' AS first; -- trailing single line\nSELECT /* embedded single line */ 'embedded' AS second;\nSELECT /* both embedded and trailing single line */ 'both' AS third; -- trailing single line\n\nSELECT 'before multi-line' AS fourth;\n/* This is an example of SQL which should not execute:\n * select 'multi-line';\n */\nSELECT 'after multi-line' AS fifth;\n\n--\n-- Nested comments\n--\n\n/*\nSELECT 'trailing' as x1; -- inside block comment\n*/\n\n/* This block comment surrounds a query which itself has a block comment...\nSELECT /* embedded single line */ 'embedded' AS x2;\n*/\n\nSELECT -- continued after the following block comments...\n/* Deeply nested comment.\n   This includes a single apostrophe to make sure we aren't decoding this part as a string.\nSELECT 'deep nest' AS n1;\n/* Second level of nesting...\nSELECT 'deeper nest' as n2;\n/* Third level of nesting...\nSELECT 'deepest nest' as n3;\n*/\nHoo boy. Still two deep...\n*/\nNow just one deep...\n*/\n'deeply nested example' AS sixth;\n\n/* and this is the end of the file */\n",
  "upstream/create_misc.sql": "--\n-- CREATE_MISC\n--\n\n-- CLASS POPULATION\n--\t(any resemblance to real life is purely coincidental)\n--\n\nINSERT INTO tenk2 SELECT * FROM tenk1;\n\nSELECT * INTO TABLE onek2 FROM onek;\n\nINSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;\n\nSELECT *\n   INTO TABLE Bprime\n   FROM tenk1\n   WHERE unique2 < 1000;\n\nINSERT INTO hobbies_r (name, person)\n   SELECT 'posthacking', p.name\n   FROM person* p\n   WHERE p.name = 'mike' or p.name = 'jeff';\n\nINSERT INTO hobbies_r (name, person)\n   SELECT 'basketball', p.name\n   FROM person p\n   WHERE p.name = 'joe' or p.name = 'sally';\n\nINSERT INTO hobbies_r (name) VALUES ('skywalking');\n\nINSERT INTO equipment_r (name, hobby) VALUES ('advil', 'posthacking');\n\nINSERT INTO equipment_r (name, hobby) VALUES ('peet''s coffee', 'posthacking');\n\nINSERT INTO equipment_r (name, hobby) VALUES ('hightops', 'basketball');\n\nINSERT INTO equipment_r (name, hobby) VALUES ('guts', 'skywalking');\n\nSELECT *\n   INTO TABLE ramp\n   FROM road\n   WHERE name ~ '.*Ramp';\n\nINSERT INTO ihighway\n   SELECT *\n   FROM road\n   WHERE name ~ 'I- .*';\n\nINSERT INTO shighway\n   SELECT *\n   FROM road\n   WHERE name ~ 'State Hwy.*';\n\nUPDATE shighway\n   SET surface = 'asphalt';\n\nINSERT INTO a_star (class, a) VALUES ('a', 1);\n\nINSERT INTO a_star (class, a) VALUES ('a', 2);\n\nINSERT INTO a_star (class) VALUES ('a');\n\nINSERT INTO b_star (class, a, b) VALUES ('b', 3, 'mumble'::text);\n\nINSERT INTO b_star (class, a) VALUES ('b', 4);\n\nINSERT INTO b_star (class, b) VALUES ('b', 'bumble'::text);\n\nINSERT INTO b_star (class) VALUES ('b');\n\nINSERT INTO c_star (class, a, c) VALUES ('c', 5, 'hi mom'::name);\n\nINSERT INTO c_star (class, a) VALUES ('c', 6);\n\nINSERT INTO c_star (class, c) VALUES ('c', 'hi paul'::name);\n\nINSERT INTO c_star (class) VALUES ('c');\n\nINSERT INTO d_star (class, a, b, c, d)\n   VALUES ('d', 7, 'grumble'::text, 'hi sunita'::name, '0.0'::float8);\n\nINSERT INTO d_star (class, a, b, c)\n   VALUES ('d', 8, 'stumble'::text, 'hi koko'::name);\n\nINSERT INTO d_star (class, a, b, d)\n   VALUES ('d', 9, 'rumble'::text, '1.1'::float8);\n\nINSERT INTO d_star (class, a, c, d)\n   VALUES ('d', 10, 'hi kristin'::name, '10.01'::float8);\n\nINSERT INTO d_star (class, b, c, d)\n   VALUES ('d', 'crumble'::text, 'hi boris'::name, '100.001'::float8);\n\nINSERT INTO d_star (class, a, b)\n   VALUES ('d', 11, 'fumble'::text);\n\nINSERT INTO d_star (class, a, c)\n   VALUES ('d', 12, 'hi avi'::name);\n\nINSERT INTO d_star (class, a, d)\n   VALUES ('d', 13, '1000.0001'::float8);\n\nINSERT INTO d_star (class, b, c)\n   VALUES ('d', 'tumble'::text, 'hi andrew'::name);\n\nINSERT INTO d_star (class, b, d)\n   VALUES ('d', 'humble'::text, '10000.00001'::float8);\n\nINSERT INTO d_star (class, c, d)\n   VALUES ('d', 'hi ginger'::name, '100000.000001'::float8);\n\nINSERT INTO d_star (class, a) VALUES ('d', 14);\n\nINSERT INTO d_star (class, b) VALUES ('d', 'jumble'::text);\n\nINSERT INTO d_star (class, c) VALUES ('d', 'hi jolly'::name);\n\nINSERT INTO d_star (class, d) VALUES ('d', '1000000.0000001'::float8);\n\nINSERT INTO d_star (class) VALUES ('d');\n\nINSERT INTO e_star (class, a, c, e)\n   VALUES ('e', 15, 'hi carol'::name, '-1'::int2);\n\nINSERT INTO e_star (class, a, c)\n   VALUES ('e', 16, 'hi bob'::name);\n\nINSERT INTO e_star (class, a, e)\n   VALUES ('e', 17, '-2'::int2);\n\nINSERT INTO e_star (class, c, e)\n   VALUES ('e', 'hi michelle'::name, '-3'::int2);\n\nINSERT INTO e_star (class, a)\n   VALUES ('e', 18);\n\nINSERT INTO e_star (class, c)\n   VALUES ('e', 'hi elisa'::name);\n\nINSERT INTO e_star (class, e)\n   VALUES ('e', '-4'::int2);\n\nINSERT INTO f_star (class, a, c, e, f)\n   VALUES ('f', 19, 'hi claire'::name, '-5'::int2, '(1,3),(2,4)'::polygon);\n\nINSERT INTO f_star (class, a, c, e)\n   VALUES ('f', 20, 'hi mike'::name, '-6'::int2);\n\nINSERT INTO f_star (class, a, c, f)\n   VALUES ('f', 21, 'hi marcel'::name, '(11,44),(22,55),(33,66)'::polygon);\n\nINSERT INTO f_star (class, a, e, f)\n   VALUES ('f', 22, '-7'::int2, '(111,555),(222,666),(333,777),(444,888)'::polygon);\n\nINSERT INTO f_star (class, c, e, f)\n   VALUES ('f', 'hi keith'::name, '-8'::int2,\n\t   '(1111,3333),(2222,4444)'::polygon);\n\nINSERT INTO f_star (class, a, c)\n   VALUES ('f', 24, 'hi marc'::name);\n\nINSERT INTO f_star (class, a, e)\n   VALUES ('f', 25, '-9'::int2);\n\nINSERT INTO f_star (class, a, f)\n   VALUES ('f', 26, '(11111,33333),(22222,44444)'::polygon);\n\nINSERT INTO f_star (class, c, e)\n   VALUES ('f', 'hi allison'::name, '-10'::int2);\n\nINSERT INTO f_star (class, c, f)\n   VALUES ('f', 'hi jeff'::name,\n           '(111111,333333),(222222,444444)'::polygon);\n\nINSERT INTO f_star (class, e, f)\n   VALUES ('f', '-11'::int2, '(1111111,3333333),(2222222,4444444)'::polygon);\n\nINSERT INTO f_star (class, a) VALUES ('f', 27);\n\nINSERT INTO f_star (class, c) VALUES ('f', 'hi carl'::name);\n\nINSERT INTO f_star (class, e) VALUES ('f', '-12'::int2);\n\nINSERT INTO f_star (class, f)\n   VALUES ('f', '(11111111,33333333),(22222222,44444444)'::polygon);\n\nINSERT INTO f_star (class) VALUES ('f');\n\n\n--\n-- for internal portal (cursor) tests\n--\nCREATE TABLE iportaltest (\n\ti\t\tint4,\n\td\t\tfloat4,\n\tp\t\tpolygon\n);\n\nINSERT INTO iportaltest (i, d, p)\n   VALUES (1, 3.567, '(3.0,1.0),(4.0,2.0)'::polygon);\n\nINSERT INTO iportaltest (i, d, p)\n   VALUES (2, 89.05, '(4.0,2.0),(3.0,1.0)'::polygon);\n",
  "upstream/date.sql": "--\n-- DATE\n--\n\nCREATE TABLE DATE_TBL (f1 date);\n\nINSERT INTO DATE_TBL VALUES ('1957-04-09');\nINSERT INTO DATE_TBL VALUES ('1957-06-13');\nINSERT INTO DATE_TBL VALUES ('1996-02-28');\nINSERT INTO DATE_TBL VALUES ('1996-02-29');\nINSERT INTO DATE_TBL VALUES ('1996-03-01');\nINSERT INTO DATE_TBL VALUES ('1996-03-02');\nINSERT INTO DATE_TBL VALUES ('1997-02-28');\nINSERT INTO DATE_TBL VALUES ('1997-02-29');\nINSERT INTO DATE_TBL VALUES ('1997-03-01');\nINSERT INTO DATE_TBL VALUES ('1997-03-02');\nINSERT INTO DATE_TBL VALUES ('2000-04-01');\nINSERT INTO DATE_TBL VALUES ('2000-04-02');\nINSERT INTO DATE_TBL VALUES ('2000-04-03');\nINSERT INTO DATE_TBL VALUES ('2038-04-08');\nINSERT INTO DATE_TBL VALUES ('2039-04-09');\nINSERT INTO DATE_TBL VALUES ('2040-04-10');\n\nSELECT f1 AS \"Fifteen\" FROM DATE_TBL;\n\nSELECT f1 AS \"Nine\" FROM DATE_TBL WHERE f1 < '2000-01-01';\n\nSELECT f1 AS \"Three\" FROM DATE_TBL\n  WHERE f1 BETWEEN '2000-01-01' AND '2001-01-01';\n\n--\n-- Check all the documented input formats\n--\nSET datestyle TO iso;  -- display results in ISO\n\nSET datestyle TO ymd;\n\nSELECT date 'January 8, 1999';\nSELECT date '1999-01-08';\nSELECT date '1999-01-18';\nSELECT date '1/8/1999';\nSELECT date '1/18/1999';\nSELECT date '18/1/1999';\nSELECT date '01/02/03';\nSELECT date '19990108';\nSELECT date '990108';\nSELECT date '1999.008';\nSELECT date 'J2451187';\nSELECT date 'January 8, 99 BC';\n\nSELECT date '99-Jan-08';\nSELECT date '1999-Jan-08';\nSELECT date '08-Jan-99';\nSELECT date '08-Jan-1999';\nSELECT date 'Jan-08-99';\nSELECT date 'Jan-08-1999';\nSELECT date '99-08-Jan';\nSELECT date '1999-08-Jan';\n\nSELECT date '99 Jan 08';\nSELECT date '1999 Jan 08';\nSELECT date '08 Jan 99';\nSELECT date '08 Jan 1999';\nSELECT date 'Jan 08 99';\nSELECT date 'Jan 08 1999';\nSELECT date '99 08 Jan';\nSELECT date '1999 08 Jan';\n\nSELECT date '99-01-08';\nSELECT date '1999-01-08';\nSELECT date '08-01-99';\nSELECT date '08-01-1999';\nSELECT date '01-08-99';\nSELECT date '01-08-1999';\nSELECT date '99-08-01';\nSELECT date '1999-08-01';\n\nSELECT date '99 01 08';\nSELECT date '1999 01 08';\nSELECT date '08 01 99';\nSELECT date '08 01 1999';\nSELECT date '01 08 99';\nSELECT date '01 08 1999';\nSELECT date '99 08 01';\nSELECT date '1999 08 01';\n\nSET datestyle TO dmy;\n\nSELECT date 'January 8, 1999';\nSELECT date '1999-01-08';\nSELECT date '1999-01-18';\nSELECT date '1/8/1999';\nSELECT date '1/18/1999';\nSELECT date '18/1/1999';\nSELECT date '01/02/03';\nSELECT date '19990108';\nSELECT date '990108';\nSELECT date '1999.008';\nSELECT date 'J2451187';\nSELECT date 'January 8, 99 BC';\n\nSELECT date '99-Jan-08';\nSELECT date '1999-Jan-08';\nSELECT date '08-Jan-99';\nSELECT date '08-Jan-1999';\nSELECT date 'Jan-08-99';\nSELECT date 'Jan-08-1999';\nSELECT date '99-08-Jan';\nSELECT date '1999-08-Jan';\n\nSELECT date '99 Jan 08';\nSELECT date '1999 Jan 08';\nSELECT date '08 Jan 99';\nSELECT date '08 Jan 1999';\nSELECT date 'Jan 08 99';\nSELECT date 'Jan 08 1999';\nSELECT date '99 08 Jan';\nSELECT date '1999 08 Jan';\n\nSELECT date '99-01-08';\nSELECT date '1999-01-08';\nSELECT date '08-01-99';\nSELECT date '08-01-1999';\nSELECT date '01-08-99';\nSELECT date '01-08-1999';\nSELECT date '99-08-01';\nSELECT date '1999-08-01';\n\nSELECT date '99 01 08';\nSELECT date '1999 01 08';\nSELECT date '08 01 99';\nSELECT date '08 01 1999';\nSELECT date '01 08 99';\nSELECT date '01 08 1999';\nSELECT date '99 08 01';\nSELECT date '1999 08 01';\n\nSET datestyle TO mdy;\n\nSELECT date 'January 8, 1999';\nSELECT date '1999-01-08';\nSELECT date '1999-01-18';\nSELECT date '1/8/1999';\nSELECT date '1/18/1999';\nSELECT date '18/1/1999';\nSELECT date '01/02/03';\nSELECT date '19990108';\nSELECT date '990108';\nSELECT date '1999.008';\nSELECT date 'J2451187';\nSELECT date 'January 8, 99 BC';\n\nSELECT date '99-Jan-08';\nSELECT date '1999-Jan-08';\nSELECT date '08-Jan-99';\nSELECT date '08-Jan-1999';\nSELECT date 'Jan-08-99';\nSELECT date 'Jan-08-1999';\nSELECT date '99-08-Jan';\nSELECT date '1999-08-Jan';\n\nSELECT date '99 Jan 08';\nSELECT date '1999 Jan 08';\nSELECT date '08 Jan 99';\nSELECT date '08 Jan 1999';\nSELECT date 'Jan 08 99';\nSELECT date 'Jan 08 1999';\nSELECT date '99 08 Jan';\nSELECT date '1999 08 Jan';\n\nSELECT date '99-01-08';\nSELECT date '1999-01-08';\nSELECT date '08-01-99';\nSELECT date '08-01-1999';\nSELECT date '01-08-99';\nSELECT date '01-08-1999';\nSELECT date '99-08-01';\nSELECT date '1999-08-01';\n\nSELECT date '99 01 08';\nSELECT date '1999 01 08';\nSELECT date '08 01 99';\nSELECT date '08 01 1999';\nSELECT date '01 08 99';\nSELECT date '01 08 1999';\nSELECT date '99 08 01';\nSELECT date '1999 08 01';\n\n-- Check upper and lower limits of date range\nSELECT date '4714-11-24 BC';\nSELECT date '4714-11-23 BC';  -- out of range\nSELECT date '5874897-12-31';\nSELECT date '5874898-01-01';  -- out of range\n\nRESET datestyle;\n\n--\n-- Simple math\n-- Leave most of it for the horology tests\n--\n\nSELECT f1 - date '2000-01-01' AS \"Days From 2K\" FROM DATE_TBL;\n\nSELECT f1 - date 'epoch' AS \"Days From Epoch\" FROM DATE_TBL;\n\nSELECT date 'yesterday' - date 'today' AS \"One day\";\n\nSELECT date 'today' - date 'tomorrow' AS \"One day\";\n\nSELECT date 'yesterday' - date 'tomorrow' AS \"Two days\";\n\nSELECT date 'tomorrow' - date 'today' AS \"One day\";\n\nSELECT date 'today' - date 'yesterday' AS \"One day\";\n\nSELECT date 'tomorrow' - date 'yesterday' AS \"Two days\";\n\n--\n-- test extract!\n--\n-- epoch\n--\nSELECT EXTRACT(EPOCH FROM DATE        '1970-01-01');     --  0\nSELECT EXTRACT(EPOCH FROM TIMESTAMP   '1970-01-01');     --  0\nSELECT EXTRACT(EPOCH FROM TIMESTAMPTZ '1970-01-01+00');  --  0\n--\n-- century\n--\nSELECT EXTRACT(CENTURY FROM DATE '0101-12-31 BC'); -- -2\nSELECT EXTRACT(CENTURY FROM DATE '0100-12-31 BC'); -- -1\nSELECT EXTRACT(CENTURY FROM DATE '0001-12-31 BC'); -- -1\nSELECT EXTRACT(CENTURY FROM DATE '0001-01-01');    --  1\nSELECT EXTRACT(CENTURY FROM DATE '0001-01-01 AD'); --  1\nSELECT EXTRACT(CENTURY FROM DATE '1900-12-31');    -- 19\nSELECT EXTRACT(CENTURY FROM DATE '1901-01-01');    -- 20\nSELECT EXTRACT(CENTURY FROM DATE '2000-12-31');    -- 20\nSELECT EXTRACT(CENTURY FROM DATE '2001-01-01');    -- 21\nSELECT EXTRACT(CENTURY FROM CURRENT_DATE)>=21 AS True;     -- true\n--\n-- millennium\n--\nSELECT EXTRACT(MILLENNIUM FROM DATE '0001-12-31 BC'); -- -1\nSELECT EXTRACT(MILLENNIUM FROM DATE '0001-01-01 AD'); --  1\nSELECT EXTRACT(MILLENNIUM FROM DATE '1000-12-31');    --  1\nSELECT EXTRACT(MILLENNIUM FROM DATE '1001-01-01');    --  2\nSELECT EXTRACT(MILLENNIUM FROM DATE '2000-12-31');    --  2\nSELECT EXTRACT(MILLENNIUM FROM DATE '2001-01-01');    --  3\n-- next test to be fixed on the turn of the next millennium;-)\nSELECT EXTRACT(MILLENNIUM FROM CURRENT_DATE);         --  3\n--\n-- decade\n--\nSELECT EXTRACT(DECADE FROM DATE '1994-12-25');    -- 199\nSELECT EXTRACT(DECADE FROM DATE '0010-01-01');    --   1\nSELECT EXTRACT(DECADE FROM DATE '0009-12-31');    --   0\nSELECT EXTRACT(DECADE FROM DATE '0001-01-01 BC'); --   0\nSELECT EXTRACT(DECADE FROM DATE '0002-12-31 BC'); --  -1\nSELECT EXTRACT(DECADE FROM DATE '0011-01-01 BC'); --  -1\nSELECT EXTRACT(DECADE FROM DATE '0012-12-31 BC'); --  -2\n--\n-- some other types:\n--\n-- on a timestamp.\nSELECT EXTRACT(CENTURY FROM NOW())>=21 AS True;       -- true\nSELECT EXTRACT(CENTURY FROM TIMESTAMP '1970-03-20 04:30:00.00000'); -- 20\n-- on an interval\nSELECT EXTRACT(CENTURY FROM INTERVAL '100 y');  -- 1\nSELECT EXTRACT(CENTURY FROM INTERVAL '99 y');   -- 0\nSELECT EXTRACT(CENTURY FROM INTERVAL '-99 y');  -- 0\nSELECT EXTRACT(CENTURY FROM INTERVAL '-100 y'); -- -1\n--\n-- test trunc function!\n--\nSELECT DATE_TRUNC('MILLENNIUM', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1001\nSELECT DATE_TRUNC('MILLENNIUM', DATE '1970-03-20'); -- 1001-01-01\nSELECT DATE_TRUNC('CENTURY', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1901\nSELECT DATE_TRUNC('CENTURY', DATE '1970-03-20'); -- 1901\nSELECT DATE_TRUNC('CENTURY', DATE '2004-08-10'); -- 2001-01-01\nSELECT DATE_TRUNC('CENTURY', DATE '0002-02-04'); -- 0001-01-01\nSELECT DATE_TRUNC('CENTURY', DATE '0055-08-10 BC'); -- 0100-01-01 BC\nSELECT DATE_TRUNC('DECADE', DATE '1993-12-25'); -- 1990-01-01\nSELECT DATE_TRUNC('DECADE', DATE '0004-12-25'); -- 0001-01-01 BC\nSELECT DATE_TRUNC('DECADE', DATE '0002-12-31 BC'); -- 0011-01-01 BC\n--\n-- test infinity\n--\nselect 'infinity'::date, '-infinity'::date;\nselect 'infinity'::date > 'today'::date as t;\nselect '-infinity'::date < 'today'::date as t;\nselect isfinite('infinity'::date), isfinite('-infinity'::date), isfinite('today'::date);\n--\n-- oscillating fields from non-finite date/timestamptz:\n--\nSELECT EXTRACT(HOUR FROM DATE 'infinity');      -- NULL\nSELECT EXTRACT(HOUR FROM DATE '-infinity');     -- NULL\nSELECT EXTRACT(HOUR FROM TIMESTAMP   'infinity');      -- NULL\nSELECT EXTRACT(HOUR FROM TIMESTAMP   '-infinity');     -- NULL\nSELECT EXTRACT(HOUR FROM TIMESTAMPTZ 'infinity');      -- NULL\nSELECT EXTRACT(HOUR FROM TIMESTAMPTZ '-infinity');     -- NULL\n-- all possible fields\nSELECT EXTRACT(MICROSECONDS  FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(MILLISECONDS  FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(SECOND        FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(MINUTE        FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(HOUR          FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(DAY           FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(MONTH         FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(QUARTER       FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(WEEK          FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(DOW           FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(ISODOW        FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(DOY           FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(TIMEZONE      FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(TIMEZONE_M    FROM DATE 'infinity');    -- NULL\nSELECT EXTRACT(TIMEZONE_H    FROM DATE 'infinity');    -- NULL\n--\n-- monotonic fields from non-finite date/timestamptz:\n--\nSELECT EXTRACT(EPOCH FROM DATE 'infinity');         --  Infinity\nSELECT EXTRACT(EPOCH FROM DATE '-infinity');        -- -Infinity\nSELECT EXTRACT(EPOCH FROM TIMESTAMP   'infinity');  --  Infinity\nSELECT EXTRACT(EPOCH FROM TIMESTAMP   '-infinity'); -- -Infinity\nSELECT EXTRACT(EPOCH FROM TIMESTAMPTZ 'infinity');  --  Infinity\nSELECT EXTRACT(EPOCH FROM TIMESTAMPTZ '-infinity'); -- -Infinity\n-- all possible fields\nSELECT EXTRACT(YEAR       FROM DATE 'infinity');    --  Infinity\nSELECT EXTRACT(DECADE     FROM DATE 'infinity');    --  Infinity\nSELECT EXTRACT(CENTURY    FROM DATE 'infinity');    --  Infinity\nSELECT EXTRACT(MILLENNIUM FROM DATE 'infinity');    --  Infinity\nSELECT EXTRACT(JULIAN     FROM DATE 'infinity');    --  Infinity\nSELECT EXTRACT(ISOYEAR    FROM DATE 'infinity');    --  Infinity\nSELECT EXTRACT(EPOCH      FROM DATE 'infinity');    --  Infinity\n--\n-- wrong fields from non-finite date:\n--\nSELECT EXTRACT(MICROSEC  FROM DATE 'infinity');     -- ERROR:  timestamp units \"microsec\" not recognized\nSELECT EXTRACT(UNDEFINED FROM DATE 'infinity');     -- ERROR:  timestamp units \"undefined\" not supported\n\n-- test constructors\nselect make_date(2013, 7, 15);\nselect make_time(8, 20, 0.0);\n-- should fail\nselect make_date(2013, 2, 30);\nselect make_date(2013, 13, 1);\nselect make_date(2013, 11, -1);\nselect make_date(-44, 3, 15);  -- perhaps we should allow this sometime?\nselect make_time(10, 55, 100.1);\nselect make_time(24, 0, 2.1);\n",
  "upstream/dbsize.sql": "SELECT size, pg_size_pretty(size), pg_size_pretty(-1 * size) FROM\n    (VALUES (10::bigint), (1000::bigint), (1000000::bigint),\n            (1000000000::bigint), (1000000000000::bigint),\n            (1000000000000000::bigint)) x(size);\n\nSELECT size, pg_size_pretty(size), pg_size_pretty(-1 * size) FROM\n    (VALUES (10::numeric), (1000::numeric), (1000000::numeric),\n            (1000000000::numeric), (1000000000000::numeric),\n            (1000000000000000::numeric),\n            (10.5::numeric), (1000.5::numeric), (1000000.5::numeric),\n            (1000000000.5::numeric), (1000000000000.5::numeric),\n            (1000000000000000.5::numeric)) x(size);\n\nSELECT size, pg_size_bytes(size) FROM\n    (VALUES ('1'), ('123bytes'), ('1kB'), ('1MB'), (' 1 GB'), ('1.5 GB '),\n            ('1TB'), ('3000 TB'), ('1e6 MB')) x(size);\n\n-- case-insensitive units are supported\nSELECT size, pg_size_bytes(size) FROM\n    (VALUES ('1'), ('123bYteS'), ('1kb'), ('1mb'), (' 1 Gb'), ('1.5 gB '),\n            ('1tb'), ('3000 tb'), ('1e6 mb')) x(size);\n\n-- negative numbers are supported\nSELECT size, pg_size_bytes(size) FROM\n    (VALUES ('-1'), ('-123bytes'), ('-1kb'), ('-1mb'), (' -1 Gb'), ('-1.5 gB '),\n            ('-1tb'), ('-3000 TB'), ('-10e-1 MB')) x(size);\n\n-- different cases with allowed points\nSELECT size, pg_size_bytes(size) FROM\n     (VALUES ('-1.'), ('-1.kb'), ('-1. kb'), ('-0. gb'),\n             ('-.1'), ('-.1kb'), ('-.1 kb'), ('-.0 gb')) x(size);\n\n-- invalid inputs\nSELECT pg_size_bytes('1 AB');\nSELECT pg_size_bytes('1 AB A');\nSELECT pg_size_bytes('1 AB A    ');\nSELECT pg_size_bytes('9223372036854775807.9');\nSELECT pg_size_bytes('1e100');\nSELECT pg_size_bytes('1e1000000000000000000');\nSELECT pg_size_bytes('1 byte');  -- the singular \"byte\" is not supported\nSELECT pg_size_bytes('');\n\nSELECT pg_size_bytes('kb');\nSELECT pg_size_bytes('..');\nSELECT pg_size_bytes('-.');\nSELECT pg_size_bytes('-.kb');\nSELECT pg_size_bytes('-. kb');\n\nSELECT pg_size_bytes('.+912');\nSELECT pg_size_bytes('+912+ kB');\nSELECT pg_size_bytes('++123 kB');\n",
  "upstream/delete.sql": "CREATE TABLE delete_test (\n    id SERIAL PRIMARY KEY,\n    a INT,\n    b text\n);\n\nINSERT INTO delete_test (a) VALUES (10);\nINSERT INTO delete_test (a, b) VALUES (50, repeat('x', 10000));\nINSERT INTO delete_test (a) VALUES (100);\n\n-- allow an alias to be specified for DELETE's target table\nDELETE FROM delete_test AS dt WHERE dt.a > 75;\n\n-- if an alias is specified, don't allow the original table name\n-- to be referenced\nDELETE FROM delete_test dt WHERE delete_test.a > 25;\n\nSELECT id, a, char_length(b) FROM delete_test;\n\n-- delete a row with a TOASTed value\nDELETE FROM delete_test WHERE a > 25;\n\nSELECT id, a, char_length(b) FROM delete_test;\n\nDROP TABLE delete_test;\n",
  "upstream/float4.sql": "--\n-- FLOAT4\n--\n\nCREATE TABLE FLOAT4_TBL (f1  float4);\n\nINSERT INTO FLOAT4_TBL(f1) VALUES ('    0.0');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('1004.30   ');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('     -34.84    ');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('1.2345678901234e+20');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('1.2345678901234e-20');\n\n-- test for over and under flow\nINSERT INTO FLOAT4_TBL(f1) VALUES ('10e70');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70');\n\n-- bad input\nINSERT INTO FLOAT4_TBL(f1) VALUES ('');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('       ');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('xyz');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('5.0.0');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('5 . 0');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('5.   0');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('     - 3.0');\nINSERT INTO FLOAT4_TBL(f1) VALUES ('123            5');\n\n-- special inputs\nSELECT 'NaN'::float4;\nSELECT 'nan'::float4;\nSELECT '   NAN  '::float4;\nSELECT 'infinity'::float4;\nSELECT '          -INFINiTY   '::float4;\n-- bad special inputs\nSELECT 'N A N'::float4;\nSELECT 'NaN x'::float4;\nSELECT ' INFINITY    x'::float4;\n\nSELECT 'Infinity'::float4 + 100.0;\nSELECT 'Infinity'::float4 / 'Infinity'::float4;\nSELECT 'nan'::float4 / 'nan'::float4;\nSELECT 'nan'::numeric::float4;\n\nSELECT '' AS five, * FROM FLOAT4_TBL;\n\nSELECT '' AS four, f.* FROM FLOAT4_TBL f WHERE f.f1 <> '1004.3';\n\nSELECT '' AS one, f.* FROM FLOAT4_TBL f WHERE f.f1 = '1004.3';\n\nSELECT '' AS three, f.* FROM FLOAT4_TBL f WHERE '1004.3' > f.f1;\n\nSELECT '' AS three, f.* FROM FLOAT4_TBL f WHERE  f.f1 < '1004.3';\n\nSELECT '' AS four, f.* FROM FLOAT4_TBL f WHERE '1004.3' >= f.f1;\n\nSELECT '' AS four, f.* FROM FLOAT4_TBL f WHERE  f.f1 <= '1004.3';\n\nSELECT '' AS three, f.f1, f.f1 * '-10' AS x FROM FLOAT4_TBL f\n   WHERE f.f1 > '0.0';\n\nSELECT '' AS three, f.f1, f.f1 + '-10' AS x FROM FLOAT4_TBL f\n   WHERE f.f1 > '0.0';\n\nSELECT '' AS three, f.f1, f.f1 / '-10' AS x FROM FLOAT4_TBL f\n   WHERE f.f1 > '0.0';\n\nSELECT '' AS three, f.f1, f.f1 - '-10' AS x FROM FLOAT4_TBL f\n   WHERE f.f1 > '0.0';\n\n-- test divide by zero\nSELECT '' AS bad, f.f1 / '0.0' from FLOAT4_TBL f;\n\nSELECT '' AS five, * FROM FLOAT4_TBL;\n\n-- test the unary float4abs operator\nSELECT '' AS five, f.f1, @f.f1 AS abs_f1 FROM FLOAT4_TBL f;\n\nUPDATE FLOAT4_TBL\n   SET f1 = FLOAT4_TBL.f1 * '-1'\n   WHERE FLOAT4_TBL.f1 > '0.0';\n\nSELECT '' AS five, * FROM FLOAT4_TBL;\n",
  "upstream/float8.sql": "--\n-- FLOAT8\n--\n\nCREATE TABLE FLOAT8_TBL(f1 float8);\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('    0.0   ');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('1004.30  ');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('   -34.84');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('1.2345678901234e+200');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('1.2345678901234e-200');\n\n-- test for underflow and overflow handling\nSELECT '10e400'::float8;\nSELECT '-10e400'::float8;\nSELECT '10e-400'::float8;\nSELECT '-10e-400'::float8;\n\n-- bad input\nINSERT INTO FLOAT8_TBL(f1) VALUES ('');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('     ');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('xyz');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('5.0.0');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('5 . 0');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('5.   0');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('    - 3');\nINSERT INTO FLOAT8_TBL(f1) VALUES ('123           5');\n\n-- special inputs\nSELECT 'NaN'::float8;\nSELECT 'nan'::float8;\nSELECT '   NAN  '::float8;\nSELECT 'infinity'::float8;\nSELECT '          -INFINiTY   '::float8;\n-- bad special inputs\nSELECT 'N A N'::float8;\nSELECT 'NaN x'::float8;\nSELECT ' INFINITY    x'::float8;\n\nSELECT 'Infinity'::float8 + 100.0;\nSELECT 'Infinity'::float8 / 'Infinity'::float8;\nSELECT 'nan'::float8 / 'nan'::float8;\nSELECT 'nan'::numeric::float8;\n\nSELECT '' AS five, * FROM FLOAT8_TBL;\n\nSELECT '' AS four, f.* FROM FLOAT8_TBL f WHERE f.f1 <> '1004.3';\n\nSELECT '' AS one, f.* FROM FLOAT8_TBL f WHERE f.f1 = '1004.3';\n\nSELECT '' AS three, f.* FROM FLOAT8_TBL f WHERE '1004.3' > f.f1;\n\nSELECT '' AS three, f.* FROM FLOAT8_TBL f WHERE  f.f1 < '1004.3';\n\nSELECT '' AS four, f.* FROM FLOAT8_TBL f WHERE '1004.3' >= f.f1;\n\nSELECT '' AS four, f.* FROM FLOAT8_TBL f WHERE  f.f1 <= '1004.3';\n\nSELECT '' AS three, f.f1, f.f1 * '-10' AS x\n   FROM FLOAT8_TBL f\n   WHERE f.f1 > '0.0';\n\nSELECT '' AS three, f.f1, f.f1 + '-10' AS x\n   FROM FLOAT8_TBL f\n   WHERE f.f1 > '0.0';\n\nSELECT '' AS three, f.f1, f.f1 / '-10' AS x\n   FROM FLOAT8_TBL f\n   WHERE f.f1 > '0.0';\n\nSELECT '' AS three, f.f1, f.f1 - '-10' AS x\n   FROM FLOAT8_TBL f\n   WHERE f.f1 > '0.0';\n\nSELECT '' AS one, f.f1 ^ '2.0' AS square_f1\n   FROM FLOAT8_TBL f where f.f1 = '1004.3';\n\n-- absolute value\nSELECT '' AS five, f.f1, @f.f1 AS abs_f1\n   FROM FLOAT8_TBL f;\n\n-- truncate\nSELECT '' AS five, f.f1, trunc(f.f1) AS trunc_f1\n   FROM FLOAT8_TBL f;\n\n-- round\nSELECT '' AS five, f.f1, round(f.f1) AS round_f1\n   FROM FLOAT8_TBL f;\n\n-- ceil / ceiling\nselect ceil(f1) as ceil_f1 from float8_tbl f;\nselect ceiling(f1) as ceiling_f1 from float8_tbl f;\n\n-- floor\nselect floor(f1) as floor_f1 from float8_tbl f;\n\n-- sign\nselect sign(f1) as sign_f1 from float8_tbl f;\n\n-- square root\nSELECT sqrt(float8 '64') AS eight;\n\nSELECT |/ float8 '64' AS eight;\n\nSELECT '' AS three, f.f1, |/f.f1 AS sqrt_f1\n   FROM FLOAT8_TBL f\n   WHERE f.f1 > '0.0';\n\n-- power\nSELECT power(float8 '144', float8 '0.5');\n\n-- take exp of ln(f.f1)\nSELECT '' AS three, f.f1, exp(ln(f.f1)) AS exp_ln_f1\n   FROM FLOAT8_TBL f\n   WHERE f.f1 > '0.0';\n\n-- cube root\nSELECT ||/ float8 '27' AS three;\n\nSELECT '' AS five, f.f1, ||/f.f1 AS cbrt_f1 FROM FLOAT8_TBL f;\n\n\nSELECT '' AS five, * FROM FLOAT8_TBL;\n\nUPDATE FLOAT8_TBL\n   SET f1 = FLOAT8_TBL.f1 * '-1'\n   WHERE FLOAT8_TBL.f1 > '0.0';\n\nSELECT '' AS bad, f.f1 * '1e200' from FLOAT8_TBL f;\n\nSELECT '' AS bad, f.f1 ^ '1e200' from FLOAT8_TBL f;\n\nSELECT 0 ^ 0 + 0 ^ 1 + 0 ^ 0.0 + 0 ^ 0.5;\n\nSELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 = '0.0' ;\n\nSELECT '' AS bad, ln(f.f1) from FLOAT8_TBL f where f.f1 < '0.0' ;\n\nSELECT '' AS bad, exp(f.f1) from FLOAT8_TBL f;\n\nSELECT '' AS bad, f.f1 / '0.0' from FLOAT8_TBL f;\n\nSELECT '' AS five, * FROM FLOAT8_TBL;\n\n-- test for over- and underflow\nINSERT INTO FLOAT8_TBL(f1) VALUES ('10e400');\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('-10e400');\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('10e-400');\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('-10e-400');\n\n-- maintain external table consistency across platforms\n-- delete all values and reinsert well-behaved ones\n\nDELETE FROM FLOAT8_TBL;\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('0.0');\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('-34.84');\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('-1004.30');\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('-1.2345678901234e+200');\n\nINSERT INTO FLOAT8_TBL(f1) VALUES ('-1.2345678901234e-200');\n\nSELECT '' AS five, * FROM FLOAT8_TBL;\n\n-- test exact cases for trigonometric functions in degrees\nSET extra_float_digits = 3;\n\nSELECT x,\n       sind(x),\n       sind(x) IN (-1,-0.5,0,0.5,1) AS sind_exact\nFROM (VALUES (0), (30), (90), (150), (180),\n      (210), (270), (330), (360)) AS t(x);\n\nSELECT x,\n       cosd(x),\n       cosd(x) IN (-1,-0.5,0,0.5,1) AS cosd_exact\nFROM (VALUES (0), (60), (90), (120), (180),\n      (240), (270), (300), (360)) AS t(x);\n\nSELECT x,\n       tand(x),\n       tand(x) IN ('-Infinity'::float8,-1,0,\n                   1,'Infinity'::float8) AS tand_exact,\n       cotd(x),\n       cotd(x) IN ('-Infinity'::float8,-1,0,\n                   1,'Infinity'::float8) AS cotd_exact\nFROM (VALUES (0), (45), (90), (135), (180),\n      (225), (270), (315), (360)) AS t(x);\n\nSELECT x,\n       asind(x),\n       asind(x) IN (-90,-30,0,30,90) AS asind_exact,\n       acosd(x),\n       acosd(x) IN (0,60,90,120,180) AS acosd_exact\nFROM (VALUES (-1), (-0.5), (0), (0.5), (1)) AS t(x);\n\nSELECT x,\n       atand(x),\n       atand(x) IN (-90,-45,0,45,90) AS atand_exact\nFROM (VALUES ('-Infinity'::float8), (-1), (0), (1),\n      ('Infinity'::float8)) AS t(x);\n\nSELECT x, y,\n       atan2d(y, x),\n       atan2d(y, x) IN (-90,0,90,180) AS atan2d_exact\nFROM (SELECT 10*cosd(a), 10*sind(a)\n      FROM generate_series(0, 360, 90) AS t(a)) AS t(x,y);\n\nRESET extra_float_digits;\n",
  "upstream/geometry.sql": "--\n-- GEOMETRY\n--\n\n-- Back off displayed precision a little bit to reduce platform-to-platform\n-- variation in results.\nSET extra_float_digits TO -3;\n\n--\n-- Points\n--\n\nSELECT '' AS four, center(f1) AS center\n   FROM BOX_TBL;\n\nSELECT '' AS four, (@@ f1) AS center\n   FROM BOX_TBL;\n\nSELECT '' AS six, point(f1) AS center\n   FROM CIRCLE_TBL;\n\nSELECT '' AS six, (@@ f1) AS center\n   FROM CIRCLE_TBL;\n\nSELECT '' AS two, (@@ f1) AS center\n   FROM POLYGON_TBL\n   WHERE (# f1) > 2;\n\n-- \"is horizontal\" function\nSELECT '' AS two, p1.f1\n   FROM POINT_TBL p1\n   WHERE ishorizontal(p1.f1, point '(0,0)');\n\n-- \"is horizontal\" operator\nSELECT '' AS two, p1.f1\n   FROM POINT_TBL p1\n   WHERE p1.f1 ?- point '(0,0)';\n\n-- \"is vertical\" function\nSELECT '' AS one, p1.f1\n   FROM POINT_TBL p1\n   WHERE isvertical(p1.f1, point '(5.1,34.5)');\n\n-- \"is vertical\" operator\nSELECT '' AS one, p1.f1\n   FROM POINT_TBL p1\n   WHERE p1.f1 ?| point '(5.1,34.5)';\n\n--\n-- Line segments\n--\n\n-- intersection\nSELECT '' AS count, p.f1, l.s, l.s # p.f1 AS intersection\n   FROM LSEG_TBL l, POINT_TBL p;\n\n-- closest point\nSELECT '' AS thirty, p.f1, l.s, p.f1 ## l.s AS closest\n   FROM LSEG_TBL l, POINT_TBL p;\n\n--\n-- Boxes\n--\n\nSELECT '' as six, box(f1) AS box FROM CIRCLE_TBL;\n\n-- translation\nSELECT '' AS twentyfour, b.f1 + p.f1 AS translation\n   FROM BOX_TBL b, POINT_TBL p;\n\nSELECT '' AS twentyfour, b.f1 - p.f1 AS translation\n   FROM BOX_TBL b, POINT_TBL p;\n\n-- scaling and rotation\nSELECT '' AS twentyfour, b.f1 * p.f1 AS rotation\n   FROM BOX_TBL b, POINT_TBL p;\n\nSELECT '' AS twenty, b.f1 / p.f1 AS rotation\n   FROM BOX_TBL b, POINT_TBL p\n   WHERE (p.f1 <-> point '(0,0)') >= 1;\n\nSELECT f1::box\n\tFROM POINT_TBL;\n\nSELECT bound_box(a.f1, b.f1)\n\tFROM BOX_TBL a, BOX_TBL b;\n\n--\n-- Paths\n--\n\nSELECT '' AS eight, npoints(f1) AS npoints, f1 AS path FROM PATH_TBL;\n\nSELECT '' AS four, path(f1) FROM POLYGON_TBL;\n\n-- translation\nSELECT '' AS eight, p1.f1 + point '(10,10)' AS dist_add\n   FROM PATH_TBL p1;\n\n-- scaling and rotation\nSELECT '' AS eight, p1.f1 * point '(2,-1)' AS dist_mul\n   FROM PATH_TBL p1;\n\n--\n-- Polygons\n--\n\n-- containment\nSELECT '' AS twentyfour, p.f1, poly.f1, poly.f1 @> p.f1 AS contains\n   FROM POLYGON_TBL poly, POINT_TBL p;\n\nSELECT '' AS twentyfour, p.f1, poly.f1, p.f1 <@ poly.f1 AS contained\n   FROM POLYGON_TBL poly, POINT_TBL p;\n\nSELECT '' AS four, npoints(f1) AS npoints, f1 AS polygon\n   FROM POLYGON_TBL;\n\nSELECT '' AS four, polygon(f1)\n   FROM BOX_TBL;\n\nSELECT '' AS four, polygon(f1)\n   FROM PATH_TBL WHERE isclosed(f1);\n\nSELECT '' AS four, f1 AS open_path, polygon( pclose(f1)) AS polygon\n   FROM PATH_TBL\n   WHERE isopen(f1);\n\n-- convert circles to polygons using the default number of points\nSELECT '' AS six, polygon(f1)\n   FROM CIRCLE_TBL;\n\n-- convert the circle to an 8-point polygon\nSELECT '' AS six, polygon(8, f1)\n   FROM CIRCLE_TBL;\n\n--\n-- Circles\n--\n\nSELECT '' AS six, circle(f1, 50.0)\n   FROM POINT_TBL;\n\nSELECT '' AS four, circle(f1)\n   FROM BOX_TBL;\n\nSELECT '' AS two, circle(f1)\n   FROM POLYGON_TBL\n   WHERE (# f1) >= 3;\n\nSELECT '' AS twentyfour, c1.f1 AS circle, p1.f1 AS point, (p1.f1 <-> c1.f1) AS distance\n   FROM CIRCLE_TBL c1, POINT_TBL p1\n   WHERE (p1.f1 <-> c1.f1) > 0\n   ORDER BY distance, area(c1.f1), p1.f1[0];\n",
  "upstream/hash_index.sql": "--\n-- HASH_INDEX\n-- grep 843938989 hash.data\n--\n\nSELECT * FROM hash_i4_heap\n   WHERE hash_i4_heap.random = 843938989;\n\n--\n-- hash index\n-- grep 66766766 hash.data\n--\nSELECT * FROM hash_i4_heap\n   WHERE hash_i4_heap.random = 66766766;\n\n--\n-- hash index\n-- grep 1505703298 hash.data\n--\nSELECT * FROM hash_name_heap\n   WHERE hash_name_heap.random = '1505703298'::name;\n\n--\n-- hash index\n-- grep 7777777 hash.data\n--\nSELECT * FROM hash_name_heap\n   WHERE hash_name_heap.random = '7777777'::name;\n\n--\n-- hash index\n-- grep 1351610853 hash.data\n--\nSELECT * FROM hash_txt_heap\n   WHERE hash_txt_heap.random = '1351610853'::text;\n\n--\n-- hash index\n-- grep 111111112222222233333333 hash.data\n--\nSELECT * FROM hash_txt_heap\n   WHERE hash_txt_heap.random = '111111112222222233333333'::text;\n\n--\n-- hash index\n-- grep 444705537 hash.data\n--\nSELECT * FROM hash_f8_heap\n   WHERE hash_f8_heap.random = '444705537'::float8;\n\n--\n-- hash index\n-- grep 88888888 hash.data\n--\nSELECT * FROM hash_f8_heap\n   WHERE hash_f8_heap.random = '88888888'::float8;\n\n--\n-- hash index\n-- grep '^90[^0-9]' hashovfl.data\n--\n-- SELECT count(*) AS i988 FROM hash_ovfl_heap\n--    WHERE x = 90;\n\n--\n-- hash index\n-- grep '^1000[^0-9]' hashovfl.data\n--\n-- SELECT count(*) AS i0 FROM hash_ovfl_heap\n--    WHERE x = 1000;\n\n--\n-- HASH\n--\nUPDATE hash_i4_heap\n   SET random = 1\n   WHERE hash_i4_heap.seqno = 1492;\n\nSELECT h.seqno AS i1492, h.random AS i1\n   FROM hash_i4_heap h\n   WHERE h.random = 1;\n\nUPDATE hash_i4_heap\n   SET seqno = 20000\n   WHERE hash_i4_heap.random = 1492795354;\n\nSELECT h.seqno AS i20000\n   FROM hash_i4_heap h\n   WHERE h.random = 1492795354;\n\nUPDATE hash_name_heap\n   SET random = '0123456789abcdef'::name\n   WHERE hash_name_heap.seqno = 6543;\n\nSELECT h.seqno AS i6543, h.random AS c0_to_f\n   FROM hash_name_heap h\n   WHERE h.random = '0123456789abcdef'::name;\n\nUPDATE hash_name_heap\n   SET seqno = 20000\n   WHERE hash_name_heap.random = '76652222'::name;\n\n--\n-- this is the row we just replaced; index scan should return zero rows\n--\nSELECT h.seqno AS emptyset\n   FROM hash_name_heap h\n   WHERE h.random = '76652222'::name;\n\nUPDATE hash_txt_heap\n   SET random = '0123456789abcdefghijklmnop'::text\n   WHERE hash_txt_heap.seqno = 4002;\n\nSELECT h.seqno AS i4002, h.random AS c0_to_p\n   FROM hash_txt_heap h\n   WHERE h.random = '0123456789abcdefghijklmnop'::text;\n\nUPDATE hash_txt_heap\n   SET seqno = 20000\n   WHERE hash_txt_heap.random = '959363399'::text;\n\nSELECT h.seqno AS t20000\n   FROM hash_txt_heap h\n   WHERE h.random = '959363399'::text;\n\nUPDATE hash_f8_heap\n   SET random = '-1234.1234'::float8\n   WHERE hash_f8_heap.seqno = 8906;\n\nSELECT h.seqno AS i8096, h.random AS f1234_1234\n   FROM hash_f8_heap h\n   WHERE h.random = '-1234.1234'::float8;\n\nUPDATE hash_f8_heap\n   SET seqno = 20000\n   WHERE hash_f8_heap.random = '488912369'::float8;\n\nSELECT h.seqno AS f20000\n   FROM hash_f8_heap h\n   WHERE h.random = '488912369'::float8;\n\n-- UPDATE hash_ovfl_heap\n--    SET x = 1000\n--   WHERE x = 90;\n\n-- this vacuums the index as well\n-- VACUUM hash_ovfl_heap;\n\n-- SELECT count(*) AS i0 FROM hash_ovfl_heap\n--   WHERE x = 90;\n\n-- SELECT count(*) AS i988 FROM hash_ovfl_heap\n--  WHERE x = 1000;\n",
  "upstream/hs_primary_extremes.sql": "--\n-- Hot Standby tests\n--\n-- hs_primary_extremes.sql\n--\n\ndrop table if exists hs_extreme;\ncreate table hs_extreme (col1 integer);\n\nCREATE OR REPLACE FUNCTION hs_subxids (n integer)\nRETURNS void\nLANGUAGE plpgsql\nAS $$\n    BEGIN\n      IF n <= 0 THEN RETURN; END IF;\n      INSERT INTO hs_extreme VALUES (n);\n      PERFORM hs_subxids(n - 1);\n      RETURN;\n    EXCEPTION WHEN raise_exception THEN NULL; END;\n$$;\n\nBEGIN;\nSELECT hs_subxids(257);\nROLLBACK;\nBEGIN;\nSELECT hs_subxids(257);\nCOMMIT;\n\nset client_min_messages = 'warning';\n\nCREATE OR REPLACE FUNCTION hs_locks_create (n integer)\nRETURNS void\nLANGUAGE plpgsql\nAS $$\n    BEGIN\n      IF n <= 0 THEN\n\t\tCHECKPOINT;\n\t\tRETURN;\n\t  END IF;\n      EXECUTE 'CREATE TABLE hs_locks_' || n::text || ' ()';\n      PERFORM hs_locks_create(n - 1);\n      RETURN;\n    EXCEPTION WHEN raise_exception THEN NULL; END;\n$$;\n\nCREATE OR REPLACE FUNCTION hs_locks_drop (n integer)\nRETURNS void\nLANGUAGE plpgsql\nAS $$\n    BEGIN\n      IF n <= 0 THEN\n\t\tCHECKPOINT;\n\t\tRETURN;\n\t  END IF;\n\t  EXECUTE 'DROP TABLE IF EXISTS hs_locks_' || n::text;\n      PERFORM hs_locks_drop(n - 1);\n      RETURN;\n    EXCEPTION WHEN raise_exception THEN NULL; END;\n$$;\n\nBEGIN;\nSELECT hs_locks_drop(257);\nSELECT hs_locks_create(257);\nSELECT count(*) > 257 FROM pg_locks;\nROLLBACK;\nBEGIN;\nSELECT hs_locks_drop(257);\nSELECT hs_locks_create(257);\nSELECT count(*) > 257 FROM pg_locks;\nCOMMIT;\nSELECT hs_locks_drop(257);\n\nSELECT pg_switch_xlog();\n",
  "upstream/hs_primary_setup.sql": "--\n-- Hot Standby tests\n--\n-- hs_primary_setup.sql\n--\n\ndrop table if exists hs1;\ncreate table hs1 (col1 integer primary key);\ninsert into hs1 values (1);\n\ndrop table if exists hs2;\ncreate table hs2 (col1 integer primary key);\ninsert into hs2 values (12);\ninsert into hs2 values (13);\n\ndrop table if exists hs3;\ncreate table hs3 (col1 integer primary key);\ninsert into hs3 values (113);\ninsert into hs3 values (114);\ninsert into hs3 values (115);\n\nDROP sequence if exists hsseq;\ncreate sequence hsseq;\n\nSELECT pg_switch_xlog();\n",
  "upstream/hs_standby_check.sql": "--\n-- Hot Standby tests\n--\n-- hs_standby_check.sql\n--\n\n--\n-- If the query below returns false then all other tests will fail after it.\n--\nselect case pg_is_in_recovery() when false then\n\t'These tests are intended only for execution on a standby server that is reading ' ||\n\t'WAL from a server upon which the regression database is already created and into ' ||\n\t'which src/test/regress/sql/hs_primary_setup.sql has been run'\nelse\n\t'Tests are running on a standby server during recovery'\nend;\n",
  "upstream/hs_standby_functions.sql": "--\n-- Hot Standby tests\n--\n-- hs_standby_functions.sql\n--\n\n-- should fail\nselect txid_current();\n\nselect length(txid_current_snapshot()::text) >= 4;\n\nselect pg_start_backup('should fail');\nselect pg_switch_xlog();\nselect pg_stop_backup();\n\n-- should return no rows\nselect * from pg_prepared_xacts;\n\n-- just the startup process\nselect locktype, virtualxid, virtualtransaction, mode, granted\nfrom pg_locks where virtualxid = '1/1';\n\n-- suicide is painless\nselect pg_cancel_backend(pg_backend_pid());\n",
  "upstream/init_privs.sql": "-- Test iniital privileges\n\n-- There should always be some initial privileges, set up by initdb\nSELECT count(*) > 0 FROM pg_init_privs;\n\n-- Intentionally include some non-initial privs for pg_dump to dump out\nGRANT SELECT ON pg_proc TO CURRENT_USER;\nGRANT SELECT (prosrc) ON pg_proc TO CURRENT_USER;\n\nGRANT SELECT (rolname, rolsuper) ON pg_authid TO CURRENT_USER;\n",
  "upstream/insert.sql": "--\n-- insert with DEFAULT in the target_list\n--\ncreate table inserttest (col1 int4, col2 int4 NOT NULL, col3 text default 'testing');\ninsert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);\ninsert into inserttest (col2, col3) values (3, DEFAULT);\ninsert into inserttest (col1, col2, col3) values (DEFAULT, 5, DEFAULT);\ninsert into inserttest values (DEFAULT, 5, 'test');\ninsert into inserttest values (DEFAULT, 7);\n\nselect * from inserttest;\n\n--\n-- insert with similar expression / target_list values (all fail)\n--\ninsert into inserttest (col1, col2, col3) values (DEFAULT, DEFAULT);\ninsert into inserttest (col1, col2, col3) values (1, 2);\ninsert into inserttest (col1) values (1, 2);\ninsert into inserttest (col1) values (DEFAULT, DEFAULT);\n\nselect * from inserttest;\n\n--\n-- VALUES test\n--\ninsert into inserttest values(10, 20, '40'), (-1, 2, DEFAULT),\n    ((select 2), (select i from (values(3)) as foo (i)), 'values are fun!');\n\nselect * from inserttest;\n\n--\n-- TOASTed value test\n--\ninsert into inserttest values(30, 50, repeat('x', 10000));\n\nselect col1, col2, char_length(col3) from inserttest;\n\ndrop table inserttest;\n",
  "upstream/int2.sql": "--\n-- INT2\n--\n\nCREATE TABLE INT2_TBL(f1 int2);\n\nINSERT INTO INT2_TBL(f1) VALUES ('0   ');\n\nINSERT INTO INT2_TBL(f1) VALUES ('  1234 ');\n\nINSERT INTO INT2_TBL(f1) VALUES ('    -1234');\n\nINSERT INTO INT2_TBL(f1) VALUES ('34.5');\n\n-- largest and smallest values\nINSERT INTO INT2_TBL(f1) VALUES ('32767');\n\nINSERT INTO INT2_TBL(f1) VALUES ('-32767');\n\n-- bad input values -- should give errors\nINSERT INTO INT2_TBL(f1) VALUES ('100000');\nINSERT INTO INT2_TBL(f1) VALUES ('asdf');\nINSERT INTO INT2_TBL(f1) VALUES ('    ');\nINSERT INTO INT2_TBL(f1) VALUES ('- 1234');\nINSERT INTO INT2_TBL(f1) VALUES ('4 444');\nINSERT INTO INT2_TBL(f1) VALUES ('123 dt');\nINSERT INTO INT2_TBL(f1) VALUES ('');\n\n\nSELECT '' AS five, * FROM INT2_TBL;\n\nSELECT '' AS four, i.* FROM INT2_TBL i WHERE i.f1 <> int2 '0';\n\nSELECT '' AS four, i.* FROM INT2_TBL i WHERE i.f1 <> int4 '0';\n\nSELECT '' AS one, i.* FROM INT2_TBL i WHERE i.f1 = int2 '0';\n\nSELECT '' AS one, i.* FROM INT2_TBL i WHERE i.f1 = int4 '0';\n\nSELECT '' AS two, i.* FROM INT2_TBL i WHERE i.f1 < int2 '0';\n\nSELECT '' AS two, i.* FROM INT2_TBL i WHERE i.f1 < int4 '0';\n\nSELECT '' AS three, i.* FROM INT2_TBL i WHERE i.f1 <= int2 '0';\n\nSELECT '' AS three, i.* FROM INT2_TBL i WHERE i.f1 <= int4 '0';\n\nSELECT '' AS two, i.* FROM INT2_TBL i WHERE i.f1 > int2 '0';\n\nSELECT '' AS two, i.* FROM INT2_TBL i WHERE i.f1 > int4 '0';\n\nSELECT '' AS three, i.* FROM INT2_TBL i WHERE i.f1 >= int2 '0';\n\nSELECT '' AS three, i.* FROM INT2_TBL i WHERE i.f1 >= int4 '0';\n\n-- positive odds\nSELECT '' AS one, i.* FROM INT2_TBL i WHERE (i.f1 % int2 '2') = int2 '1';\n\n-- any evens\nSELECT '' AS three, i.* FROM INT2_TBL i WHERE (i.f1 % int4 '2') = int2 '0';\n\nSELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT2_TBL i\nWHERE abs(f1) < 16384;\n\nSELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT2_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT2_TBL i\nWHERE f1 < 32766;\n\nSELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT2_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT2_TBL i\nWHERE f1 > -32767;\n\nSELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT2_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 / int2 '2' AS x FROM INT2_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 / int4 '2' AS x FROM INT2_TBL i;\n\n-- corner cases\nSELECT (-1::int2<<15)::text;\nSELECT ((-1::int2<<15)+1::int2)::text;\n\n-- check sane handling of INT16_MIN overflow cases\nSELECT (-32768)::int2 * (-1)::int2;\nSELECT (-32768)::int2 / (-1)::int2;\nSELECT (-32768)::int2 % (-1)::int2;\n\n-- check rounding when casting from float\nSELECT x, x::int2 AS int2_value\nFROM (VALUES (-2.5::float8),\n             (-1.5::float8),\n             (-0.5::float8),\n             (0.0::float8),\n             (0.5::float8),\n             (1.5::float8),\n             (2.5::float8)) t(x);\n\n-- check rounding when casting from numeric\nSELECT x, x::int2 AS int2_value\nFROM (VALUES (-2.5::numeric),\n             (-1.5::numeric),\n             (-0.5::numeric),\n             (0.0::numeric),\n             (0.5::numeric),\n             (1.5::numeric),\n             (2.5::numeric)) t(x);\n",
  "upstream/int4.sql": "--\n-- INT4\n--\n\nCREATE TABLE INT4_TBL(f1 int4);\n\nINSERT INTO INT4_TBL(f1) VALUES ('   0  ');\n\nINSERT INTO INT4_TBL(f1) VALUES ('123456     ');\n\nINSERT INTO INT4_TBL(f1) VALUES ('    -123456');\n\nINSERT INTO INT4_TBL(f1) VALUES ('34.5');\n\n-- largest and smallest values\nINSERT INTO INT4_TBL(f1) VALUES ('2147483647');\n\nINSERT INTO INT4_TBL(f1) VALUES ('-2147483647');\n\n-- bad input values -- should give errors\nINSERT INTO INT4_TBL(f1) VALUES ('1000000000000');\nINSERT INTO INT4_TBL(f1) VALUES ('asdf');\nINSERT INTO INT4_TBL(f1) VALUES ('     ');\nINSERT INTO INT4_TBL(f1) VALUES ('   asdf   ');\nINSERT INTO INT4_TBL(f1) VALUES ('- 1234');\nINSERT INTO INT4_TBL(f1) VALUES ('123       5');\nINSERT INTO INT4_TBL(f1) VALUES ('');\n\n\nSELECT '' AS five, * FROM INT4_TBL;\n\nSELECT '' AS four, i.* FROM INT4_TBL i WHERE i.f1 <> int2 '0';\n\nSELECT '' AS four, i.* FROM INT4_TBL i WHERE i.f1 <> int4 '0';\n\nSELECT '' AS one, i.* FROM INT4_TBL i WHERE i.f1 = int2 '0';\n\nSELECT '' AS one, i.* FROM INT4_TBL i WHERE i.f1 = int4 '0';\n\nSELECT '' AS two, i.* FROM INT4_TBL i WHERE i.f1 < int2 '0';\n\nSELECT '' AS two, i.* FROM INT4_TBL i WHERE i.f1 < int4 '0';\n\nSELECT '' AS three, i.* FROM INT4_TBL i WHERE i.f1 <= int2 '0';\n\nSELECT '' AS three, i.* FROM INT4_TBL i WHERE i.f1 <= int4 '0';\n\nSELECT '' AS two, i.* FROM INT4_TBL i WHERE i.f1 > int2 '0';\n\nSELECT '' AS two, i.* FROM INT4_TBL i WHERE i.f1 > int4 '0';\n\nSELECT '' AS three, i.* FROM INT4_TBL i WHERE i.f1 >= int2 '0';\n\nSELECT '' AS three, i.* FROM INT4_TBL i WHERE i.f1 >= int4 '0';\n\n-- positive odds\nSELECT '' AS one, i.* FROM INT4_TBL i WHERE (i.f1 % int2 '2') = int2 '1';\n\n-- any evens\nSELECT '' AS three, i.* FROM INT4_TBL i WHERE (i.f1 % int4 '2') = int2 '0';\n\nSELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 * int2 '2' AS x FROM INT4_TBL i\nWHERE abs(f1) < 1073741824;\n\nSELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 * int4 '2' AS x FROM INT4_TBL i\nWHERE abs(f1) < 1073741824;\n\nSELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 + int2 '2' AS x FROM INT4_TBL i\nWHERE f1 < 2147483646;\n\nSELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 + int4 '2' AS x FROM INT4_TBL i\nWHERE f1 < 2147483646;\n\nSELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 - int2 '2' AS x FROM INT4_TBL i\nWHERE f1 > -2147483647;\n\nSELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 - int4 '2' AS x FROM INT4_TBL i\nWHERE f1 > -2147483647;\n\nSELECT '' AS five, i.f1, i.f1 / int2 '2' AS x FROM INT4_TBL i;\n\nSELECT '' AS five, i.f1, i.f1 / int4 '2' AS x FROM INT4_TBL i;\n\n--\n-- more complex expressions\n--\n\n-- variations on unary minus parsing\nSELECT -2+3 AS one;\n\nSELECT 4-2 AS two;\n\nSELECT 2- -1 AS three;\n\nSELECT 2 - -2 AS four;\n\nSELECT int2 '2' * int2 '2' = int2 '16' / int2 '4' AS true;\n\nSELECT int4 '2' * int2 '2' = int2 '16' / int4 '4' AS true;\n\nSELECT int2 '2' * int4 '2' = int4 '16' / int2 '4' AS true;\n\nSELECT int4 '1000' < int4 '999' AS false;\n\nSELECT 4! AS twenty_four;\n\nSELECT !!3 AS six;\n\nSELECT 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 AS ten;\n\nSELECT 2 + 2 / 2 AS three;\n\nSELECT (2 + 2) / 2 AS two;\n\n-- corner case\nSELECT (-1::int4<<31)::text;\nSELECT ((-1::int4<<31)+1)::text;\n\n-- check sane handling of INT_MIN overflow cases\nSELECT (-2147483648)::int4 * (-1)::int4;\nSELECT (-2147483648)::int4 / (-1)::int4;\nSELECT (-2147483648)::int4 % (-1)::int4;\nSELECT (-2147483648)::int4 * (-1)::int2;\nSELECT (-2147483648)::int4 / (-1)::int2;\nSELECT (-2147483648)::int4 % (-1)::int2;\n\n-- check rounding when casting from float\nSELECT x, x::int4 AS int4_value\nFROM (VALUES (-2.5::float8),\n             (-1.5::float8),\n             (-0.5::float8),\n             (0.0::float8),\n             (0.5::float8),\n             (1.5::float8),\n             (2.5::float8)) t(x);\n\n-- check rounding when casting from numeric\nSELECT x, x::int4 AS int4_value\nFROM (VALUES (-2.5::numeric),\n             (-1.5::numeric),\n             (-0.5::numeric),\n             (0.0::numeric),\n             (0.5::numeric),\n             (1.5::numeric),\n             (2.5::numeric)) t(x);\n",
  "upstream/json_encoding.sql": "\n-- encoding-sensitive tests for json and jsonb\n\n-- first json\n\n-- basic unicode input\nSELECT '\"\\u\"'::json;\t\t\t-- ERROR, incomplete escape\nSELECT '\"\\u00\"'::json;\t\t\t-- ERROR, incomplete escape\nSELECT '\"\\u000g\"'::json;\t\t-- ERROR, g is not a hex digit\nSELECT '\"\\u0000\"'::json;\t\t-- OK, legal escape\nSELECT '\"\\uaBcD\"'::json;\t\t-- OK, uppercase and lower case both OK\n\n-- handling of unicode surrogate pairs\n\nselect json '{ \"a\":  \"\\ud83d\\ude04\\ud83d\\udc36\" }' -> 'a' as correct_in_utf8;\nselect json '{ \"a\":  \"\\ud83d\\ud83d\" }' -> 'a'; -- 2 high surrogates in a row\nselect json '{ \"a\":  \"\\ude04\\ud83d\" }' -> 'a'; -- surrogates in wrong order\nselect json '{ \"a\":  \"\\ud83dX\" }' -> 'a'; -- orphan high surrogate\nselect json '{ \"a\":  \"\\ude04X\" }' -> 'a'; -- orphan low surrogate\n\n--handling of simple unicode escapes\n\nselect json '{ \"a\":  \"the Copyright \\u00a9 sign\" }' as correct_in_utf8;\nselect json '{ \"a\":  \"dollar \\u0024 character\" }' as correct_everywhere;\nselect json '{ \"a\":  \"dollar \\\\u0024 character\" }' as not_an_escape;\nselect json '{ \"a\":  \"null \\u0000 escape\" }' as not_unescaped;\nselect json '{ \"a\":  \"null \\\\u0000 escape\" }' as not_an_escape;\n\nselect json '{ \"a\":  \"the Copyright \\u00a9 sign\" }' ->> 'a' as correct_in_utf8;\nselect json '{ \"a\":  \"dollar \\u0024 character\" }' ->> 'a' as correct_everywhere;\nselect json '{ \"a\":  \"dollar \\\\u0024 character\" }' ->> 'a' as not_an_escape;\nselect json '{ \"a\":  \"null \\u0000 escape\" }' ->> 'a' as fails;\nselect json '{ \"a\":  \"null \\\\u0000 escape\" }' ->> 'a' as not_an_escape;\n\n-- then jsonb\n\n-- basic unicode input\nSELECT '\"\\u\"'::jsonb;\t\t\t-- ERROR, incomplete escape\nSELECT '\"\\u00\"'::jsonb;\t\t\t-- ERROR, incomplete escape\nSELECT '\"\\u000g\"'::jsonb;\t\t-- ERROR, g is not a hex digit\nSELECT '\"\\u0045\"'::jsonb;\t\t-- OK, legal escape\nSELECT '\"\\u0000\"'::jsonb;\t\t-- ERROR, we don't support U+0000\n-- use octet_length here so we don't get an odd unicode char in the\n-- output\nSELECT octet_length('\"\\uaBcD\"'::jsonb::text); -- OK, uppercase and lower case both OK\n\n-- handling of unicode surrogate pairs\n\nSELECT octet_length((jsonb '{ \"a\":  \"\\ud83d\\ude04\\ud83d\\udc36\" }' -> 'a')::text) AS correct_in_utf8;\nSELECT jsonb '{ \"a\":  \"\\ud83d\\ud83d\" }' -> 'a'; -- 2 high surrogates in a row\nSELECT jsonb '{ \"a\":  \"\\ude04\\ud83d\" }' -> 'a'; -- surrogates in wrong order\nSELECT jsonb '{ \"a\":  \"\\ud83dX\" }' -> 'a'; -- orphan high surrogate\nSELECT jsonb '{ \"a\":  \"\\ude04X\" }' -> 'a'; -- orphan low surrogate\n\n-- handling of simple unicode escapes\n\nSELECT jsonb '{ \"a\":  \"the Copyright \\u00a9 sign\" }' as correct_in_utf8;\nSELECT jsonb '{ \"a\":  \"dollar \\u0024 character\" }' as correct_everywhere;\nSELECT jsonb '{ \"a\":  \"dollar \\\\u0024 character\" }' as not_an_escape;\nSELECT jsonb '{ \"a\":  \"null \\u0000 escape\" }' as fails;\nSELECT jsonb '{ \"a\":  \"null \\\\u0000 escape\" }' as not_an_escape;\n\nSELECT jsonb '{ \"a\":  \"the Copyright \\u00a9 sign\" }' ->> 'a' as correct_in_utf8;\nSELECT jsonb '{ \"a\":  \"dollar \\u0024 character\" }' ->> 'a' as correct_everywhere;\nSELECT jsonb '{ \"a\":  \"dollar \\\\u0024 character\" }' ->> 'a' as not_an_escape;\nSELECT jsonb '{ \"a\":  \"null \\u0000 escape\" }' ->> 'a' as fails;\nSELECT jsonb '{ \"a\":  \"null \\\\u0000 escape\" }' ->> 'a' as not_an_escape;\n",
  "upstream/line.sql": "--\n-- LINE\n-- Infinite lines\n--\n\n--DROP TABLE LINE_TBL;\nCREATE TABLE LINE_TBL (s line);\n\nINSERT INTO LINE_TBL VALUES ('{1,-1,1}');\nINSERT INTO LINE_TBL VALUES ('(0,0),(6,6)');\nINSERT INTO LINE_TBL VALUES ('10,-10 ,-5,-4');\nINSERT INTO LINE_TBL VALUES ('[-1e6,2e2,3e5, -4e1]');\nINSERT INTO LINE_TBL VALUES ('(11,22,33,44)');\n\nINSERT INTO LINE_TBL VALUES ('[(1,0),(1,0)]');\n\n-- horizontal\nINSERT INTO LINE_TBL VALUES ('[(1,3),(2,3)]');\n-- vertical\nINSERT INTO LINE_TBL VALUES ('[(3,1),(3,2)]');\n\n-- bad values for parser testing\nINSERT INTO LINE_TBL VALUES ('{0,0,1}');\nINSERT INTO LINE_TBL VALUES ('(3asdf,2 ,3,4r2)');\nINSERT INTO LINE_TBL VALUES ('[1,2,3, 4');\nINSERT INTO LINE_TBL VALUES ('[(,2),(3,4)]');\nINSERT INTO LINE_TBL VALUES ('[(1,2),(3,4)');\n\nselect * from LINE_TBL;\n\n\n-- functions and operators\n\nSELECT * FROM LINE_TBL WHERE (s <-> line '[(1,2),(3,4)]') < 10;\n\nSELECT * FROM LINE_TBL WHERE (point '(0.1,0.1)' <-> s) < 1;\n\nSELECT * FROM LINE_TBL WHERE (lseg '[(0.1,0.1),(0.2,0.2)]' <-> s) < 1;\n\nSELECT line '[(1,1),(2,1)]' <-> line '[(-1,-1),(-2,-1)]';\nSELECT lseg '[(1,1),(2,1)]' <-> line '[(-1,-1),(-2,-1)]';\nSELECT point '(-1,1)' <-> line '[(-3,0),(-4,0)]';\n\nSELECT lseg '[(1,1),(5,5)]' ?# line '[(2,0),(0,2)]';  -- true\nSELECT lseg '[(1,1),(5,5)]' ?# line '[(0,0),(1,0)]';  -- false\n\nSELECT line '[(0,0),(1,1)]' ?# box '(0,0,2,2)';  -- true\nSELECT line '[(3,0),(4,1)]' ?# box '(0,0,2,2)';  -- false\n\nSELECT point '(1,1)' <@ line '[(0,0),(2,2)]';  -- true\nSELECT point '(1,1)' <@ line '[(0,0),(1,0)]';  -- false\n\nSELECT point '(1,1)' @ line '[(0,0),(2,2)]';  -- true\nSELECT point '(1,1)' @ line '[(0,0),(1,0)]';  -- false\n\nSELECT lseg '[(1,1),(2,2)]' <@ line '[(0,0),(2,2)]';  -- true\nSELECT lseg '[(1,1),(2,1)]' <@ line '[(0,0),(1,0)]';  -- false\n\nSELECT lseg '[(1,1),(2,2)]' @ line '[(0,0),(2,2)]';  -- true\nSELECT lseg '[(1,1),(2,1)]' @ line '[(0,0),(1,0)]';  -- false\n\nSELECT point '(0,1)' ## line '[(0,0),(1,1)]';\n\nSELECT line '[(0,0),(1,1)]' ## lseg '[(1,0),(2,0)]';\n\nSELECT line '[(0,0),(1,1)]' ?# line '[(1,0),(2,1)]';  -- false\nSELECT line '[(0,0),(1,1)]' ?# line '[(1,0),(1,1)]';  -- true\n\nSELECT line '[(0,0),(1,1)]' # line '[(1,0),(2,1)]';\nSELECT line '[(0,0),(1,1)]' # line '[(1,0),(1,1)]';\n\nSELECT line '[(0,0),(1,1)]' ?|| line '[(1,0),(2,1)]';  -- true\nSELECT line '[(0,0),(1,1)]' ?|| line '[(1,0),(1,1)]';  -- false\n\nSELECT line '[(0,0),(1,0)]' ?-| line '[(0,0),(0,1)]';  -- true\nSELECT line '[(0,0),(1,1)]' ?-| line '[(1,0),(1,1)]';  -- false\n\nSELECT ?- line '[(0,0),(1,0)]';  -- true\nSELECT ?- line '[(0,0),(1,1)]';  -- false\n\nSELECT ?| line '[(0,0),(0,1)]';  -- true\nSELECT ?| line '[(0,0),(1,1)]';  -- false\n\nSELECT line(point '(1,2)', point '(3,4)');\n\nSELECT line '[(1,2),(3,4)]' = line '[(3,4),(4,5)]';  -- true\nSELECT line '[(1,2),(3,4)]' = line '[(3,4),(4,4)]';  -- false\n",
  "upstream/lseg.sql": "--\n-- LSEG\n-- Line segments\n--\n\n--DROP TABLE LSEG_TBL;\nCREATE TABLE LSEG_TBL (s lseg);\n\nINSERT INTO LSEG_TBL VALUES ('[(1,2),(3,4)]');\nINSERT INTO LSEG_TBL VALUES ('(0,0),(6,6)');\nINSERT INTO LSEG_TBL VALUES ('10,-10 ,-3,-4');\nINSERT INTO LSEG_TBL VALUES ('[-1e6,2e2,3e5, -4e1]');\nINSERT INTO LSEG_TBL VALUES ('(11,22,33,44)');\n\n-- bad values for parser testing\nINSERT INTO LSEG_TBL VALUES ('(3asdf,2 ,3,4r2)');\nINSERT INTO LSEG_TBL VALUES ('[1,2,3, 4');\nINSERT INTO LSEG_TBL VALUES ('[(,2),(3,4)]');\nINSERT INTO LSEG_TBL VALUES ('[(1,2),(3,4)');\n\nselect * from LSEG_TBL;\n\nSELECT * FROM LSEG_TBL WHERE s <= lseg '[(1,2),(3,4)]';\n\nSELECT * FROM LSEG_TBL WHERE (s <-> lseg '[(1,2),(3,4)]') < 10;\n",
  "upstream/misc_functions.sql": "--\n-- num_nulls()\n--\n\nSELECT num_nonnulls(NULL);\nSELECT num_nonnulls('1');\nSELECT num_nonnulls(NULL::text);\nSELECT num_nonnulls(NULL::text, NULL::int);\nSELECT num_nonnulls(1, 2, NULL::text, NULL::point, '', int8 '9', 1.0 / NULL);\nSELECT num_nonnulls(VARIADIC '{1,2,NULL,3}'::int[]);\nSELECT num_nonnulls(VARIADIC '{\"1\",\"2\",\"3\",\"4\"}'::text[]);\nSELECT num_nonnulls(VARIADIC ARRAY(SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) i));\n\nSELECT num_nulls(NULL);\nSELECT num_nulls('1');\nSELECT num_nulls(NULL::text);\nSELECT num_nulls(NULL::text, NULL::int);\nSELECT num_nulls(1, 2, NULL::text, NULL::point, '', int8 '9', 1.0 / NULL);\nSELECT num_nulls(VARIADIC '{1,2,NULL,3}'::int[]);\nSELECT num_nulls(VARIADIC '{\"1\",\"2\",\"3\",\"4\"}'::text[]);\nSELECT num_nulls(VARIADIC ARRAY(SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) i));\n\n-- special cases\nSELECT num_nonnulls(VARIADIC NULL::text[]);\nSELECT num_nonnulls(VARIADIC '{}'::int[]);\nSELECT num_nulls(VARIADIC NULL::text[]);\nSELECT num_nulls(VARIADIC '{}'::int[]);\n\n-- should fail, one or more arguments is required\nSELECT num_nonnulls();\nSELECT num_nulls();\n",
  "upstream/money.sql": "--\n-- MONEY\n--\n\nCREATE TABLE money_data (m money);\n\nINSERT INTO money_data VALUES ('123');\nSELECT * FROM money_data;\nSELECT m + '123' FROM money_data;\nSELECT m + '123.45' FROM money_data;\nSELECT m - '123.45' FROM money_data;\nSELECT m * 2 FROM money_data;\nSELECT m / 2 FROM money_data;\n\n-- All true\nSELECT m = '$123.00' FROM money_data;\nSELECT m != '$124.00' FROM money_data;\nSELECT m <= '$123.00' FROM money_data;\nSELECT m >= '$123.00' FROM money_data;\nSELECT m < '$124.00' FROM money_data;\nSELECT m > '$122.00' FROM money_data;\n\n-- All false\nSELECT m = '$123.01' FROM money_data;\nSELECT m != '$123.00' FROM money_data;\nSELECT m <= '$122.99' FROM money_data;\nSELECT m >= '$123.01' FROM money_data;\nSELECT m > '$124.00' FROM money_data;\nSELECT m < '$122.00' FROM money_data;\n\nSELECT cashlarger(m, '$124.00') FROM money_data;\nSELECT cashsmaller(m, '$124.00') FROM money_data;\nSELECT cash_words(m) FROM money_data;\nSELECT cash_words(m + '1.23') FROM money_data;\n\nDELETE FROM money_data;\nINSERT INTO money_data VALUES ('$123.45');\nSELECT * FROM money_data;\n\nDELETE FROM money_data;\nINSERT INTO money_data VALUES ('$123.451');\nSELECT * FROM money_data;\n\nDELETE FROM money_data;\nINSERT INTO money_data VALUES ('$123.454');\nSELECT * FROM money_data;\n\nDELETE FROM money_data;\nINSERT INTO money_data VALUES ('$123.455');\nSELECT * FROM money_data;\n\nDELETE FROM money_data;\nINSERT INTO money_data VALUES ('$123.456');\nSELECT * FROM money_data;\n\nDELETE FROM money_data;\nINSERT INTO money_data VALUES ('$123.459');\nSELECT * FROM money_data;\n\n-- Cast int4/int8 to money\nSELECT 1234567890::money;\nSELECT 12345678901234567::money;\nSELECT 123456789012345678::money;\nSELECT 9223372036854775807::money;\nSELECT (-12345)::money;\nSELECT (-1234567890)::money;\nSELECT (-12345678901234567)::money;\nSELECT (-123456789012345678)::money;\nSELECT (-9223372036854775808)::money;\nSELECT 1234567890::int4::money;\nSELECT 12345678901234567::int8::money;\nSELECT (-1234567890)::int4::money;\nSELECT (-12345678901234567)::int8::money;\n",
  "upstream/numerology.sql": "--\n-- NUMEROLOGY\n-- Test various combinations of numeric types and functions.\n--\n\n--\n-- Test implicit type conversions\n-- This fails for Postgres v6.1 (and earlier?)\n--  so let's try explicit conversions for now - tgl 97/05/07\n--\n\nCREATE TABLE TEMP_FLOAT (f1 FLOAT8);\n\nINSERT INTO TEMP_FLOAT (f1)\n  SELECT float8(f1) FROM INT4_TBL;\n\nINSERT INTO TEMP_FLOAT (f1)\n  SELECT float8(f1) FROM INT2_TBL;\n\nSELECT '' AS ten, f1 FROM TEMP_FLOAT\n  ORDER BY f1;\n\n-- int4\n\nCREATE TABLE TEMP_INT4 (f1 INT4);\n\nINSERT INTO TEMP_INT4 (f1)\n  SELECT int4(f1) FROM FLOAT8_TBL\n  WHERE (f1 > -2147483647) AND (f1 < 2147483647);\n\nINSERT INTO TEMP_INT4 (f1)\n  SELECT int4(f1) FROM INT2_TBL;\n\nSELECT '' AS nine, f1 FROM TEMP_INT4\n  ORDER BY f1;\n\n-- int2\n\nCREATE TABLE TEMP_INT2 (f1 INT2);\n\nINSERT INTO TEMP_INT2 (f1)\n  SELECT int2(f1) FROM FLOAT8_TBL\n  WHERE (f1 >= -32767) AND (f1 <= 32767);\n\nINSERT INTO TEMP_INT2 (f1)\n  SELECT int2(f1) FROM INT4_TBL\n  WHERE (f1 >= -32767) AND (f1 <= 32767);\n\nSELECT '' AS five, f1 FROM TEMP_INT2\n  ORDER BY f1;\n\n--\n-- Group-by combinations\n--\n\nCREATE TABLE TEMP_GROUP (f1 INT4, f2 INT4, f3 FLOAT8);\n\nINSERT INTO TEMP_GROUP\n  SELECT 1, (- i.f1), (- f.f1)\n  FROM INT4_TBL i, FLOAT8_TBL f;\n\nINSERT INTO TEMP_GROUP\n  SELECT 2, i.f1, f.f1\n  FROM INT4_TBL i, FLOAT8_TBL f;\n\nSELECT DISTINCT f1 AS two FROM TEMP_GROUP ORDER BY 1;\n\nSELECT f1 AS two, max(f3) AS max_float, min(f3) as min_float\n  FROM TEMP_GROUP\n  GROUP BY f1\n  ORDER BY two, max_float, min_float;\n\n-- GROUP BY a result column name is not legal per SQL92, but we accept it\n-- anyway (if the name is not the name of any column exposed by FROM).\nSELECT f1 AS two, max(f3) AS max_float, min(f3) AS min_float\n  FROM TEMP_GROUP\n  GROUP BY two\n  ORDER BY two, max_float, min_float;\n\nSELECT f1 AS two, (max(f3) + 1) AS max_plus_1, (min(f3) - 1) AS min_minus_1\n  FROM TEMP_GROUP\n  GROUP BY f1\n  ORDER BY two, min_minus_1;\n\nSELECT f1 AS two,\n       max(f2) + min(f2) AS max_plus_min,\n       min(f3) - 1 AS min_minus_1\n  FROM TEMP_GROUP\n  GROUP BY f1\n  ORDER BY two, min_minus_1;\n\nDROP TABLE TEMP_INT2;\n\nDROP TABLE TEMP_INT4;\n\nDROP TABLE TEMP_FLOAT;\n\nDROP TABLE TEMP_GROUP;\n",
  "upstream/oid.sql": "--\n-- OID\n--\n\nCREATE TABLE OID_TBL(f1 oid);\n\nINSERT INTO OID_TBL(f1) VALUES ('1234');\nINSERT INTO OID_TBL(f1) VALUES ('1235');\nINSERT INTO OID_TBL(f1) VALUES ('987');\nINSERT INTO OID_TBL(f1) VALUES ('-1040');\nINSERT INTO OID_TBL(f1) VALUES ('99999999');\nINSERT INTO OID_TBL(f1) VALUES ('5     ');\nINSERT INTO OID_TBL(f1) VALUES ('   10  ');\n-- leading/trailing hard tab is also allowed\nINSERT INTO OID_TBL(f1) VALUES ('\t  15 \t  ');\n\n-- bad inputs\nINSERT INTO OID_TBL(f1) VALUES ('');\nINSERT INTO OID_TBL(f1) VALUES ('    ');\nINSERT INTO OID_TBL(f1) VALUES ('asdfasd');\nINSERT INTO OID_TBL(f1) VALUES ('99asdfasd');\nINSERT INTO OID_TBL(f1) VALUES ('5    d');\nINSERT INTO OID_TBL(f1) VALUES ('    5d');\nINSERT INTO OID_TBL(f1) VALUES ('5    5');\nINSERT INTO OID_TBL(f1) VALUES (' - 500');\nINSERT INTO OID_TBL(f1) VALUES ('32958209582039852935');\nINSERT INTO OID_TBL(f1) VALUES ('-23582358720398502385');\n\nSELECT '' AS six, * FROM OID_TBL;\n\nSELECT '' AS one, o.* FROM OID_TBL o WHERE o.f1 = 1234;\n\nSELECT '' AS five, o.* FROM OID_TBL o WHERE o.f1 <> '1234';\n\nSELECT '' AS three, o.* FROM OID_TBL o WHERE o.f1 <= '1234';\n\nSELECT '' AS two, o.* FROM OID_TBL o WHERE o.f1 < '1234';\n\nSELECT '' AS four, o.* FROM OID_TBL o WHERE o.f1 >= '1234';\n\nSELECT '' AS three, o.* FROM OID_TBL o WHERE o.f1 > '1234';\n\nDROP TABLE OID_TBL;\n",
  "upstream/oidjoins.sql": "--\n-- This is created by pgsql/src/tools/findoidjoins/make_oidjoins_check\n--\nSELECT\tctid, aggfnoid\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggfnoid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggfnoid);\nSELECT\tctid, aggtransfn\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggtransfn != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggtransfn);\nSELECT\tctid, aggfinalfn\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggfinalfn != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggfinalfn);\nSELECT\tctid, aggmtransfn\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggmtransfn != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggmtransfn);\nSELECT\tctid, aggminvtransfn\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggminvtransfn != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggminvtransfn);\nSELECT\tctid, aggmfinalfn\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggmfinalfn != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.aggmfinalfn);\nSELECT\tctid, aggsortop\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggsortop != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.aggsortop);\nSELECT\tctid, aggtranstype\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggtranstype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.aggtranstype);\nSELECT\tctid, aggmtranstype\nFROM\tpg_catalog.pg_aggregate fk\nWHERE\taggmtranstype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.aggmtranstype);\nSELECT\tctid, amhandler\nFROM\tpg_catalog.pg_am fk\nWHERE\tamhandler != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.amhandler);\nSELECT\tctid, amopfamily\nFROM\tpg_catalog.pg_amop fk\nWHERE\tamopfamily != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_opfamily pk WHERE pk.oid = fk.amopfamily);\nSELECT\tctid, amoplefttype\nFROM\tpg_catalog.pg_amop fk\nWHERE\tamoplefttype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.amoplefttype);\nSELECT\tctid, amoprighttype\nFROM\tpg_catalog.pg_amop fk\nWHERE\tamoprighttype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.amoprighttype);\nSELECT\tctid, amopopr\nFROM\tpg_catalog.pg_amop fk\nWHERE\tamopopr != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.amopopr);\nSELECT\tctid, amopmethod\nFROM\tpg_catalog.pg_amop fk\nWHERE\tamopmethod != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_am pk WHERE pk.oid = fk.amopmethod);\nSELECT\tctid, amopsortfamily\nFROM\tpg_catalog.pg_amop fk\nWHERE\tamopsortfamily != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_opfamily pk WHERE pk.oid = fk.amopsortfamily);\nSELECT\tctid, amprocfamily\nFROM\tpg_catalog.pg_amproc fk\nWHERE\tamprocfamily != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_opfamily pk WHERE pk.oid = fk.amprocfamily);\nSELECT\tctid, amproclefttype\nFROM\tpg_catalog.pg_amproc fk\nWHERE\tamproclefttype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.amproclefttype);\nSELECT\tctid, amprocrighttype\nFROM\tpg_catalog.pg_amproc fk\nWHERE\tamprocrighttype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.amprocrighttype);\nSELECT\tctid, amproc\nFROM\tpg_catalog.pg_amproc fk\nWHERE\tamproc != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.amproc);\nSELECT\tctid, adrelid\nFROM\tpg_catalog.pg_attrdef fk\nWHERE\tadrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.adrelid);\nSELECT\tctid, attrelid\nFROM\tpg_catalog.pg_attribute fk\nWHERE\tattrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.attrelid);\nSELECT\tctid, atttypid\nFROM\tpg_catalog.pg_attribute fk\nWHERE\tatttypid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.atttypid);\nSELECT\tctid, attcollation\nFROM\tpg_catalog.pg_attribute fk\nWHERE\tattcollation != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_collation pk WHERE pk.oid = fk.attcollation);\nSELECT\tctid, castsource\nFROM\tpg_catalog.pg_cast fk\nWHERE\tcastsource != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.castsource);\nSELECT\tctid, casttarget\nFROM\tpg_catalog.pg_cast fk\nWHERE\tcasttarget != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.casttarget);\nSELECT\tctid, castfunc\nFROM\tpg_catalog.pg_cast fk\nWHERE\tcastfunc != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.castfunc);\nSELECT\tctid, relnamespace\nFROM\tpg_catalog.pg_class fk\nWHERE\trelnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.relnamespace);\nSELECT\tctid, reltype\nFROM\tpg_catalog.pg_class fk\nWHERE\treltype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.reltype);\nSELECT\tctid, reloftype\nFROM\tpg_catalog.pg_class fk\nWHERE\treloftype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.reloftype);\nSELECT\tctid, relowner\nFROM\tpg_catalog.pg_class fk\nWHERE\trelowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.relowner);\nSELECT\tctid, relam\nFROM\tpg_catalog.pg_class fk\nWHERE\trelam != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_am pk WHERE pk.oid = fk.relam);\nSELECT\tctid, reltablespace\nFROM\tpg_catalog.pg_class fk\nWHERE\treltablespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_tablespace pk WHERE pk.oid = fk.reltablespace);\nSELECT\tctid, reltoastrelid\nFROM\tpg_catalog.pg_class fk\nWHERE\treltoastrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.reltoastrelid);\nSELECT\tctid, collnamespace\nFROM\tpg_catalog.pg_collation fk\nWHERE\tcollnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.collnamespace);\nSELECT\tctid, collowner\nFROM\tpg_catalog.pg_collation fk\nWHERE\tcollowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.collowner);\nSELECT\tctid, connamespace\nFROM\tpg_catalog.pg_constraint fk\nWHERE\tconnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.connamespace);\nSELECT\tctid, conrelid\nFROM\tpg_catalog.pg_constraint fk\nWHERE\tconrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.conrelid);\nSELECT\tctid, contypid\nFROM\tpg_catalog.pg_constraint fk\nWHERE\tcontypid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.contypid);\nSELECT\tctid, conindid\nFROM\tpg_catalog.pg_constraint fk\nWHERE\tconindid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.conindid);\nSELECT\tctid, confrelid\nFROM\tpg_catalog.pg_constraint fk\nWHERE\tconfrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.confrelid);\nSELECT\tctid, connamespace\nFROM\tpg_catalog.pg_conversion fk\nWHERE\tconnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.connamespace);\nSELECT\tctid, conowner\nFROM\tpg_catalog.pg_conversion fk\nWHERE\tconowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.conowner);\nSELECT\tctid, conproc\nFROM\tpg_catalog.pg_conversion fk\nWHERE\tconproc != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.conproc);\nSELECT\tctid, datdba\nFROM\tpg_catalog.pg_database fk\nWHERE\tdatdba != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.datdba);\nSELECT\tctid, dattablespace\nFROM\tpg_catalog.pg_database fk\nWHERE\tdattablespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_tablespace pk WHERE pk.oid = fk.dattablespace);\nSELECT\tctid, setdatabase\nFROM\tpg_catalog.pg_db_role_setting fk\nWHERE\tsetdatabase != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_database pk WHERE pk.oid = fk.setdatabase);\nSELECT\tctid, classid\nFROM\tpg_catalog.pg_depend fk\nWHERE\tclassid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.classid);\nSELECT\tctid, refclassid\nFROM\tpg_catalog.pg_depend fk\nWHERE\trefclassid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.refclassid);\nSELECT\tctid, classoid\nFROM\tpg_catalog.pg_description fk\nWHERE\tclassoid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.classoid);\nSELECT\tctid, enumtypid\nFROM\tpg_catalog.pg_enum fk\nWHERE\tenumtypid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.enumtypid);\nSELECT\tctid, extowner\nFROM\tpg_catalog.pg_extension fk\nWHERE\textowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.extowner);\nSELECT\tctid, extnamespace\nFROM\tpg_catalog.pg_extension fk\nWHERE\textnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.extnamespace);\nSELECT\tctid, fdwowner\nFROM\tpg_catalog.pg_foreign_data_wrapper fk\nWHERE\tfdwowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.fdwowner);\nSELECT\tctid, srvowner\nFROM\tpg_catalog.pg_foreign_server fk\nWHERE\tsrvowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.srvowner);\nSELECT\tctid, srvfdw\nFROM\tpg_catalog.pg_foreign_server fk\nWHERE\tsrvfdw != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_foreign_data_wrapper pk WHERE pk.oid = fk.srvfdw);\nSELECT\tctid, indexrelid\nFROM\tpg_catalog.pg_index fk\nWHERE\tindexrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.indexrelid);\nSELECT\tctid, indrelid\nFROM\tpg_catalog.pg_index fk\nWHERE\tindrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.indrelid);\nSELECT\tctid, inhrelid\nFROM\tpg_catalog.pg_inherits fk\nWHERE\tinhrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.inhrelid);\nSELECT\tctid, inhparent\nFROM\tpg_catalog.pg_inherits fk\nWHERE\tinhparent != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.inhparent);\nSELECT\tctid, lanowner\nFROM\tpg_catalog.pg_language fk\nWHERE\tlanowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.lanowner);\nSELECT\tctid, lanplcallfoid\nFROM\tpg_catalog.pg_language fk\nWHERE\tlanplcallfoid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.lanplcallfoid);\nSELECT\tctid, laninline\nFROM\tpg_catalog.pg_language fk\nWHERE\tlaninline != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.laninline);\nSELECT\tctid, lanvalidator\nFROM\tpg_catalog.pg_language fk\nWHERE\tlanvalidator != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.lanvalidator);\nSELECT\tctid, loid\nFROM\tpg_catalog.pg_largeobject fk\nWHERE\tloid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_largeobject_metadata pk WHERE pk.oid = fk.loid);\nSELECT\tctid, lomowner\nFROM\tpg_catalog.pg_largeobject_metadata fk\nWHERE\tlomowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.lomowner);\nSELECT\tctid, nspowner\nFROM\tpg_catalog.pg_namespace fk\nWHERE\tnspowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.nspowner);\nSELECT\tctid, opcmethod\nFROM\tpg_catalog.pg_opclass fk\nWHERE\topcmethod != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_am pk WHERE pk.oid = fk.opcmethod);\nSELECT\tctid, opcnamespace\nFROM\tpg_catalog.pg_opclass fk\nWHERE\topcnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.opcnamespace);\nSELECT\tctid, opcowner\nFROM\tpg_catalog.pg_opclass fk\nWHERE\topcowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.opcowner);\nSELECT\tctid, opcfamily\nFROM\tpg_catalog.pg_opclass fk\nWHERE\topcfamily != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_opfamily pk WHERE pk.oid = fk.opcfamily);\nSELECT\tctid, opcintype\nFROM\tpg_catalog.pg_opclass fk\nWHERE\topcintype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.opcintype);\nSELECT\tctid, opckeytype\nFROM\tpg_catalog.pg_opclass fk\nWHERE\topckeytype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.opckeytype);\nSELECT\tctid, oprnamespace\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.oprnamespace);\nSELECT\tctid, oprowner\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.oprowner);\nSELECT\tctid, oprleft\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprleft != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.oprleft);\nSELECT\tctid, oprright\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprright != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.oprright);\nSELECT\tctid, oprresult\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprresult != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.oprresult);\nSELECT\tctid, oprcom\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprcom != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.oprcom);\nSELECT\tctid, oprnegate\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprnegate != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.oprnegate);\nSELECT\tctid, oprcode\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprcode != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.oprcode);\nSELECT\tctid, oprrest\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprrest != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.oprrest);\nSELECT\tctid, oprjoin\nFROM\tpg_catalog.pg_operator fk\nWHERE\toprjoin != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.oprjoin);\nSELECT\tctid, opfmethod\nFROM\tpg_catalog.pg_opfamily fk\nWHERE\topfmethod != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_am pk WHERE pk.oid = fk.opfmethod);\nSELECT\tctid, opfnamespace\nFROM\tpg_catalog.pg_opfamily fk\nWHERE\topfnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.opfnamespace);\nSELECT\tctid, opfowner\nFROM\tpg_catalog.pg_opfamily fk\nWHERE\topfowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.opfowner);\nSELECT\tctid, polrelid\nFROM\tpg_catalog.pg_policy fk\nWHERE\tpolrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.polrelid);\nSELECT\tctid, pronamespace\nFROM\tpg_catalog.pg_proc fk\nWHERE\tpronamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.pronamespace);\nSELECT\tctid, proowner\nFROM\tpg_catalog.pg_proc fk\nWHERE\tproowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.proowner);\nSELECT\tctid, prolang\nFROM\tpg_catalog.pg_proc fk\nWHERE\tprolang != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_language pk WHERE pk.oid = fk.prolang);\nSELECT\tctid, provariadic\nFROM\tpg_catalog.pg_proc fk\nWHERE\tprovariadic != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.provariadic);\nSELECT\tctid, protransform\nFROM\tpg_catalog.pg_proc fk\nWHERE\tprotransform != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.protransform);\nSELECT\tctid, prorettype\nFROM\tpg_catalog.pg_proc fk\nWHERE\tprorettype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.prorettype);\nSELECT\tctid, rngtypid\nFROM\tpg_catalog.pg_range fk\nWHERE\trngtypid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.rngtypid);\nSELECT\tctid, rngsubtype\nFROM\tpg_catalog.pg_range fk\nWHERE\trngsubtype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.rngsubtype);\nSELECT\tctid, rngcollation\nFROM\tpg_catalog.pg_range fk\nWHERE\trngcollation != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_collation pk WHERE pk.oid = fk.rngcollation);\nSELECT\tctid, rngsubopc\nFROM\tpg_catalog.pg_range fk\nWHERE\trngsubopc != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_opclass pk WHERE pk.oid = fk.rngsubopc);\nSELECT\tctid, rngcanonical\nFROM\tpg_catalog.pg_range fk\nWHERE\trngcanonical != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.rngcanonical);\nSELECT\tctid, rngsubdiff\nFROM\tpg_catalog.pg_range fk\nWHERE\trngsubdiff != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.rngsubdiff);\nSELECT\tctid, ev_class\nFROM\tpg_catalog.pg_rewrite fk\nWHERE\tev_class != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.ev_class);\nSELECT\tctid, refclassid\nFROM\tpg_catalog.pg_shdepend fk\nWHERE\trefclassid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.refclassid);\nSELECT\tctid, classoid\nFROM\tpg_catalog.pg_shdescription fk\nWHERE\tclassoid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.classoid);\nSELECT\tctid, starelid\nFROM\tpg_catalog.pg_statistic fk\nWHERE\tstarelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.starelid);\nSELECT\tctid, staop1\nFROM\tpg_catalog.pg_statistic fk\nWHERE\tstaop1 != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop1);\nSELECT\tctid, staop2\nFROM\tpg_catalog.pg_statistic fk\nWHERE\tstaop2 != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop2);\nSELECT\tctid, staop3\nFROM\tpg_catalog.pg_statistic fk\nWHERE\tstaop3 != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop3);\nSELECT\tctid, staop4\nFROM\tpg_catalog.pg_statistic fk\nWHERE\tstaop4 != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop4);\nSELECT\tctid, staop5\nFROM\tpg_catalog.pg_statistic fk\nWHERE\tstaop5 != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.staop5);\nSELECT\tctid, spcowner\nFROM\tpg_catalog.pg_tablespace fk\nWHERE\tspcowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.spcowner);\nSELECT\tctid, trftype\nFROM\tpg_catalog.pg_transform fk\nWHERE\ttrftype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.trftype);\nSELECT\tctid, trflang\nFROM\tpg_catalog.pg_transform fk\nWHERE\ttrflang != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_language pk WHERE pk.oid = fk.trflang);\nSELECT\tctid, trffromsql\nFROM\tpg_catalog.pg_transform fk\nWHERE\ttrffromsql != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.trffromsql);\nSELECT\tctid, trftosql\nFROM\tpg_catalog.pg_transform fk\nWHERE\ttrftosql != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.trftosql);\nSELECT\tctid, tgrelid\nFROM\tpg_catalog.pg_trigger fk\nWHERE\ttgrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.tgrelid);\nSELECT\tctid, tgfoid\nFROM\tpg_catalog.pg_trigger fk\nWHERE\ttgfoid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.tgfoid);\nSELECT\tctid, tgconstrrelid\nFROM\tpg_catalog.pg_trigger fk\nWHERE\ttgconstrrelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.tgconstrrelid);\nSELECT\tctid, tgconstrindid\nFROM\tpg_catalog.pg_trigger fk\nWHERE\ttgconstrindid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.tgconstrindid);\nSELECT\tctid, tgconstraint\nFROM\tpg_catalog.pg_trigger fk\nWHERE\ttgconstraint != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_constraint pk WHERE pk.oid = fk.tgconstraint);\nSELECT\tctid, cfgnamespace\nFROM\tpg_catalog.pg_ts_config fk\nWHERE\tcfgnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.cfgnamespace);\nSELECT\tctid, cfgowner\nFROM\tpg_catalog.pg_ts_config fk\nWHERE\tcfgowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.cfgowner);\nSELECT\tctid, cfgparser\nFROM\tpg_catalog.pg_ts_config fk\nWHERE\tcfgparser != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_ts_parser pk WHERE pk.oid = fk.cfgparser);\nSELECT\tctid, mapcfg\nFROM\tpg_catalog.pg_ts_config_map fk\nWHERE\tmapcfg != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_ts_config pk WHERE pk.oid = fk.mapcfg);\nSELECT\tctid, mapdict\nFROM\tpg_catalog.pg_ts_config_map fk\nWHERE\tmapdict != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_ts_dict pk WHERE pk.oid = fk.mapdict);\nSELECT\tctid, dictnamespace\nFROM\tpg_catalog.pg_ts_dict fk\nWHERE\tdictnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.dictnamespace);\nSELECT\tctid, dictowner\nFROM\tpg_catalog.pg_ts_dict fk\nWHERE\tdictowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.dictowner);\nSELECT\tctid, dicttemplate\nFROM\tpg_catalog.pg_ts_dict fk\nWHERE\tdicttemplate != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_ts_template pk WHERE pk.oid = fk.dicttemplate);\nSELECT\tctid, prsnamespace\nFROM\tpg_catalog.pg_ts_parser fk\nWHERE\tprsnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.prsnamespace);\nSELECT\tctid, prsstart\nFROM\tpg_catalog.pg_ts_parser fk\nWHERE\tprsstart != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prsstart);\nSELECT\tctid, prstoken\nFROM\tpg_catalog.pg_ts_parser fk\nWHERE\tprstoken != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prstoken);\nSELECT\tctid, prsend\nFROM\tpg_catalog.pg_ts_parser fk\nWHERE\tprsend != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prsend);\nSELECT\tctid, prsheadline\nFROM\tpg_catalog.pg_ts_parser fk\nWHERE\tprsheadline != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prsheadline);\nSELECT\tctid, prslextype\nFROM\tpg_catalog.pg_ts_parser fk\nWHERE\tprslextype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.prslextype);\nSELECT\tctid, tmplnamespace\nFROM\tpg_catalog.pg_ts_template fk\nWHERE\ttmplnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.tmplnamespace);\nSELECT\tctid, tmplinit\nFROM\tpg_catalog.pg_ts_template fk\nWHERE\ttmplinit != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.tmplinit);\nSELECT\tctid, tmpllexize\nFROM\tpg_catalog.pg_ts_template fk\nWHERE\ttmpllexize != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.tmpllexize);\nSELECT\tctid, typnamespace\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypnamespace != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_namespace pk WHERE pk.oid = fk.typnamespace);\nSELECT\tctid, typowner\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypowner != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_authid pk WHERE pk.oid = fk.typowner);\nSELECT\tctid, typrelid\nFROM\tpg_catalog.pg_type fk\nWHERE\ttyprelid != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_class pk WHERE pk.oid = fk.typrelid);\nSELECT\tctid, typelem\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypelem != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.typelem);\nSELECT\tctid, typarray\nFROM\tpg_catalog.pg_type fk\nWHERE\ttyparray != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.typarray);\nSELECT\tctid, typinput\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypinput != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typinput);\nSELECT\tctid, typoutput\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypoutput != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typoutput);\nSELECT\tctid, typreceive\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypreceive != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typreceive);\nSELECT\tctid, typsend\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypsend != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typsend);\nSELECT\tctid, typmodin\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypmodin != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typmodin);\nSELECT\tctid, typmodout\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypmodout != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typmodout);\nSELECT\tctid, typanalyze\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypanalyze != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_proc pk WHERE pk.oid = fk.typanalyze);\nSELECT\tctid, typbasetype\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypbasetype != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.typbasetype);\nSELECT\tctid, typcollation\nFROM\tpg_catalog.pg_type fk\nWHERE\ttypcollation != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_collation pk WHERE pk.oid = fk.typcollation);\nSELECT\tctid, conpfeqop\nFROM\t(SELECT ctid, unnest(conpfeqop) AS conpfeqop FROM pg_catalog.pg_constraint) fk\nWHERE\tconpfeqop != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.conpfeqop);\nSELECT\tctid, conppeqop\nFROM\t(SELECT ctid, unnest(conppeqop) AS conppeqop FROM pg_catalog.pg_constraint) fk\nWHERE\tconppeqop != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.conppeqop);\nSELECT\tctid, conffeqop\nFROM\t(SELECT ctid, unnest(conffeqop) AS conffeqop FROM pg_catalog.pg_constraint) fk\nWHERE\tconffeqop != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.conffeqop);\nSELECT\tctid, conexclop\nFROM\t(SELECT ctid, unnest(conexclop) AS conexclop FROM pg_catalog.pg_constraint) fk\nWHERE\tconexclop != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_operator pk WHERE pk.oid = fk.conexclop);\nSELECT\tctid, proallargtypes\nFROM\t(SELECT ctid, unnest(proallargtypes) AS proallargtypes FROM pg_catalog.pg_proc) fk\nWHERE\tproallargtypes != 0 AND\n\tNOT EXISTS(SELECT 1 FROM pg_catalog.pg_type pk WHERE pk.oid = fk.proallargtypes);\n",
  "upstream/path.sql": "--\n-- PATH\n--\n\n--DROP TABLE PATH_TBL;\n\nCREATE TABLE PATH_TBL (f1 path);\n\nINSERT INTO PATH_TBL VALUES ('[(1,2),(3,4)]');\n\nINSERT INTO PATH_TBL VALUES ('((1,2),(3,4))');\n\nINSERT INTO PATH_TBL VALUES ('[(0,0),(3,0),(4,5),(1,6)]');\n\nINSERT INTO PATH_TBL VALUES ('((1,2),(3,4))');\n\nINSERT INTO PATH_TBL VALUES ('1,2 ,3,4');\n\nINSERT INTO PATH_TBL VALUES ('[1,2,3, 4]');\n\nINSERT INTO PATH_TBL VALUES ('[11,12,13,14]');\n\nINSERT INTO PATH_TBL VALUES ('(11,12,13,14)');\n\n-- bad values for parser testing\nINSERT INTO PATH_TBL VALUES ('[(,2),(3,4)]');\n\nINSERT INTO PATH_TBL VALUES ('[(1,2),(3,4)');\n\nSELECT f1 FROM PATH_TBL;\n\nSELECT '' AS count, f1 AS open_path FROM PATH_TBL WHERE isopen(f1);\n\nSELECT '' AS count, f1 AS closed_path FROM PATH_TBL WHERE isclosed(f1);\n\nSELECT '' AS count, pclose(f1) AS closed_path FROM PATH_TBL;\n\nSELECT '' AS count, popen(f1) AS open_path FROM PATH_TBL;\n",
  "upstream/polygon.sql": "--\n-- POLYGON\n--\n-- polygon logic\n--\n\nCREATE TABLE POLYGON_TBL(f1 polygon);\n\n\nINSERT INTO POLYGON_TBL(f1) VALUES ('(2.0,0.0),(2.0,4.0),(0.0,0.0)');\n\nINSERT INTO POLYGON_TBL(f1) VALUES ('(3.0,1.0),(3.0,3.0),(1.0,0.0)');\n\n-- degenerate polygons\nINSERT INTO POLYGON_TBL(f1) VALUES ('(0.0,0.0)');\n\nINSERT INTO POLYGON_TBL(f1) VALUES ('(0.0,1.0),(0.0,1.0)');\n\n-- bad polygon input strings\nINSERT INTO POLYGON_TBL(f1) VALUES ('0.0');\n\nINSERT INTO POLYGON_TBL(f1) VALUES ('(0.0 0.0');\n\nINSERT INTO POLYGON_TBL(f1) VALUES ('(0,1,2)');\n\nINSERT INTO POLYGON_TBL(f1) VALUES ('(0,1,2,3');\n\nINSERT INTO POLYGON_TBL(f1) VALUES ('asdf');\n\n\nSELECT '' AS four, * FROM POLYGON_TBL;\n\n-- overlap\nSELECT '' AS three, p.*\n   FROM POLYGON_TBL p\n   WHERE p.f1 && '(3.0,1.0),(3.0,3.0),(1.0,0.0)';\n\n-- left overlap\nSELECT '' AS four, p.*\n   FROM POLYGON_TBL p\n   WHERE p.f1 &< '(3.0,1.0),(3.0,3.0),(1.0,0.0)';\n\n-- right overlap\nSELECT '' AS two, p.*\n   FROM POLYGON_TBL p\n   WHERE p.f1 &> '(3.0,1.0),(3.0,3.0),(1.0,0.0)';\n\n-- left of\nSELECT '' AS one, p.*\n   FROM POLYGON_TBL p\n   WHERE p.f1 << '(3.0,1.0),(3.0,3.0),(1.0,0.0)';\n\n-- right of\nSELECT '' AS zero, p.*\n   FROM POLYGON_TBL p\n   WHERE p.f1 >> '(3.0,1.0),(3.0,3.0),(1.0,0.0)';\n\n-- contained\nSELECT '' AS one, p.*\n   FROM POLYGON_TBL p\n   WHERE p.f1 <@ polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)';\n\n-- same\nSELECT '' AS one, p.*\n   FROM POLYGON_TBL p\n   WHERE p.f1 ~= polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)';\n\n-- contains\nSELECT '' AS one, p.*\n   FROM POLYGON_TBL p\n   WHERE p.f1 @> polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)';\n\n--\n-- polygon logic\n--\n-- left of\nSELECT polygon '(2.0,0.0),(2.0,4.0),(0.0,0.0)' << polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)' AS false;\n\n-- left overlap\nSELECT polygon '(2.0,0.0),(2.0,4.0),(0.0,0.0)' << polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)' AS true;\n\n-- right overlap\nSELECT polygon '(2.0,0.0),(2.0,4.0),(0.0,0.0)' &> polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)' AS false;\n\n-- right of\nSELECT polygon '(2.0,0.0),(2.0,4.0),(0.0,0.0)' >> polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)' AS false;\n\n-- contained in\nSELECT polygon '(2.0,0.0),(2.0,4.0),(0.0,0.0)' <@ polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)' AS false;\n\n-- contains\nSELECT polygon '(2.0,0.0),(2.0,4.0),(0.0,0.0)' @> polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)' AS false;\n\nSELECT '((0,4),(6,4),(1,2),(6,0),(0,0))'::polygon @> '((2,1),(2,3),(3,3),(3,1))'::polygon AS \"false\";\n\nSELECT '((0,4),(6,4),(3,2),(6,0),(0,0))'::polygon @> '((2,1),(2,3),(3,3),(3,1))'::polygon AS \"true\";\n\nSELECT '((1,1),(1,4),(5,4),(5,3),(2,3),(2,2),(5,2),(5,1))'::polygon @> '((3,2),(3,3),(4,3),(4,2))'::polygon AS \"false\";\n\nSELECT '((0,0),(0,3),(3,3),(3,0))'::polygon @> '((2,1),(2,2),(3,2),(3,1))'::polygon AS \"true\";\n\n-- same\nSELECT polygon '(2.0,0.0),(2.0,4.0),(0.0,0.0)' ~= polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)' AS false;\n\n-- overlap\nSELECT polygon '(2.0,0.0),(2.0,4.0),(0.0,0.0)' && polygon '(3.0,1.0),(3.0,3.0),(1.0,0.0)' AS true;\n\nSELECT '((0,4),(6,4),(1,2),(6,0),(0,0))'::polygon && '((2,1),(2,3),(3,3),(3,1))'::polygon AS \"true\";\n\nSELECT '((1,4),(1,1),(4,1),(4,2),(2,2),(2,4),(1,4))'::polygon && '((3,3),(4,3),(4,4),(3,4),(3,3))'::polygon AS \"false\";\nSELECT '((200,800),(800,800),(800,200),(200,200))' &&  '(1000,1000,0,0)'::polygon AS \"true\";\n\n-- distance from a point\nSELECT\t'(0,0)'::point <-> '((0,0),(1,2),(2,1))'::polygon as on_corner,\n\t'(1,1)'::point <-> '((0,0),(2,2),(1,3))'::polygon as on_segment,\n\t'(2,2)'::point <-> '((0,0),(1,4),(3,1))'::polygon as inside,\n\t'(3,3)'::point <-> '((0,2),(2,0),(2,2))'::polygon as near_corner,\n\t'(4,4)'::point <-> '((0,0),(0,3),(4,0))'::polygon as near_segment;\n",
  "upstream/random.sql": "--\n-- RANDOM\n-- Test the random function\n--\n\n-- count the number of tuples originally, should be 1000\nSELECT count(*) FROM onek;\n\n-- pick three random rows, they shouldn't match\n(SELECT unique1 AS random\n  FROM onek ORDER BY random() LIMIT 1)\nINTERSECT\n(SELECT unique1 AS random\n  FROM onek ORDER BY random() LIMIT 1)\nINTERSECT\n(SELECT unique1 AS random\n  FROM onek ORDER BY random() LIMIT 1);\n\n-- count roughly 1/10 of the tuples\nSELECT count(*) AS random INTO RANDOM_TBL\n  FROM onek WHERE random() < 1.0/10;\n\n-- select again, the count should be different\nINSERT INTO RANDOM_TBL (random)\n  SELECT count(*)\n  FROM onek WHERE random() < 1.0/10;\n\n-- select again, the count should be different\nINSERT INTO RANDOM_TBL (random)\n  SELECT count(*)\n  FROM onek WHERE random() < 1.0/10;\n\n-- select again, the count should be different\nINSERT INTO RANDOM_TBL (random)\n  SELECT count(*)\n  FROM onek WHERE random() < 1.0/10;\n\n-- now test that they are different counts\nSELECT random, count(random) FROM RANDOM_TBL\n  GROUP BY random HAVING count(random) > 3;\n\nSELECT AVG(random) FROM RANDOM_TBL\n  HAVING AVG(random) NOT BETWEEN 80 AND 120;\n",
  "upstream/reltime.sql": "--\n-- RELTIME\n--\n\nCREATE TABLE RELTIME_TBL (f1 reltime);\n\nINSERT INTO RELTIME_TBL (f1) VALUES ('@ 1 minute');\n\nINSERT INTO RELTIME_TBL (f1) VALUES ('@ 5 hour');\n\nINSERT INTO RELTIME_TBL (f1) VALUES ('@ 10 day');\n\nINSERT INTO RELTIME_TBL (f1) VALUES ('@ 34 year');\n\nINSERT INTO RELTIME_TBL (f1) VALUES ('@ 3 months');\n\nINSERT INTO RELTIME_TBL (f1) VALUES ('@ 14 seconds ago');\n\n\n-- badly formatted reltimes\nINSERT INTO RELTIME_TBL (f1) VALUES ('badly formatted reltime');\n\nINSERT INTO RELTIME_TBL (f1) VALUES ('@ 30 eons ago');\n\n-- test reltime operators\n\nSELECT '' AS six, * FROM RELTIME_TBL;\n\nSELECT '' AS five, * FROM RELTIME_TBL\n   WHERE RELTIME_TBL.f1 <> reltime '@ 10 days';\n\nSELECT '' AS three, * FROM RELTIME_TBL\n   WHERE RELTIME_TBL.f1 <= reltime '@ 5 hours';\n\nSELECT '' AS three, * FROM RELTIME_TBL\n   WHERE RELTIME_TBL.f1 < reltime '@ 1 day';\n\nSELECT '' AS one, * FROM RELTIME_TBL\n   WHERE RELTIME_TBL.f1 = reltime '@ 34 years';\n\nSELECT '' AS two, * FROM RELTIME_TBL\n   WHERE RELTIME_TBL.f1 >= reltime '@ 1 month';\n\nSELECT '' AS five, * FROM RELTIME_TBL\n   WHERE RELTIME_TBL.f1 > reltime '@ 3 seconds ago';\n\nSELECT '' AS fifteen, r1.*, r2.*\n   FROM RELTIME_TBL r1, RELTIME_TBL r2\n   WHERE r1.f1 > r2.f1\n   ORDER BY r1.f1, r2.f1;\n",
  "upstream/select_distinct_on.sql": "--\n-- SELECT_DISTINCT_ON\n--\n\nSELECT DISTINCT ON (string4) string4, two, ten\n   FROM tmp\n   ORDER BY string4 using <, two using >, ten using <;\n\n-- this will fail due to conflict of ordering requirements\nSELECT DISTINCT ON (string4, ten) string4, two, ten\n   FROM tmp\n   ORDER BY string4 using <, two using <, ten using <;\n\nSELECT DISTINCT ON (string4, ten) string4, ten, two\n   FROM tmp\n   ORDER BY string4 using <, ten using >, two using <;\n\n-- bug #5049: early 8.4.x chokes on volatile DISTINCT ON clauses\nselect distinct on (1) floor(random()) as r, f1 from int4_tbl order by 1,2;\n",
  "upstream/select_having.sql": "--\n-- SELECT_HAVING\n--\n\n-- load test data\nCREATE TABLE test_having (a int, b int, c char(8), d char);\nINSERT INTO test_having VALUES (0, 1, 'XXXX', 'A');\nINSERT INTO test_having VALUES (1, 2, 'AAAA', 'b');\nINSERT INTO test_having VALUES (2, 2, 'AAAA', 'c');\nINSERT INTO test_having VALUES (3, 3, 'BBBB', 'D');\nINSERT INTO test_having VALUES (4, 3, 'BBBB', 'e');\nINSERT INTO test_having VALUES (5, 3, 'bbbb', 'F');\nINSERT INTO test_having VALUES (6, 4, 'cccc', 'g');\nINSERT INTO test_having VALUES (7, 4, 'cccc', 'h');\nINSERT INTO test_having VALUES (8, 4, 'CCCC', 'I');\nINSERT INTO test_having VALUES (9, 4, 'CCCC', 'j');\n\nSELECT b, c FROM test_having\n\tGROUP BY b, c HAVING count(*) = 1 ORDER BY b, c;\n\n-- HAVING is effectively equivalent to WHERE in this case\nSELECT b, c FROM test_having\n\tGROUP BY b, c HAVING b = 3 ORDER BY b, c;\n\nSELECT lower(c), count(c) FROM test_having\n\tGROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)\n\tORDER BY lower(c);\n\nSELECT c, max(a) FROM test_having\n\tGROUP BY c HAVING count(*) > 2 OR min(a) = max(a)\n\tORDER BY c;\n\n-- test degenerate cases involving HAVING without GROUP BY\n-- Per SQL spec, these should generate 0 or 1 row, even without aggregates\n\nSELECT min(a), max(a) FROM test_having HAVING min(a) = max(a);\nSELECT min(a), max(a) FROM test_having HAVING min(a) < max(a);\n\n-- errors: ungrouped column references\nSELECT a FROM test_having HAVING min(a) < max(a);\nSELECT 1 AS one FROM test_having HAVING a > 1;\n\n-- the really degenerate case: need not scan table at all\nSELECT 1 AS one FROM test_having HAVING 1 > 2;\nSELECT 1 AS one FROM test_having HAVING 1 < 2;\n\n-- and just to prove that we aren't scanning the table:\nSELECT 1 AS one FROM test_having WHERE 1/a = 1 HAVING 1 < 2;\n\nDROP TABLE test_having;\n",
  "upstream/select_implicit.sql": "--\n-- SELECT_IMPLICIT\n-- Test cases for queries with ordering terms missing from the target list.\n-- This used to be called \"junkfilter.sql\".\n-- The parser uses the term \"resjunk\" to handle these cases.\n-- - thomas 1998-07-09\n--\n\n-- load test data\nCREATE TABLE test_missing_target (a int, b int, c char(8), d char);\nINSERT INTO test_missing_target VALUES (0, 1, 'XXXX', 'A');\nINSERT INTO test_missing_target VALUES (1, 2, 'ABAB', 'b');\nINSERT INTO test_missing_target VALUES (2, 2, 'ABAB', 'c');\nINSERT INTO test_missing_target VALUES (3, 3, 'BBBB', 'D');\nINSERT INTO test_missing_target VALUES (4, 3, 'BBBB', 'e');\nINSERT INTO test_missing_target VALUES (5, 3, 'bbbb', 'F');\nINSERT INTO test_missing_target VALUES (6, 4, 'cccc', 'g');\nINSERT INTO test_missing_target VALUES (7, 4, 'cccc', 'h');\nINSERT INTO test_missing_target VALUES (8, 4, 'CCCC', 'I');\nINSERT INTO test_missing_target VALUES (9, 4, 'CCCC', 'j');\n\n\n--   w/ existing GROUP BY target\nSELECT c, count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;\n\n--   w/o existing GROUP BY target using a relation name in GROUP BY clause\nSELECT count(*) FROM test_missing_target GROUP BY test_missing_target.c ORDER BY c;\n\n--   w/o existing GROUP BY target and w/o existing a different ORDER BY target\n--   failure expected\nSELECT count(*) FROM test_missing_target GROUP BY a ORDER BY b;\n\n--   w/o existing GROUP BY target and w/o existing same ORDER BY target\nSELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b;\n\n--   w/ existing GROUP BY target using a relation name in target\nSELECT test_missing_target.b, count(*)\n  FROM test_missing_target GROUP BY b ORDER BY b;\n\n--   w/o existing GROUP BY target\nSELECT c FROM test_missing_target ORDER BY a;\n\n--   w/o existing ORDER BY target\nSELECT count(*) FROM test_missing_target GROUP BY b ORDER BY b desc;\n\n--   group using reference number\nSELECT count(*) FROM test_missing_target ORDER BY 1 desc;\n\n--   order using reference number\nSELECT c, count(*) FROM test_missing_target GROUP BY 1 ORDER BY 1;\n\n--   group using reference number out of range\n--   failure expected\nSELECT c, count(*) FROM test_missing_target GROUP BY 3;\n\n--   group w/o existing GROUP BY and ORDER BY target under ambiguous condition\n--   failure expected\nSELECT count(*) FROM test_missing_target x, test_missing_target y\n\tWHERE x.a = y.a\n\tGROUP BY b ORDER BY b;\n\n--   order w/ target under ambiguous condition\n--   failure NOT expected\nSELECT a, a FROM test_missing_target\n\tORDER BY a;\n\n--   order expression w/ target under ambiguous condition\n--   failure NOT expected\nSELECT a/2, a/2 FROM test_missing_target\n\tORDER BY a/2;\n\n--   group expression w/ target under ambiguous condition\n--   failure NOT expected\nSELECT a/2, a/2 FROM test_missing_target\n\tGROUP BY a/2 ORDER BY a/2;\n\n--   group w/ existing GROUP BY target under ambiguous condition\nSELECT x.b, count(*) FROM test_missing_target x, test_missing_target y\n\tWHERE x.a = y.a\n\tGROUP BY x.b ORDER BY x.b;\n\n--   group w/o existing GROUP BY target under ambiguous condition\nSELECT count(*) FROM test_missing_target x, test_missing_target y\n\tWHERE x.a = y.a\n\tGROUP BY x.b ORDER BY x.b;\n\n--   group w/o existing GROUP BY target under ambiguous condition\n--   into a table\nSELECT count(*) INTO TABLE test_missing_target2\nFROM test_missing_target x, test_missing_target y\n\tWHERE x.a = y.a\n\tGROUP BY x.b ORDER BY x.b;\nSELECT * FROM test_missing_target2;\n\n\n--  Functions and expressions\n\n--   w/ existing GROUP BY target\nSELECT a%2, count(b) FROM test_missing_target\nGROUP BY test_missing_target.a%2\nORDER BY test_missing_target.a%2;\n\n--   w/o existing GROUP BY target using a relation name in GROUP BY clause\nSELECT count(c) FROM test_missing_target\nGROUP BY lower(test_missing_target.c)\nORDER BY lower(test_missing_target.c);\n\n--   w/o existing GROUP BY target and w/o existing a different ORDER BY target\n--   failure expected\nSELECT count(a) FROM test_missing_target GROUP BY a ORDER BY b;\n\n--   w/o existing GROUP BY target and w/o existing same ORDER BY target\nSELECT count(b) FROM test_missing_target GROUP BY b/2 ORDER BY b/2;\n\n--   w/ existing GROUP BY target using a relation name in target\nSELECT lower(test_missing_target.c), count(c)\n  FROM test_missing_target GROUP BY lower(c) ORDER BY lower(c);\n\n--   w/o existing GROUP BY target\nSELECT a FROM test_missing_target ORDER BY upper(d);\n\n--   w/o existing ORDER BY target\nSELECT count(b) FROM test_missing_target\n\tGROUP BY (b + 1) / 2 ORDER BY (b + 1) / 2 desc;\n\n--   group w/o existing GROUP BY and ORDER BY target under ambiguous condition\n--   failure expected\nSELECT count(x.a) FROM test_missing_target x, test_missing_target y\n\tWHERE x.a = y.a\n\tGROUP BY b/2 ORDER BY b/2;\n\n--   group w/ existing GROUP BY target under ambiguous condition\nSELECT x.b/2, count(x.b) FROM test_missing_target x, test_missing_target y\n\tWHERE x.a = y.a\n\tGROUP BY x.b/2 ORDER BY x.b/2;\n\n--   group w/o existing GROUP BY target under ambiguous condition\n--   failure expected due to ambiguous b in count(b)\nSELECT count(b) FROM test_missing_target x, test_missing_target y\n\tWHERE x.a = y.a\n\tGROUP BY x.b/2;\n\n--   group w/o existing GROUP BY target under ambiguous condition\n--   into a table\nSELECT count(x.b) INTO TABLE test_missing_target3\nFROM test_missing_target x, test_missing_target y\n\tWHERE x.a = y.a\n\tGROUP BY x.b/2 ORDER BY x.b/2;\nSELECT * FROM test_missing_target3;\n\n--   Cleanup\nDROP TABLE test_missing_target;\nDROP TABLE test_missing_target2;\nDROP TABLE test_missing_target3;\n",
  "upstream/text.sql": "--\n-- TEXT\n--\n\nSELECT text 'this is a text string' = text 'this is a text string' AS true;\n\nSELECT text 'this is a text string' = text 'this is a text strin' AS false;\n\nCREATE TABLE TEXT_TBL (f1 text);\n\nINSERT INTO TEXT_TBL VALUES ('doh!');\nINSERT INTO TEXT_TBL VALUES ('hi de ho neighbor');\n\nSELECT '' AS two, * FROM TEXT_TBL;\n\n-- As of 8.3 we have removed most implicit casts to text, so that for example\n-- this no longer works:\n\nselect length(42);\n\n-- But as a special exception for usability's sake, we still allow implicit\n-- casting to text in concatenations, so long as the other input is text or\n-- an unknown literal.  So these work:\n\nselect 'four: '::text || 2+2;\nselect 'four: ' || 2+2;\n\n-- but not this:\n\nselect 3 || 4.0;\n\n/*\n * various string functions\n */\nselect concat('one');\nselect concat(1,2,3,'hello',true, false, to_date('20100309','YYYYMMDD'));\nselect concat_ws('#','one');\nselect concat_ws('#',1,2,3,'hello',true, false, to_date('20100309','YYYYMMDD'));\nselect concat_ws(',',10,20,null,30);\nselect concat_ws('',10,20,null,30);\nselect concat_ws(NULL,10,20,null,30) is null;\nselect reverse('abcde');\nselect i, left('ahoj', i), right('ahoj', i) from generate_series(-5, 5) t(i) order by i;\nselect quote_literal('');\nselect quote_literal('abc''');\nselect quote_literal(e'\\\\');\n-- check variadic labeled argument\nselect concat(variadic array[1,2,3]);\nselect concat_ws(',', variadic array[1,2,3]);\nselect concat_ws(',', variadic NULL::int[]);\nselect concat(variadic NULL::int[]) is NULL;\nselect concat(variadic '{}'::int[]) = '';\n--should fail\nselect concat_ws(',', variadic 10);\n\n/*\n * format\n */\nselect format(NULL);\nselect format('Hello');\nselect format('Hello %s', 'World');\nselect format('Hello %%');\nselect format('Hello %%%%');\n-- should fail\nselect format('Hello %s %s', 'World');\nselect format('Hello %s');\nselect format('Hello %x', 20);\n-- check literal and sql identifiers\nselect format('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, 'Hello');\nselect format('%s%s%s','Hello', NULL,'World');\nselect format('INSERT INTO %I VALUES(%L,%L)', 'mytab', 10, NULL);\nselect format('INSERT INTO %I VALUES(%L,%L)', 'mytab', NULL, 'Hello');\n-- should fail, sql identifier cannot be NULL\nselect format('INSERT INTO %I VALUES(%L,%L)', NULL, 10, 'Hello');\n-- check positional placeholders\nselect format('%1$s %3$s', 1, 2, 3);\nselect format('%1$s %12$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);\n-- should fail\nselect format('%1$s %4$s', 1, 2, 3);\nselect format('%1$s %13$s', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);\nselect format('%0$s', 'Hello');\nselect format('%*0$s', 'Hello');\nselect format('%1$', 1);\nselect format('%1$1', 1);\n-- check mix of positional and ordered placeholders\nselect format('Hello %s %1$s %s', 'World', 'Hello again');\nselect format('Hello %s %s, %2$s %2$s', 'World', 'Hello again');\n-- check variadic labeled arguments\nselect format('%s, %s', variadic array['Hello','World']);\nselect format('%s, %s', variadic array[1, 2]);\nselect format('%s, %s', variadic array[true, false]);\nselect format('%s, %s', variadic array[true, false]::text[]);\n-- check variadic with positional placeholders\nselect format('%2$s, %1$s', variadic array['first', 'second']);\nselect format('%2$s, %1$s', variadic array[1, 2]);\n-- variadic argument can be array type NULL, but should not be referenced\nselect format('Hello', variadic NULL::int[]);\n-- variadic argument allows simulating more than FUNC_MAX_ARGS parameters\nselect format(string_agg('%s',','), variadic array_agg(i))\nfrom generate_series(1,200) g(i);\n-- check field widths and left, right alignment\nselect format('>>%10s<<', 'Hello');\nselect format('>>%10s<<', NULL);\nselect format('>>%10s<<', '');\nselect format('>>%-10s<<', '');\nselect format('>>%-10s<<', 'Hello');\nselect format('>>%-10s<<', NULL);\nselect format('>>%1$10s<<', 'Hello');\nselect format('>>%1$-10I<<', 'Hello');\nselect format('>>%2$*1$L<<', 10, 'Hello');\nselect format('>>%2$*1$L<<', 10, NULL);\nselect format('>>%2$*1$L<<', -10, NULL);\nselect format('>>%*s<<', 10, 'Hello');\nselect format('>>%*1$s<<', 10, 'Hello');\nselect format('>>%-s<<', 'Hello');\nselect format('>>%10L<<', NULL);\nselect format('>>%2$*1$L<<', NULL, 'Hello');\nselect format('>>%2$*1$L<<', 0, 'Hello');\n",
  "upstream/time.sql": "--\n-- TIME\n--\n\nCREATE TABLE TIME_TBL (f1 time(2));\n\nINSERT INTO TIME_TBL VALUES ('00:00');\nINSERT INTO TIME_TBL VALUES ('01:00');\n-- as of 7.4, timezone spec should be accepted and ignored\nINSERT INTO TIME_TBL VALUES ('02:03 PST');\nINSERT INTO TIME_TBL VALUES ('11:59 EDT');\nINSERT INTO TIME_TBL VALUES ('12:00');\nINSERT INTO TIME_TBL VALUES ('12:01');\nINSERT INTO TIME_TBL VALUES ('23:59');\nINSERT INTO TIME_TBL VALUES ('11:59:59.99 PM');\n\nINSERT INTO TIME_TBL VALUES ('2003-03-07 15:36:39 America/New_York');\nINSERT INTO TIME_TBL VALUES ('2003-07-07 15:36:39 America/New_York');\n-- this should fail (the timezone offset is not known)\nINSERT INTO TIME_TBL VALUES ('15:36:39 America/New_York');\n\n\nSELECT f1 AS \"Time\" FROM TIME_TBL;\n\nSELECT f1 AS \"Three\" FROM TIME_TBL WHERE f1 < '05:06:07';\n\nSELECT f1 AS \"Five\" FROM TIME_TBL WHERE f1 > '05:06:07';\n\nSELECT f1 AS \"None\" FROM TIME_TBL WHERE f1 < '00:00';\n\nSELECT f1 AS \"Eight\" FROM TIME_TBL WHERE f1 >= '00:00';\n\n--\n-- TIME simple math\n--\n-- We now make a distinction between time and intervals,\n-- and adding two times together makes no sense at all.\n-- Leave in one query to show that it is rejected,\n-- and do the rest of the testing in horology.sql\n-- where we do mixed-type arithmetic. - thomas 2000-12-02\n\nSELECT f1 + time '00:01' AS \"Illegal\" FROM TIME_TBL;\n",
  "upstream/timetz.sql": "--\n-- TIMETZ\n--\n\nCREATE TABLE TIMETZ_TBL (f1 time(2) with time zone);\n\nINSERT INTO TIMETZ_TBL VALUES ('00:01 PDT');\nINSERT INTO TIMETZ_TBL VALUES ('01:00 PDT');\nINSERT INTO TIMETZ_TBL VALUES ('02:03 PDT');\nINSERT INTO TIMETZ_TBL VALUES ('07:07 PST');\nINSERT INTO TIMETZ_TBL VALUES ('08:08 EDT');\nINSERT INTO TIMETZ_TBL VALUES ('11:59 PDT');\nINSERT INTO TIMETZ_TBL VALUES ('12:00 PDT');\nINSERT INTO TIMETZ_TBL VALUES ('12:01 PDT');\nINSERT INTO TIMETZ_TBL VALUES ('23:59 PDT');\nINSERT INTO TIMETZ_TBL VALUES ('11:59:59.99 PM PDT');\n\nINSERT INTO TIMETZ_TBL VALUES ('2003-03-07 15:36:39 America/New_York');\nINSERT INTO TIMETZ_TBL VALUES ('2003-07-07 15:36:39 America/New_York');\n-- this should fail (the timezone offset is not known)\nINSERT INTO TIMETZ_TBL VALUES ('15:36:39 America/New_York');\n\nSELECT f1 AS \"Time TZ\" FROM TIMETZ_TBL;\n\nSELECT f1 AS \"Three\" FROM TIMETZ_TBL WHERE f1 < '05:06:07-07';\n\nSELECT f1 AS \"Seven\" FROM TIMETZ_TBL WHERE f1 > '05:06:07-07';\n\nSELECT f1 AS \"None\" FROM TIMETZ_TBL WHERE f1 < '00:00-07';\n\nSELECT f1 AS \"Ten\" FROM TIMETZ_TBL WHERE f1 >= '00:00-07';\n\n--\n-- TIME simple math\n--\n-- We now make a distinction between time and intervals,\n-- and adding two times together makes no sense at all.\n-- Leave in one query to show that it is rejected,\n-- and do the rest of the testing in horology.sql\n-- where we do mixed-type arithmetic. - thomas 2000-12-02\n\nSELECT f1 + time with time zone '00:01' AS \"Illegal\" FROM TIMETZ_TBL;\n",
  "upstream/tinterval.sql": "--\n-- TINTERVAL\n--\n\nCREATE TABLE TINTERVAL_TBL (f1  tinterval);\n\n-- Should accept any abstime,\n-- so do not bother with extensive testing of values\n\nINSERT INTO TINTERVAL_TBL (f1)\n   VALUES ('[\"-infinity\" \"infinity\"]');\n\nINSERT INTO TINTERVAL_TBL (f1)\n   VALUES ('[\"May 10, 1947 23:59:12\" \"Jan 14, 1973 03:14:21\"]');\n\nINSERT INTO TINTERVAL_TBL (f1)\n   VALUES ('[\"Sep 4, 1983 23:59:12\" \"Oct 4, 1983 23:59:12\"]');\n\nINSERT INTO TINTERVAL_TBL (f1)\n   VALUES ('[\"epoch\" \"Mon May  1 00:30:30 1995\"]');\n\nINSERT INTO TINTERVAL_TBL (f1)\n   VALUES ('[\"Feb 15 1990 12:15:03\" \"2001-09-23 11:12:13\"]');\n\n\n-- badly formatted tintervals\nINSERT INTO TINTERVAL_TBL (f1)\n   VALUES ('[\"bad time specifications\" \"\"]');\n\nINSERT INTO TINTERVAL_TBL (f1)\n   VALUES ('[\"\" \"infinity\"]');\n\n-- test tinterval operators\n\nSELECT '' AS five, * FROM TINTERVAL_TBL;\n\n-- length ==\nSELECT '' AS one, t.*\n   FROM TINTERVAL_TBL t\n   WHERE t.f1 #= '@ 1 months';\n\n-- length <>\nSELECT '' AS three, t.*\n   FROM TINTERVAL_TBL t\n   WHERE t.f1 #<> '@ 1 months';\n\n-- length <\nSELECT '' AS zero, t.*\n   FROM TINTERVAL_TBL t\n   WHERE t.f1 #< '@ 1 month';\n\n-- length <=\nSELECT '' AS one, t.*\n   FROM TINTERVAL_TBL t\n   WHERE t.f1 #<= '@ 1 month';\n\n-- length >\nSELECT '' AS three, t.*\n   FROM TINTERVAL_TBL t\n   WHERE t.f1 #> '@ 1 year';\n\n-- length >=\nSELECT '' AS three, t.*\n   FROM TINTERVAL_TBL t\n   WHERE t.f1 #>= '@ 3 years';\n\n-- overlaps\nSELECT '' AS three, t1.*\n   FROM TINTERVAL_TBL t1\n   WHERE t1.f1 &&\n        tinterval '[\"Aug 15 14:23:19 1983\" \"Sep 16 14:23:19 1983\"]';\n\nSELECT '' AS five, t1.f1, t2.f1\n   FROM TINTERVAL_TBL t1, TINTERVAL_TBL t2\n   WHERE t1.f1 && t2.f1 and\n         t1.f1 = t2.f1\n   ORDER BY t1.f1, t2.f1;\n\nSELECT '' AS fourteen, t1.f1 AS interval1, t2.f1 AS interval2\n   FROM TINTERVAL_TBL t1, TINTERVAL_TBL t2\n   WHERE t1.f1 && t2.f1 and not t1.f1 = t2.f1\n   ORDER BY interval1, interval2;\n\n-- contains\nSELECT '' AS five, t1.f1\n   FROM TINTERVAL_TBL t1\n   WHERE not t1.f1 <<\n        tinterval '[\"Aug 15 14:23:19 1980\" \"Sep 16 14:23:19 1990\"]'\n   ORDER BY t1.f1;\n\n-- make time interval\nSELECT '' AS three, t1.f1\n   FROM TINTERVAL_TBL t1\n   WHERE t1.f1 &&\n        (abstime 'Aug 15 14:23:19 1983' <#>\n         abstime 'Sep 16 14:23:19 1983')\n   ORDER BY t1.f1;\n",
  "upstream/truncate.sql": "-- Test basic TRUNCATE functionality.\nCREATE TABLE truncate_a (col1 integer primary key);\nINSERT INTO truncate_a VALUES (1);\nINSERT INTO truncate_a VALUES (2);\nSELECT * FROM truncate_a;\n-- Roll truncate back\nBEGIN;\nTRUNCATE truncate_a;\nROLLBACK;\nSELECT * FROM truncate_a;\n-- Commit the truncate this time\nBEGIN;\nTRUNCATE truncate_a;\nCOMMIT;\nSELECT * FROM truncate_a;\n\n-- Test foreign-key checks\nCREATE TABLE trunc_b (a int REFERENCES truncate_a);\nCREATE TABLE trunc_c (a serial PRIMARY KEY);\nCREATE TABLE trunc_d (a int REFERENCES trunc_c);\nCREATE TABLE trunc_e (a int REFERENCES truncate_a, b int REFERENCES trunc_c);\n\nTRUNCATE TABLE truncate_a;\t\t-- fail\nTRUNCATE TABLE truncate_a,trunc_b;\t\t-- fail\nTRUNCATE TABLE truncate_a,trunc_b,trunc_e;\t-- ok\nTRUNCATE TABLE truncate_a,trunc_e;\t\t-- fail\nTRUNCATE TABLE trunc_c;\t\t-- fail\nTRUNCATE TABLE trunc_c,trunc_d;\t\t-- fail\nTRUNCATE TABLE trunc_c,trunc_d,trunc_e;\t-- ok\nTRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a;\t-- fail\nTRUNCATE TABLE trunc_c,trunc_d,trunc_e,truncate_a,trunc_b;\t-- ok\n\nTRUNCATE TABLE truncate_a RESTRICT; -- fail\nTRUNCATE TABLE truncate_a CASCADE;  -- ok\n\n-- circular references\nALTER TABLE truncate_a ADD FOREIGN KEY (col1) REFERENCES trunc_c;\n\n-- Add some data to verify that truncating actually works ...\nINSERT INTO trunc_c VALUES (1);\nINSERT INTO truncate_a VALUES (1);\nINSERT INTO trunc_b VALUES (1);\nINSERT INTO trunc_d VALUES (1);\nINSERT INTO trunc_e VALUES (1,1);\nTRUNCATE TABLE trunc_c;\nTRUNCATE TABLE trunc_c,truncate_a;\nTRUNCATE TABLE trunc_c,truncate_a,trunc_d;\nTRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e;\nTRUNCATE TABLE trunc_c,truncate_a,trunc_d,trunc_e,trunc_b;\n\n-- Verify that truncating did actually work\nSELECT * FROM truncate_a\n   UNION ALL\n SELECT * FROM trunc_c\n   UNION ALL\n SELECT * FROM trunc_b\n   UNION ALL\n SELECT * FROM trunc_d;\nSELECT * FROM trunc_e;\n\n-- Add data again to test TRUNCATE ... CASCADE\nINSERT INTO trunc_c VALUES (1);\nINSERT INTO truncate_a VALUES (1);\nINSERT INTO trunc_b VALUES (1);\nINSERT INTO trunc_d VALUES (1);\nINSERT INTO trunc_e VALUES (1,1);\n\nTRUNCATE TABLE trunc_c CASCADE;  -- ok\n\nSELECT * FROM truncate_a\n   UNION ALL\n SELECT * FROM trunc_c\n   UNION ALL\n SELECT * FROM trunc_b\n   UNION ALL\n SELECT * FROM trunc_d;\nSELECT * FROM trunc_e;\n\nDROP TABLE truncate_a,trunc_c,trunc_b,trunc_d,trunc_e CASCADE;\n\n-- Test TRUNCATE with inheritance\n\nCREATE TABLE trunc_f (col1 integer primary key);\nINSERT INTO trunc_f VALUES (1);\nINSERT INTO trunc_f VALUES (2);\n\nCREATE TABLE trunc_fa (col2a text) INHERITS (trunc_f);\nINSERT INTO trunc_fa VALUES (3, 'three');\n\nCREATE TABLE trunc_fb (col2b int) INHERITS (trunc_f);\nINSERT INTO trunc_fb VALUES (4, 444);\n\nCREATE TABLE trunc_faa (col3 text) INHERITS (trunc_fa);\nINSERT INTO trunc_faa VALUES (5, 'five', 'FIVE');\n\nBEGIN;\nSELECT * FROM trunc_f;\nTRUNCATE trunc_f;\nSELECT * FROM trunc_f;\nROLLBACK;\n\nBEGIN;\nSELECT * FROM trunc_f;\nTRUNCATE ONLY trunc_f;\nSELECT * FROM trunc_f;\nROLLBACK;\n\nBEGIN;\nSELECT * FROM trunc_f;\nSELECT * FROM trunc_fa;\nSELECT * FROM trunc_faa;\nTRUNCATE ONLY trunc_fb, ONLY trunc_fa;\nSELECT * FROM trunc_f;\nSELECT * FROM trunc_fa;\nSELECT * FROM trunc_faa;\nROLLBACK;\n\nBEGIN;\nSELECT * FROM trunc_f;\nSELECT * FROM trunc_fa;\nSELECT * FROM trunc_faa;\nTRUNCATE ONLY trunc_fb, trunc_fa;\nSELECT * FROM trunc_f;\nSELECT * FROM trunc_fa;\nSELECT * FROM trunc_faa;\nROLLBACK;\n\nDROP TABLE trunc_f CASCADE;\n\n-- Test ON TRUNCATE triggers\n\nCREATE TABLE trunc_trigger_test (f1 int, f2 text, f3 text);\nCREATE TABLE trunc_trigger_log (tgop text, tglevel text, tgwhen text,\n        tgargv text, tgtable name, rowcount bigint);\n\nCREATE FUNCTION trunctrigger() RETURNS trigger as $$\ndeclare c bigint;\nbegin\n    execute 'select count(*) from ' || quote_ident(tg_table_name) into c;\n    insert into trunc_trigger_log values\n      (TG_OP, TG_LEVEL, TG_WHEN, TG_ARGV[0], tg_table_name, c);\n    return null;\nend;\n$$ LANGUAGE plpgsql;\n\n-- basic before trigger\nINSERT INTO trunc_trigger_test VALUES(1, 'foo', 'bar'), (2, 'baz', 'quux');\n\nCREATE TRIGGER t\nBEFORE TRUNCATE ON trunc_trigger_test\nFOR EACH STATEMENT\nEXECUTE PROCEDURE trunctrigger('before trigger truncate');\n\nSELECT count(*) as \"Row count in test table\" FROM trunc_trigger_test;\nSELECT * FROM trunc_trigger_log;\nTRUNCATE trunc_trigger_test;\nSELECT count(*) as \"Row count in test table\" FROM trunc_trigger_test;\nSELECT * FROM trunc_trigger_log;\n\nDROP TRIGGER t ON trunc_trigger_test;\n\ntruncate trunc_trigger_log;\n\n-- same test with an after trigger\nINSERT INTO trunc_trigger_test VALUES(1, 'foo', 'bar'), (2, 'baz', 'quux');\n\nCREATE TRIGGER tt\nAFTER TRUNCATE ON trunc_trigger_test\nFOR EACH STATEMENT\nEXECUTE PROCEDURE trunctrigger('after trigger truncate');\n\nSELECT count(*) as \"Row count in test table\" FROM trunc_trigger_test;\nSELECT * FROM trunc_trigger_log;\nTRUNCATE trunc_trigger_test;\nSELECT count(*) as \"Row count in test table\" FROM trunc_trigger_test;\nSELECT * FROM trunc_trigger_log;\n\nDROP TABLE trunc_trigger_test;\nDROP TABLE trunc_trigger_log;\n\nDROP FUNCTION trunctrigger();\n\n-- test TRUNCATE ... RESTART IDENTITY\nCREATE SEQUENCE truncate_a_id1 START WITH 33;\nCREATE TABLE truncate_a (id serial,\n                         id1 integer default nextval('truncate_a_id1'));\nALTER SEQUENCE truncate_a_id1 OWNED BY truncate_a.id1;\n\nINSERT INTO truncate_a DEFAULT VALUES;\nINSERT INTO truncate_a DEFAULT VALUES;\nSELECT * FROM truncate_a;\n\nTRUNCATE truncate_a;\n\nINSERT INTO truncate_a DEFAULT VALUES;\nINSERT INTO truncate_a DEFAULT VALUES;\nSELECT * FROM truncate_a;\n\nTRUNCATE truncate_a RESTART IDENTITY;\n\nINSERT INTO truncate_a DEFAULT VALUES;\nINSERT INTO truncate_a DEFAULT VALUES;\nSELECT * FROM truncate_a;\n\n-- check rollback of a RESTART IDENTITY operation\nBEGIN;\nTRUNCATE truncate_a RESTART IDENTITY;\nINSERT INTO truncate_a DEFAULT VALUES;\nSELECT * FROM truncate_a;\nROLLBACK;\nINSERT INTO truncate_a DEFAULT VALUES;\nINSERT INTO truncate_a DEFAULT VALUES;\nSELECT * FROM truncate_a;\n\nDROP TABLE truncate_a;\n\nSELECT nextval('truncate_a_id1'); -- fail, seq should have been dropped\n",
  "upstream/tstypes.sql": "--Base tsvector test\n\nSELECT '1'::tsvector;\nSELECT '1 '::tsvector;\nSELECT ' 1'::tsvector;\nSELECT ' 1 '::tsvector;\nSELECT '1 2'::tsvector;\nSELECT '''1 2'''::tsvector;\nSELECT E'''1 \\\\''2'''::tsvector;\nSELECT E'''1 \\\\''2''3'::tsvector;\nSELECT E'''1 \\\\''2'' 3'::tsvector;\nSELECT E'''1 \\\\''2'' '' 3'' 4 '::tsvector;\nSELECT $$'\\\\as' ab\\c ab\\\\c AB\\\\\\c ab\\\\\\\\c$$::tsvector;\nSELECT tsvectorin(tsvectorout($$'\\\\as' ab\\c ab\\\\c AB\\\\\\c ab\\\\\\\\c$$::tsvector));\nSELECT '''w'':4A,3B,2C,1D,5 a:8';\nSELECT 'a:3A b:2a'::tsvector || 'ba:1234 a:1B';\n\n--Base tsquery test\nSELECT '1'::tsquery;\nSELECT '1 '::tsquery;\nSELECT ' 1'::tsquery;\nSELECT ' 1 '::tsquery;\nSELECT '''1 2'''::tsquery;\nSELECT E'''1 \\\\''2'''::tsquery;\nSELECT '!1'::tsquery;\nSELECT '1|2'::tsquery;\nSELECT '1|!2'::tsquery;\nSELECT '!1|2'::tsquery;\nSELECT '!1|!2'::tsquery;\nSELECT '!(!1|!2)'::tsquery;\nSELECT '!(!1|2)'::tsquery;\nSELECT '!(1|!2)'::tsquery;\nSELECT '!(1|2)'::tsquery;\nSELECT '1&2'::tsquery;\nSELECT '!1&2'::tsquery;\nSELECT '1&!2'::tsquery;\nSELECT '!1&!2'::tsquery;\nSELECT '(1&2)'::tsquery;\nSELECT '1&(2)'::tsquery;\nSELECT '!(1)&2'::tsquery;\nSELECT '!(1&2)'::tsquery;\nSELECT '1|2&3'::tsquery;\nSELECT '1|(2&3)'::tsquery;\nSELECT '(1|2)&3'::tsquery;\nSELECT '1|2&!3'::tsquery;\nSELECT '1|!2&3'::tsquery;\nSELECT '!1|2&3'::tsquery;\nSELECT '!1|(2&3)'::tsquery;\nSELECT '!(1|2)&3'::tsquery;\nSELECT '(!1|2)&3'::tsquery;\nSELECT '1|(2|(4|(5|6)))'::tsquery;\nSELECT '1|2|4|5|6'::tsquery;\nSELECT '1&(2&(4&(5&6)))'::tsquery;\nSELECT '1&2&4&5&6'::tsquery;\nSELECT '1&(2&(4&(5|6)))'::tsquery;\nSELECT '1&(2&(4&(5|!6)))'::tsquery;\nSELECT E'1&(''2''&('' 4''&(\\\\|5 | ''6 \\\\'' !|&'')))'::tsquery;\nSELECT $$'\\\\as'$$::tsquery;\nSELECT 'a:* & nbb:*ac | doo:a* | goo'::tsquery;\n\n-- phrase transformation\nSELECT 'a <-> (b|c)'::tsquery;\nSELECT '(a|b) <-> c'::tsquery;\nSELECT '(a|b) <-> (d|c)'::tsquery;\n\nSELECT 'a <-> (b&c)'::tsquery;\nSELECT '(a&b) <-> c'::tsquery;\nSELECT '(a&b) <-> (d&c)'::tsquery;\n\nSELECT 'a <-> !b'::tsquery;\nSELECT '!a <-> b'::tsquery;\nSELECT '!a <-> !b'::tsquery;\n\nSELECT 'a <-> !(b&c)'::tsquery;\nSELECT 'a <-> !(b|c)'::tsquery;\nSELECT  '!(a&b) <-> c'::tsquery;\nSELECT  '!(a|b) <-> c'::tsquery;\n\nSELECT  '(!a|b) <-> c'::tsquery;\nSELECT  '(!a&b) <-> c'::tsquery;\nSELECT  'c <-> (!a|b)'::tsquery;\nSELECT  'c <-> (!a&b)'::tsquery;\n\nSELECT  '(a|b) <-> !c'::tsquery;\nSELECT  '(a&b) <-> !c'::tsquery;\nSELECT  '!c <-> (a|b)'::tsquery;\nSELECT  '!c <-> (a&b)'::tsquery;\n\n--comparisons\nSELECT 'a' < 'b & c'::tsquery as \"true\";\nSELECT 'a' > 'b & c'::tsquery as \"false\";\nSELECT 'a | f' < 'b & c'::tsquery as \"false\";\nSELECT 'a | ff' < 'b & c'::tsquery as \"false\";\nSELECT 'a | f | g' < 'b & c'::tsquery as \"false\";\n\n--concatenation\nSELECT numnode( 'new'::tsquery );\nSELECT numnode( 'new & york'::tsquery );\nSELECT numnode( 'new & york | qwery'::tsquery );\n\nSELECT 'foo & bar'::tsquery && 'asd';\nSELECT 'foo & bar'::tsquery || 'asd & fg';\nSELECT 'foo & bar'::tsquery || !!'asd & fg'::tsquery;\nSELECT 'foo & bar'::tsquery && 'asd | fg';\nSELECT 'a' <-> 'b & d'::tsquery;\nSELECT 'a & g' <-> 'b & d'::tsquery;\nSELECT 'a & g' <-> 'b | d'::tsquery;\nSELECT 'a & g' <-> 'b <-> d'::tsquery;\nSELECT tsquery_phrase('a <3> g', 'b & d', 10);\n\n-- tsvector-tsquery operations\n\nSELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca' as \"true\";\nSELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:B' as \"true\";\nSELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:A' as \"true\";\nSELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:C' as \"false\";\nSELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & ca:CB' as \"true\";\nSELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*C' as \"false\";\nSELECT 'a b:89  ca:23A,64b d:34c'::tsvector @@ 'd:AC & c:*CB' as \"true\";\nSELECT 'a b:89  ca:23A,64b cb:80c d:34c'::tsvector @@ 'd:AC & c:*C' as \"true\";\nSELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*C' as \"true\";\nSELECT 'a b:89  ca:23A,64c cb:80b d:34c'::tsvector @@ 'd:AC & c:*B' as \"true\";\n\nSELECT 'supernova'::tsvector @@ 'super'::tsquery AS \"false\";\nSELECT 'supeanova supernova'::tsvector @@ 'super'::tsquery AS \"false\";\nSELECT 'supeznova supernova'::tsvector @@ 'super'::tsquery AS \"false\";\nSELECT 'supernova'::tsvector @@ 'super:*'::tsquery AS \"true\";\nSELECT 'supeanova supernova'::tsvector @@ 'super:*'::tsquery AS \"true\";\nSELECT 'supeznova supernova'::tsvector @@ 'super:*'::tsquery AS \"true\";\n\n--phrase search\nSELECT to_tsvector('simple', '1 2 3 1') @@ '1 <-> 2' AS \"true\";\nSELECT to_tsvector('simple', '1 2 3 1') @@ '1 <2> 2' AS \"true\";\nSELECT to_tsvector('simple', '1 2 3 1') @@ '1 <-> 3' AS \"false\";\nSELECT to_tsvector('simple', '1 2 3 1') @@ '1 <2> 3' AS \"true\";\n\nSELECT to_tsvector('simple', '1 2 11 3') @@ '1 <-> 3' AS \"false\";\nSELECT to_tsvector('simple', '1 2 11 3') @@ '1:* <-> 3' AS \"true\";\n\nSELECT to_tsvector('simple', '1 2 3 4') @@ '1 <-> 2 <-> 3' AS \"true\";\nSELECT to_tsvector('simple', '1 2 3 4') @@ '(1 <-> 2) <-> 3' AS \"true\";\nSELECT to_tsvector('simple', '1 2 3 4') @@ '1 <-> (2 <-> 3)' AS \"false\";\nSELECT to_tsvector('simple', '1 2 3 4') @@ '1 <2> (2 <-> 3)' AS \"true\";\nSELECT to_tsvector('simple', '1 2 1 2 3 4') @@ '(1 <-> 2) <-> 3' AS \"true\";\nSELECT to_tsvector('simple', '1 2 1 2 3 4') @@ '1 <-> 2 <-> 3' AS \"true\";\n\n--ranking\nSELECT ts_rank(' a:1 s:2C d g'::tsvector, 'a | s');\nSELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | s');\nSELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | s:*');\nSELECT ts_rank(' a:1 sa:2C d g'::tsvector, 'a | sa:*');\nSELECT ts_rank(' a:1 s:2B d g'::tsvector, 'a | s');\nSELECT ts_rank(' a:1 s:2 d g'::tsvector, 'a | s');\nSELECT ts_rank(' a:1 s:2C d g'::tsvector, 'a & s');\nSELECT ts_rank(' a:1 s:2B d g'::tsvector, 'a & s');\nSELECT ts_rank(' a:1 s:2 d g'::tsvector, 'a & s');\n\nSELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a | s');\nSELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | s');\nSELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | s:*');\nSELECT ts_rank_cd(' a:1 sa:2C d g'::tsvector, 'a | sa:*');\nSELECT ts_rank_cd(' a:1 sa:3C sab:2c d g'::tsvector, 'a | sa:*');\nSELECT ts_rank_cd(' a:1 s:2B d g'::tsvector, 'a | s');\nSELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a | s');\nSELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a & s');\nSELECT ts_rank_cd(' a:1 s:2B d g'::tsvector, 'a & s');\nSELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a & s');\n\nSELECT ts_rank_cd(' a:1 s:2A d g'::tsvector, 'a <-> s');\nSELECT ts_rank_cd(' a:1 s:2C d g'::tsvector, 'a <-> s');\nSELECT ts_rank_cd(' a:1 s:2 d g'::tsvector, 'a <-> s');\nSELECT ts_rank_cd(' a:1 s:2 d:2A g'::tsvector, 'a <-> s');\nSELECT ts_rank_cd(' a:1 s:2,3A d:2A g'::tsvector, 'a <2> s:A');\nSELECT ts_rank_cd(' a:1 b:2 s:3A d:2A g'::tsvector, 'a <2> s:A');\nSELECT ts_rank_cd(' a:1 sa:2D sb:2A g'::tsvector, 'a <-> s:*');\nSELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:*');\nSELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:* <-> sa:A');\nSELECT ts_rank_cd(' a:1 sa:2A sb:2D g'::tsvector, 'a <-> s:* <-> sa:B');\n\nSELECT 'a:1 b:2'::tsvector @@ 'a <-> b'::tsquery AS \"true\";\nSELECT 'a:1 b:2'::tsvector @@ 'a <0> b'::tsquery AS \"false\";\nSELECT 'a:1 b:2'::tsvector @@ 'a <1> b'::tsquery AS \"true\";\nSELECT 'a:1 b:2'::tsvector @@ 'a <2> b'::tsquery AS \"true\";\nSELECT 'a:1 b:3'::tsvector @@ 'a <-> b'::tsquery AS \"false\";\nSELECT 'a:1 b:3'::tsvector @@ 'a <0> b'::tsquery AS \"false\";\nSELECT 'a:1 b:3'::tsvector @@ 'a <1> b'::tsquery AS \"false\";\nSELECT 'a:1 b:3'::tsvector @@ 'a <2> b'::tsquery AS \"true\";\nSELECT 'a:1 b:3'::tsvector @@ 'a <3> b'::tsquery AS \"true\";\n\n-- tsvector editing operations\n\nSELECT strip('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd'::tsvector);\nSELECT strip('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);\nSELECT strip('base hidden rebel spaceship strike'::tsvector);\n\nSELECT ts_delete(to_tsvector('english', 'Rebel spaceships, striking from a hidden base'), 'spaceship');\nSELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'base');\nSELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'bas');\nSELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'bases');\nSELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, 'spaceship');\nSELECT ts_delete('base hidden rebel spaceship strike'::tsvector, 'spaceship');\n\nSELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceship','rebel']);\nSELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceships','rebel']);\nSELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceshi','rebel']);\nSELECT ts_delete('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector, ARRAY['spaceship','leya','rebel']);\nSELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship','leya','rebel']);\nSELECT ts_delete('base hidden rebel spaceship strike'::tsvector, ARRAY['spaceship','leya','rebel', NULL]);\n\nSELECT unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);\nSELECT unnest('base hidden rebel spaceship strike'::tsvector);\nSELECT * FROM unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);\nSELECT * FROM unnest('base hidden rebel spaceship strike'::tsvector);\nSELECT lexeme, positions[1] from unnest('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);\n\nSELECT tsvector_to_array('base:7 hidden:6 rebel:1 spaceship:2,33A,34B,35C,36D strike:3'::tsvector);\nSELECT tsvector_to_array('base hidden rebel spaceship strike'::tsvector);\n\nSELECT array_to_tsvector(ARRAY['base','hidden','rebel','spaceship','strike']);\nSELECT array_to_tsvector(ARRAY['base','hidden','rebel','spaceship', NULL]);\n\nSELECT setweight('w:12B w:13* w:12,5,6 a:1,3* a:3 w asd:1dc asd zxc:81,567,222A'::tsvector, 'c');\nSELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c');\nSELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a}');\nSELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a}');\nSELECT setweight('a:1,3A asd:1C w:5,6,12B,13A zxc:81,222A,567'::tsvector, 'c', '{a,zxc}');\nSELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', '{a,zxc}');\nSELECT setweight('a asd w:5,6,12B,13A zxc'::tsvector, 'c', ARRAY['a', 'zxc', NULL]);\n\nSELECT ts_filter('base:7A empir:17 evil:15 first:11 galact:16 hidden:6A rebel:1A spaceship:2A strike:3A victori:12 won:9'::tsvector, '{a}');\nSELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a}');\nSELECT ts_filter('base hidden rebel spaceship strike'::tsvector, '{a,b,NULL}');\n",
  "upstream/txid.sql": "-- txid_snapshot data type and related functions\n\n-- i/o\nselect '12:13:'::txid_snapshot;\nselect '12:18:14,16'::txid_snapshot;\nselect '12:16:14,14'::txid_snapshot;\n\n-- errors\nselect '31:12:'::txid_snapshot;\nselect '0:1:'::txid_snapshot;\nselect '12:13:0'::txid_snapshot;\nselect '12:16:14,13'::txid_snapshot;\n\ncreate temp table snapshot_test (\n\tnr\tinteger,\n\tsnap\ttxid_snapshot\n);\n\ninsert into snapshot_test values (1, '12:13:');\ninsert into snapshot_test values (2, '12:20:13,15,18');\ninsert into snapshot_test values (3, '100001:100009:100005,100007,100008');\ninsert into snapshot_test values (4, '100:150:101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131');\nselect snap from snapshot_test order by nr;\n\nselect  txid_snapshot_xmin(snap),\n\ttxid_snapshot_xmax(snap),\n\ttxid_snapshot_xip(snap)\nfrom snapshot_test order by nr;\n\nselect id, txid_visible_in_snapshot(id, snap)\nfrom snapshot_test, generate_series(11, 21) id\nwhere nr = 2;\n\n-- test bsearch\nselect id, txid_visible_in_snapshot(id, snap)\nfrom snapshot_test, generate_series(90, 160) id\nwhere nr = 4;\n\n-- test current values also\nselect txid_current() >= txid_snapshot_xmin(txid_current_snapshot());\n\n-- we can't assume current is always less than xmax, however\n\nselect txid_visible_in_snapshot(txid_current(), txid_current_snapshot());\n\n-- test 64bitness\n\nselect txid_snapshot '1000100010001000:1000100010001100:1000100010001012,1000100010001013';\nselect txid_visible_in_snapshot('1000100010001012', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');\nselect txid_visible_in_snapshot('1000100010001015', '1000100010001000:1000100010001100:1000100010001012,1000100010001013');\n\n-- test 64bit overflow\nSELECT txid_snapshot '1:9223372036854775807:3';\nSELECT txid_snapshot '1:9223372036854775808:3';\n",
  "upstream/varchar.sql": "--\n-- VARCHAR\n--\n\nCREATE TABLE VARCHAR_TBL(f1 varchar(1));\n\nINSERT INTO VARCHAR_TBL (f1) VALUES ('a');\n\nINSERT INTO VARCHAR_TBL (f1) VALUES ('A');\n\n-- any of the following three input formats are acceptable\nINSERT INTO VARCHAR_TBL (f1) VALUES ('1');\n\nINSERT INTO VARCHAR_TBL (f1) VALUES (2);\n\nINSERT INTO VARCHAR_TBL (f1) VALUES ('3');\n\n-- zero-length char\nINSERT INTO VARCHAR_TBL (f1) VALUES ('');\n\n-- try varchar's of greater than 1 length\nINSERT INTO VARCHAR_TBL (f1) VALUES ('cd');\nINSERT INTO VARCHAR_TBL (f1) VALUES ('c     ');\n\n\nSELECT '' AS seven, * FROM VARCHAR_TBL;\n\nSELECT '' AS six, c.*\n   FROM VARCHAR_TBL c\n   WHERE c.f1 <> 'a';\n\nSELECT '' AS one, c.*\n   FROM VARCHAR_TBL c\n   WHERE c.f1 = 'a';\n\nSELECT '' AS five, c.*\n   FROM VARCHAR_TBL c\n   WHERE c.f1 < 'a';\n\nSELECT '' AS six, c.*\n   FROM VARCHAR_TBL c\n   WHERE c.f1 <= 'a';\n\nSELECT '' AS one, c.*\n   FROM VARCHAR_TBL c\n   WHERE c.f1 > 'a';\n\nSELECT '' AS two, c.*\n   FROM VARCHAR_TBL c\n   WHERE c.f1 >= 'a';\n\nDROP TABLE VARCHAR_TBL;\n\n--\n-- Now test longer arrays of char\n--\n\nCREATE TABLE VARCHAR_TBL(f1 varchar(4));\n\nINSERT INTO VARCHAR_TBL (f1) VALUES ('a');\nINSERT INTO VARCHAR_TBL (f1) VALUES ('ab');\nINSERT INTO VARCHAR_TBL (f1) VALUES ('abcd');\nINSERT INTO VARCHAR_TBL (f1) VALUES ('abcde');\nINSERT INTO VARCHAR_TBL (f1) VALUES ('abcd    ');\n\nSELECT '' AS four, * FROM VARCHAR_TBL;\n",
  "upstream/with.sql": "--\n-- Tests for common table expressions (WITH query, ... SELECT ...)\n--\n\n-- Basic WITH\nWITH q1(x,y) AS (SELECT 1,2)\nSELECT * FROM q1, q1 AS q2;\n\n-- Multiple uses are evaluated only once\nSELECT count(*) FROM (\n  WITH q1(x) AS (SELECT random() FROM generate_series(1, 5))\n    SELECT * FROM q1\n  UNION\n    SELECT * FROM q1\n) ss;\n\n-- WITH RECURSIVE\n\n-- sum of 1..100\nWITH RECURSIVE t(n) AS (\n    VALUES (1)\nUNION ALL\n    SELECT n+1 FROM t WHERE n < 100\n)\nSELECT sum(n) FROM t;\n\nWITH RECURSIVE t(n) AS (\n    SELECT (VALUES(1))\nUNION ALL\n    SELECT n+1 FROM t WHERE n < 5\n)\nSELECT * FROM t;\n\n-- recursive view\nCREATE RECURSIVE VIEW nums (n) AS\n    VALUES (1)\nUNION ALL\n    SELECT n+1 FROM nums WHERE n < 5;\n\nSELECT * FROM nums;\n\nCREATE OR REPLACE RECURSIVE VIEW nums (n) AS\n    VALUES (1)\nUNION ALL\n    SELECT n+1 FROM nums WHERE n < 6;\n\nSELECT * FROM nums;\n\n-- This is an infinite loop with UNION ALL, but not with UNION\nWITH RECURSIVE t(n) AS (\n    SELECT 1\nUNION\n    SELECT 10-n FROM t)\nSELECT * FROM t;\n\n-- This'd be an infinite loop, but outside query reads only as much as needed\nWITH RECURSIVE t(n) AS (\n    VALUES (1)\nUNION ALL\n    SELECT n+1 FROM t)\nSELECT * FROM t LIMIT 10;\n\n-- UNION case should have same property\nWITH RECURSIVE t(n) AS (\n    SELECT 1\nUNION\n    SELECT n+1 FROM t)\nSELECT * FROM t LIMIT 10;\n\n-- Test behavior with an unknown-type literal in the WITH\nWITH q AS (SELECT 'foo' AS x)\nSELECT x, x IS OF (unknown) as is_unknown FROM q;\n\nWITH RECURSIVE t(n) AS (\n    SELECT 'foo'\nUNION ALL\n    SELECT n || ' bar' FROM t WHERE length(n) < 20\n)\nSELECT n, n IS OF (text) as is_text FROM t;\n\n--\n-- Some examples with a tree\n--\n-- department structure represented here is as follows:\n--\n-- ROOT-+->A-+->B-+->C\n--      |         |\n--      |         +->D-+->F\n--      +->E-+->G\n\nCREATE TEMP TABLE department (\n\tid INTEGER PRIMARY KEY,  -- department ID\n\tparent_department INTEGER REFERENCES department, -- upper department ID\n\tname TEXT -- department name\n);\n\nINSERT INTO department VALUES (0, NULL, 'ROOT');\nINSERT INTO department VALUES (1, 0, 'A');\nINSERT INTO department VALUES (2, 1, 'B');\nINSERT INTO department VALUES (3, 2, 'C');\nINSERT INTO department VALUES (4, 2, 'D');\nINSERT INTO department VALUES (5, 0, 'E');\nINSERT INTO department VALUES (6, 4, 'F');\nINSERT INTO department VALUES (7, 5, 'G');\n\n\n-- extract all departments under 'A'. Result should be A, B, C, D and F\nWITH RECURSIVE subdepartment AS\n(\n\t-- non recursive term\n\tSELECT name as root_name, * FROM department WHERE name = 'A'\n\n\tUNION ALL\n\n\t-- recursive term\n\tSELECT sd.root_name, d.* FROM department AS d, subdepartment AS sd\n\t\tWHERE d.parent_department = sd.id\n)\nSELECT * FROM subdepartment ORDER BY name;\n\n-- extract all departments under 'A' with \"level\" number\nWITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n(\n\t-- non recursive term\n\tSELECT 1, * FROM department WHERE name = 'A'\n\n\tUNION ALL\n\n\t-- recursive term\n\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n\t\tWHERE d.parent_department = sd.id\n)\nSELECT * FROM subdepartment ORDER BY name;\n\n-- extract all departments under 'A' with \"level\" number.\n-- Only shows level 2 or more\nWITH RECURSIVE subdepartment(level, id, parent_department, name) AS\n(\n\t-- non recursive term\n\tSELECT 1, * FROM department WHERE name = 'A'\n\n\tUNION ALL\n\n\t-- recursive term\n\tSELECT sd.level + 1, d.* FROM department AS d, subdepartment AS sd\n\t\tWHERE d.parent_department = sd.id\n)\nSELECT * FROM subdepartment WHERE level >= 2 ORDER BY name;\n\n-- \"RECURSIVE\" is ignored if the query has no self-reference\nWITH RECURSIVE subdepartment AS\n(\n\t-- note lack of recursive UNION structure\n\tSELECT * FROM department WHERE name = 'A'\n)\nSELECT * FROM subdepartment ORDER BY name;\n\n-- inside subqueries\nSELECT count(*) FROM (\n    WITH RECURSIVE t(n) AS (\n        SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 500\n    )\n    SELECT * FROM t) AS t WHERE n < (\n        SELECT count(*) FROM (\n            WITH RECURSIVE t(n) AS (\n                   SELECT 1 UNION ALL SELECT n + 1 FROM t WHERE n < 100\n                )\n            SELECT * FROM t WHERE n < 50000\n         ) AS t WHERE n < 100);\n\n-- use same CTE twice at different subquery levels\nWITH q1(x,y) AS (\n    SELECT hundred, sum(ten) FROM tenk1 GROUP BY hundred\n  )\nSELECT count(*) FROM q1 WHERE y > (SELECT sum(y)/100 FROM q1 qsub);\n\n-- via a VIEW\nCREATE TEMPORARY VIEW vsubdepartment AS\n\tWITH RECURSIVE subdepartment AS\n\t(\n\t\t -- non recursive term\n\t\tSELECT * FROM department WHERE name = 'A'\n\t\tUNION ALL\n\t\t-- recursive term\n\t\tSELECT d.* FROM department AS d, subdepartment AS sd\n\t\t\tWHERE d.parent_department = sd.id\n\t)\n\tSELECT * FROM subdepartment;\n\nSELECT * FROM vsubdepartment ORDER BY name;\n\n-- Check reverse listing\nSELECT pg_get_viewdef('vsubdepartment'::regclass);\nSELECT pg_get_viewdef('vsubdepartment'::regclass, true);\n\n-- Another reverse-listing example\nCREATE VIEW sums_1_100 AS\nWITH RECURSIVE t(n) AS (\n    VALUES (1)\nUNION ALL\n    SELECT n+1 FROM t WHERE n < 100\n)\nSELECT sum(n) FROM t;\n\n\n\n\n-- corner case in which sub-WITH gets initialized first\nwith recursive q as (\n      select * from department\n    union all\n      (with x as (select * from q)\n       select * from x)\n    )\nselect * from q limit 24;\n\nwith recursive q as (\n      select * from department\n    union all\n      (with recursive x as (\n           select * from department\n         union all\n           (select * from q union all select * from x)\n        )\n       select * from x)\n    )\nselect * from q limit 32;\n\n-- recursive term has sub-UNION\nWITH RECURSIVE t(i,j) AS (\n\tVALUES (1,2)\n\tUNION ALL\n\tSELECT t2.i, t.j+1 FROM\n\t\t(SELECT 2 AS i UNION ALL SELECT 3 AS i) AS t2\n\t\tJOIN t ON (t2.i = t.i+1))\n\n\tSELECT * FROM t;\n\n--\n-- different tree example\n--\nCREATE TEMPORARY TABLE tree(\n    id INTEGER PRIMARY KEY,\n    parent_id INTEGER REFERENCES tree(id)\n);\n\nINSERT INTO tree\nVALUES (1, NULL), (2, 1), (3,1), (4,2), (5,2), (6,2), (7,3), (8,3),\n       (9,4), (10,4), (11,7), (12,7), (13,7), (14, 9), (15,11), (16,11);\n\n--\n-- get all paths from \"second level\" nodes to leaf nodes\n--\nWITH RECURSIVE t(id, path) AS (\n    VALUES(1,ARRAY[]::integer[])\nUNION ALL\n    SELECT tree.id, t.path || tree.id\n    FROM tree JOIN t ON (tree.parent_id = t.id)\n)\nSELECT t1.*, t2.* FROM t AS t1 JOIN t AS t2 ON\n\t(t1.path[1] = t2.path[1] AND\n\tarray_upper(t1.path,1) = 1 AND\n\tarray_upper(t2.path,1) > 1)\n\tORDER BY t1.id, t2.id;\n\n-- just count 'em\nWITH RECURSIVE t(id, path) AS (\n    VALUES(1,ARRAY[]::integer[])\nUNION ALL\n    SELECT tree.id, t.path || tree.id\n    FROM tree JOIN t ON (tree.parent_id = t.id)\n)\nSELECT t1.id, count(t2.*) FROM t AS t1 JOIN t AS t2 ON\n\t(t1.path[1] = t2.path[1] AND\n\tarray_upper(t1.path,1) = 1 AND\n\tarray_upper(t2.path,1) > 1)\n\tGROUP BY t1.id\n\tORDER BY t1.id;\n\n-- this variant tickled a whole-row-variable bug in 8.4devel\nWITH RECURSIVE t(id, path) AS (\n    VALUES(1,ARRAY[]::integer[])\nUNION ALL\n    SELECT tree.id, t.path || tree.id\n    FROM tree JOIN t ON (tree.parent_id = t.id)\n)\nSELECT t1.id, t2.path, t2 FROM t AS t1 JOIN t AS t2 ON\n(t1.id=t2.id);\n\n--\n-- test cycle detection\n--\ncreate temp table graph( f int, t int, label text );\n\ninsert into graph values\n\t(1, 2, 'arc 1 -> 2'),\n\t(1, 3, 'arc 1 -> 3'),\n\t(2, 3, 'arc 2 -> 3'),\n\t(1, 4, 'arc 1 -> 4'),\n\t(4, 5, 'arc 4 -> 5'),\n\t(5, 1, 'arc 5 -> 1');\n\nwith recursive search_graph(f, t, label, path, cycle) as (\n\tselect *, array[row(g.f, g.t)], false from graph g\n\tunion all\n\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n\tfrom graph g, search_graph sg\n\twhere g.f = sg.t and not cycle\n)\nselect * from search_graph;\n\n-- ordering by the path column has same effect as SEARCH DEPTH FIRST\nwith recursive search_graph(f, t, label, path, cycle) as (\n\tselect *, array[row(g.f, g.t)], false from graph g\n\tunion all\n\tselect g.*, path || row(g.f, g.t), row(g.f, g.t) = any(path)\n\tfrom graph g, search_graph sg\n\twhere g.f = sg.t and not cycle\n)\nselect * from search_graph order by path;\n\n--\n-- test multiple WITH queries\n--\nWITH RECURSIVE\n  y (id) AS (VALUES (1)),\n  x (id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5)\nSELECT * FROM x;\n\n-- forward reference OK\nWITH RECURSIVE\n    x(id) AS (SELECT * FROM y UNION ALL SELECT id+1 FROM x WHERE id < 5),\n    y(id) AS (values (1))\n SELECT * FROM x;\n\nWITH RECURSIVE\n   x(id) AS\n     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n   y(id) AS\n     (VALUES (1) UNION ALL SELECT id+1 FROM y WHERE id < 10)\n SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n\nWITH RECURSIVE\n   x(id) AS\n     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 5),\n   y(id) AS\n     (VALUES (1) UNION ALL SELECT id+1 FROM x WHERE id < 10)\n SELECT y.*, x.* FROM y LEFT JOIN x USING (id);\n\nWITH RECURSIVE\n   x(id) AS\n     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n   y(id) AS\n     (SELECT * FROM x UNION ALL SELECT * FROM x),\n   z(id) AS\n     (SELECT * FROM x UNION ALL SELECT id+1 FROM z WHERE id < 10)\n SELECT * FROM z;\n\nWITH RECURSIVE\n   x(id) AS\n     (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 3 ),\n   y(id) AS\n     (SELECT * FROM x UNION ALL SELECT * FROM x),\n   z(id) AS\n     (SELECT * FROM y UNION ALL SELECT id+1 FROM z WHERE id < 10)\n SELECT * FROM z;\n\n--\n-- Test WITH attached to a data-modifying statement\n--\n\nCREATE TEMPORARY TABLE y (a INTEGER);\nINSERT INTO y SELECT generate_series(1, 10);\n\nWITH t AS (\n\tSELECT a FROM y\n)\nINSERT INTO y\nSELECT a+20 FROM t RETURNING *;\n\nSELECT * FROM y;\n\nWITH t AS (\n\tSELECT a FROM y\n)\nUPDATE y SET a = y.a-10 FROM t WHERE y.a > 20 AND t.a = y.a RETURNING y.a;\n\nSELECT * FROM y;\n\nWITH RECURSIVE t(a) AS (\n\tSELECT 11\n\tUNION ALL\n\tSELECT a+1 FROM t WHERE a < 50\n)\nDELETE FROM y USING t WHERE t.a = y.a RETURNING y.a;\n\nSELECT * FROM y;\n\nDROP TABLE y;\n\n--\n-- error cases\n--\n\n-- INTERSECT\nWITH RECURSIVE x(n) AS (SELECT 1 INTERSECT SELECT n+1 FROM x)\n\tSELECT * FROM x;\n\nWITH RECURSIVE x(n) AS (SELECT 1 INTERSECT ALL SELECT n+1 FROM x)\n\tSELECT * FROM x;\n\n-- EXCEPT\nWITH RECURSIVE x(n) AS (SELECT 1 EXCEPT SELECT n+1 FROM x)\n\tSELECT * FROM x;\n\nWITH RECURSIVE x(n) AS (SELECT 1 EXCEPT ALL SELECT n+1 FROM x)\n\tSELECT * FROM x;\n\n-- no non-recursive term\nWITH RECURSIVE x(n) AS (SELECT n FROM x)\n\tSELECT * FROM x;\n\n-- recursive term in the left hand side (strictly speaking, should allow this)\nWITH RECURSIVE x(n) AS (SELECT n FROM x UNION ALL SELECT 1)\n\tSELECT * FROM x;\n\nCREATE TEMPORARY TABLE y (a INTEGER);\nINSERT INTO y SELECT generate_series(1, 10);\n\n-- LEFT JOIN\n\nWITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1\n\tUNION ALL\n\tSELECT x.n+1 FROM y LEFT JOIN x ON x.n = y.a WHERE n < 10)\nSELECT * FROM x;\n\n-- RIGHT JOIN\nWITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1\n\tUNION ALL\n\tSELECT x.n+1 FROM x RIGHT JOIN y ON x.n = y.a WHERE n < 10)\nSELECT * FROM x;\n\n-- FULL JOIN\nWITH RECURSIVE x(n) AS (SELECT a FROM y WHERE a = 1\n\tUNION ALL\n\tSELECT x.n+1 FROM x FULL JOIN y ON x.n = y.a WHERE n < 10)\nSELECT * FROM x;\n\n-- subquery\nWITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x\n                          WHERE n IN (SELECT * FROM x))\n  SELECT * FROM x;\n\n-- aggregate functions\nWITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT count(*) FROM x)\n  SELECT * FROM x;\n\nWITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT sum(n) FROM x)\n  SELECT * FROM x;\n\n-- ORDER BY\nWITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x ORDER BY 1)\n  SELECT * FROM x;\n\n-- LIMIT/OFFSET\nWITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x LIMIT 10 OFFSET 1)\n  SELECT * FROM x;\n\n-- FOR UPDATE\nWITH RECURSIVE x(n) AS (SELECT 1 UNION ALL SELECT n+1 FROM x FOR UPDATE)\n  SELECT * FROM x;\n\n-- target list has a recursive query name\nWITH RECURSIVE x(id) AS (values (1)\n    UNION ALL\n    SELECT (SELECT * FROM x) FROM x WHERE id < 5\n) SELECT * FROM x;\n\n-- mutual recursive query (not implemented)\nWITH RECURSIVE\n  x (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM y WHERE id < 5),\n  y (id) AS (SELECT 1 UNION ALL SELECT id+1 FROM x WHERE id < 5)\nSELECT * FROM x;\n\n-- non-linear recursion is not allowed\nWITH RECURSIVE foo(i) AS\n    (values (1)\n    UNION ALL\n       (SELECT i+1 FROM foo WHERE i < 10\n          UNION ALL\n       SELECT i+1 FROM foo WHERE i < 5)\n) SELECT * FROM foo;\n\nWITH RECURSIVE foo(i) AS\n    (values (1)\n    UNION ALL\n\t   SELECT * FROM\n       (SELECT i+1 FROM foo WHERE i < 10\n          UNION ALL\n       SELECT i+1 FROM foo WHERE i < 5) AS t\n) SELECT * FROM foo;\n\nWITH RECURSIVE foo(i) AS\n    (values (1)\n    UNION ALL\n       (SELECT i+1 FROM foo WHERE i < 10\n          EXCEPT\n       SELECT i+1 FROM foo WHERE i < 5)\n) SELECT * FROM foo;\n\nWITH RECURSIVE foo(i) AS\n    (values (1)\n    UNION ALL\n       (SELECT i+1 FROM foo WHERE i < 10\n          INTERSECT\n       SELECT i+1 FROM foo WHERE i < 5)\n) SELECT * FROM foo;\n\n-- Wrong type induced from non-recursive term\nWITH RECURSIVE foo(i) AS\n   (SELECT i FROM (VALUES(1),(2)) t(i)\n   UNION ALL\n   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)\nSELECT * FROM foo;\n\n-- rejects different typmod, too (should we allow this?)\nWITH RECURSIVE foo(i) AS\n   (SELECT i::numeric(3,0) FROM (VALUES(1),(2)) t(i)\n   UNION ALL\n   SELECT (i+1)::numeric(10,0) FROM foo WHERE i < 10)\nSELECT * FROM foo;\n\n-- disallow OLD/NEW reference in CTE\nCREATE TEMPORARY TABLE x (n integer);\nCREATE RULE r2 AS ON UPDATE TO x DO INSTEAD\n    WITH t AS (SELECT OLD.*) UPDATE y SET a = t.n FROM t;\n\n--\n-- test for bug #4902\n--\nwith cte(foo) as ( values(42) ) values((select foo from cte));\nwith cte(foo) as ( select 42 ) select * from ((select foo from cte)) q;\n\n-- test CTE referencing an outer-level variable (to see that changed-parameter\n-- signaling still works properly after fixing this bug)\nselect ( with cte(foo) as ( values(f1) )\n         select (select foo from cte) )\nfrom int4_tbl;\n\nselect ( with cte(foo) as ( values(f1) )\n          values((select foo from cte)) )\nfrom int4_tbl;\n\n--\n-- test for nested-recursive-WITH bug\n--\nWITH RECURSIVE t(j) AS (\n    WITH RECURSIVE s(i) AS (\n        VALUES (1)\n        UNION ALL\n        SELECT i+1 FROM s WHERE i < 10\n    )\n    SELECT i FROM s\n    UNION ALL\n    SELECT j+1 FROM t WHERE j < 10\n)\nSELECT * FROM t;\n\n--\n-- test WITH attached to intermediate-level set operation\n--\n\nWITH outermost(x) AS (\n  SELECT 1\n  UNION (WITH innermost as (SELECT 2)\n         SELECT * FROM innermost\n         UNION SELECT 3)\n)\nSELECT * FROM outermost;\n\nWITH outermost(x) AS (\n  SELECT 1\n  UNION (WITH innermost as (SELECT 2)\n         SELECT * FROM outermost  -- fail\n         UNION SELECT * FROM innermost)\n)\nSELECT * FROM outermost;\n\nWITH RECURSIVE outermost(x) AS (\n  SELECT 1\n  UNION (WITH innermost as (SELECT 2)\n         SELECT * FROM outermost\n         UNION SELECT * FROM innermost)\n)\nSELECT * FROM outermost;\n\nWITH RECURSIVE outermost(x) AS (\n  WITH innermost as (SELECT 2 FROM outermost) -- fail\n    SELECT * FROM innermost\n    UNION SELECT * from outermost\n)\nSELECT * FROM outermost;\n\n--\n-- This test will fail with the old implementation of PARAM_EXEC parameter\n-- assignment, because the \"q1\" Var passed down to A's targetlist subselect\n-- looks exactly like the \"A.id\" Var passed down to C's subselect, causing\n-- the old code to give them the same runtime PARAM_EXEC slot.  But the\n-- lifespans of the two parameters overlap, thanks to B also reading A.\n--\n\nwith\nA as ( select q2 as id, (select q1) as x from int8_tbl ),\nB as ( select id, row_number() over (partition by id) as r from A ),\nC as ( select A.id, array(select B.id from B where B.id = A.id) from A )\nselect * from C;\n\n--\n-- Test CTEs read in non-initialization orders\n--\n\nWITH RECURSIVE\n  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),\n  iter (id_key, row_type, link) AS (\n      SELECT 0, 'base', 17\n    UNION ALL (\n      WITH remaining(id_key, row_type, link, min) AS (\n        SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()\n        FROM tab INNER JOIN iter USING (link)\n        WHERE tab.id_key > iter.id_key\n      ),\n      first_remaining AS (\n        SELECT id_key, row_type, link\n        FROM remaining\n        WHERE id_key=min\n      ),\n      effect AS (\n        SELECT tab.id_key, 'new'::text, tab.link\n        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key\n        WHERE e.row_type = 'false'\n      )\n      SELECT * FROM first_remaining\n      UNION ALL SELECT * FROM effect\n    )\n  )\nSELECT * FROM iter;\n\nWITH RECURSIVE\n  tab(id_key,link) AS (VALUES (1,17), (2,17), (3,17), (4,17), (6,17), (5,17)),\n  iter (id_key, row_type, link) AS (\n      SELECT 0, 'base', 17\n    UNION (\n      WITH remaining(id_key, row_type, link, min) AS (\n        SELECT tab.id_key, 'true'::text, iter.link, MIN(tab.id_key) OVER ()\n        FROM tab INNER JOIN iter USING (link)\n        WHERE tab.id_key > iter.id_key\n      ),\n      first_remaining AS (\n        SELECT id_key, row_type, link\n        FROM remaining\n        WHERE id_key=min\n      ),\n      effect AS (\n        SELECT tab.id_key, 'new'::text, tab.link\n        FROM first_remaining e INNER JOIN tab ON e.id_key=tab.id_key\n        WHERE e.row_type = 'false'\n      )\n      SELECT * FROM first_remaining\n      UNION ALL SELECT * FROM effect\n    )\n  )\nSELECT * FROM iter;\n\n--\n-- Data-modifying statements in WITH\n--\n\n-- INSERT ... RETURNING\nWITH t AS (\n    INSERT INTO y\n    VALUES\n        (11),\n        (12),\n        (13),\n        (14),\n        (15),\n        (16),\n        (17),\n        (18),\n        (19),\n        (20)\n    RETURNING *\n)\nSELECT * FROM t;\n\nSELECT * FROM y;\n\n-- UPDATE ... RETURNING\nWITH t AS (\n    UPDATE y\n    SET a=a+1\n    RETURNING *\n)\nSELECT * FROM t;\n\nSELECT * FROM y;\n\n-- DELETE ... RETURNING\nWITH t AS (\n    DELETE FROM y\n    WHERE a <= 10\n    RETURNING *\n)\nSELECT * FROM t;\n\nSELECT * FROM y;\n\n-- forward reference\nWITH RECURSIVE t AS (\n\tINSERT INTO y\n\t\tSELECT a+5 FROM t2 WHERE a > 5\n\tRETURNING *\n), t2 AS (\n\tUPDATE y SET a=a-11 RETURNING *\n)\nSELECT * FROM t\nUNION ALL\nSELECT * FROM t2;\n\nSELECT * FROM y;\n\n-- unconditional DO INSTEAD rule\nCREATE RULE y_rule AS ON DELETE TO y DO INSTEAD\n  INSERT INTO y VALUES(42) RETURNING *;\n\nWITH t AS (\n\tDELETE FROM y RETURNING *\n)\nSELECT * FROM t;\n\nSELECT * FROM y;\n\nDROP RULE y_rule ON y;\n\n-- check merging of outer CTE with CTE in a rule action\nCREATE TEMP TABLE bug6051 AS\n  select i from generate_series(1,3) as t(i);\n\nSELECT * FROM bug6051;\n\nWITH t1 AS ( DELETE FROM bug6051 RETURNING * )\nINSERT INTO bug6051 SELECT * FROM t1;\n\nSELECT * FROM bug6051;\n\nCREATE TEMP TABLE bug6051_2 (i int);\n\nCREATE RULE bug6051_ins AS ON INSERT TO bug6051 DO INSTEAD\n INSERT INTO bug6051_2\n SELECT NEW.i;\n\nWITH t1 AS ( DELETE FROM bug6051 RETURNING * )\nINSERT INTO bug6051 SELECT * FROM t1;\n\nSELECT * FROM bug6051;\nSELECT * FROM bug6051_2;\n\n-- a truly recursive CTE in the same list\nWITH RECURSIVE t(a) AS (\n\tSELECT 0\n\t\tUNION ALL\n\tSELECT a+1 FROM t WHERE a+1 < 5\n), t2 as (\n\tINSERT INTO y\n\t\tSELECT * FROM t RETURNING *\n)\nSELECT * FROM t2 JOIN y USING (a) ORDER BY a;\n\nSELECT * FROM y;\n\n-- data-modifying WITH in a modifying statement\nWITH t AS (\n    DELETE FROM y\n    WHERE a <= 10\n    RETURNING *\n)\nINSERT INTO y SELECT -a FROM t RETURNING *;\n\nSELECT * FROM y;\n\n-- check that WITH query is run to completion even if outer query isn't\nWITH t AS (\n    UPDATE y SET a = a * 100 RETURNING *\n)\nSELECT * FROM t LIMIT 10;\n\nSELECT * FROM y;\n\n-- data-modifying WITH containing INSERT...ON CONFLICT DO UPDATE\nCREATE TABLE z AS SELECT i AS k, (i || ' v')::text v FROM generate_series(1, 16, 3) i;\nALTER TABLE z ADD UNIQUE (k);\n\nWITH t AS (\n    INSERT INTO z SELECT i, 'insert'\n    FROM generate_series(0, 16) i\n    ON CONFLICT (k) DO UPDATE SET v = z.v || ', now update'\n    RETURNING *\n)\nSELECT * FROM t JOIN y ON t.k = y.a ORDER BY a, k;\n\n-- Test EXCLUDED.* reference within CTE\nWITH aa AS (\n    INSERT INTO z VALUES(1, 5) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v\n    WHERE z.k != EXCLUDED.k\n    RETURNING *\n)\nSELECT * FROM aa;\n\n-- New query/snapshot demonstrates side-effects of previous query.\nSELECT * FROM z ORDER BY k;\n\n--\n-- Ensure subqueries within the update clause work, even if they\n-- reference outside values\n--\nWITH aa AS (SELECT 1 a, 2 b)\nINSERT INTO z VALUES(1, 'insert')\nON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);\nWITH aa AS (SELECT 1 a, 2 b)\nINSERT INTO z VALUES(1, 'insert')\nON CONFLICT (k) DO UPDATE SET v = ' update' WHERE z.k = (SELECT a FROM aa);\nWITH aa AS (SELECT 1 a, 2 b)\nINSERT INTO z VALUES(1, 'insert')\nON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);\nWITH aa AS (SELECT 'a' a, 'b' b UNION ALL SELECT 'a' a, 'b' b)\nINSERT INTO z VALUES(1, 'insert')\nON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 'a' LIMIT 1);\nWITH aa AS (SELECT 1 a, 2 b)\nINSERT INTO z VALUES(1, (SELECT b || ' insert' FROM aa WHERE a = 1 ))\nON CONFLICT (k) DO UPDATE SET v = (SELECT b || ' update' FROM aa WHERE a = 1 LIMIT 1);\n\n-- Update a row more than once, in different parts of a wCTE. That is\n-- an allowed, presumably very rare, edge case, but since it was\n-- broken in the past, having a test seems worthwhile.\nWITH simpletup AS (\n  SELECT 2 k, 'Green' v),\nupsert_cte AS (\n  INSERT INTO z VALUES(2, 'Blue') ON CONFLICT (k) DO\n    UPDATE SET (k, v) = (SELECT k, v FROM simpletup WHERE simpletup.k = z.k)\n    RETURNING k, v)\nINSERT INTO z VALUES(2, 'Red') ON CONFLICT (k) DO\nUPDATE SET (k, v) = (SELECT k, v FROM upsert_cte WHERE upsert_cte.k = z.k)\nRETURNING k, v;\n\nDROP TABLE z;\n\n-- check that run to completion happens in proper ordering\n\nTRUNCATE TABLE y;\nINSERT INTO y SELECT generate_series(1, 3);\nCREATE TEMPORARY TABLE yy (a INTEGER);\n\nWITH RECURSIVE t1 AS (\n  INSERT INTO y SELECT * FROM y RETURNING *\n), t2 AS (\n  INSERT INTO yy SELECT * FROM t1 RETURNING *\n)\nSELECT 1;\n\nSELECT * FROM y;\nSELECT * FROM yy;\n\nWITH RECURSIVE t1 AS (\n  INSERT INTO yy SELECT * FROM t2 RETURNING *\n), t2 AS (\n  INSERT INTO y SELECT * FROM y RETURNING *\n)\nSELECT 1;\n\nSELECT * FROM y;\nSELECT * FROM yy;\n\n-- triggers\n\nTRUNCATE TABLE y;\nINSERT INTO y SELECT generate_series(1, 10);\n\nCREATE FUNCTION y_trigger() RETURNS trigger AS $$\nbegin\n  raise notice 'y_trigger: a = %', new.a;\n  return new;\nend;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER y_trig BEFORE INSERT ON y FOR EACH ROW\n    EXECUTE PROCEDURE y_trigger();\n\nWITH t AS (\n    INSERT INTO y\n    VALUES\n        (21),\n        (22),\n        (23)\n    RETURNING *\n)\nSELECT * FROM t;\n\nSELECT * FROM y;\n\nDROP TRIGGER y_trig ON y;\n\nCREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH ROW\n    EXECUTE PROCEDURE y_trigger();\n\nWITH t AS (\n    INSERT INTO y\n    VALUES\n        (31),\n        (32),\n        (33)\n    RETURNING *\n)\nSELECT * FROM t LIMIT 1;\n\nSELECT * FROM y;\n\nDROP TRIGGER y_trig ON y;\n\nCREATE OR REPLACE FUNCTION y_trigger() RETURNS trigger AS $$\nbegin\n  raise notice 'y_trigger';\n  return null;\nend;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER y_trig AFTER INSERT ON y FOR EACH STATEMENT\n    EXECUTE PROCEDURE y_trigger();\n\nWITH t AS (\n    INSERT INTO y\n    VALUES\n        (41),\n        (42),\n        (43)\n    RETURNING *\n)\nSELECT * FROM t;\n\nSELECT * FROM y;\n\nDROP TRIGGER y_trig ON y;\nDROP FUNCTION y_trigger();\n\n-- WITH attached to inherited UPDATE or DELETE\n\nCREATE TEMP TABLE parent ( id int, val text );\nCREATE TEMP TABLE child1 ( ) INHERITS ( parent );\nCREATE TEMP TABLE child2 ( ) INHERITS ( parent );\n\nINSERT INTO parent VALUES ( 1, 'p1' );\nINSERT INTO child1 VALUES ( 11, 'c11' ),( 12, 'c12' );\nINSERT INTO child2 VALUES ( 23, 'c21' ),( 24, 'c22' );\n\nWITH rcte AS ( SELECT sum(id) AS totalid FROM parent )\nUPDATE parent SET id = id + totalid FROM rcte;\n\nSELECT * FROM parent;\n\nWITH wcte AS ( INSERT INTO child1 VALUES ( 42, 'new' ) RETURNING id AS newid )\nUPDATE parent SET id = id + newid FROM wcte;\n\nSELECT * FROM parent;\n\nWITH rcte AS ( SELECT max(id) AS maxid FROM parent )\nDELETE FROM parent USING rcte WHERE id = maxid;\n\nSELECT * FROM parent;\n\nWITH wcte AS ( INSERT INTO child2 VALUES ( 42, 'new2' ) RETURNING id AS newid )\nDELETE FROM parent USING wcte WHERE id = newid;\n\nSELECT * FROM parent;\n\n-- check EXPLAIN VERBOSE for a wCTE with RETURNING\n\nEXPLAIN (VERBOSE, COSTS OFF)\nWITH wcte AS ( INSERT INTO int8_tbl VALUES ( 42, 47 ) RETURNING q2 )\nDELETE FROM a USING wcte WHERE aa = q2;\n\n-- error cases\n\n-- data-modifying WITH tries to use its own output\nWITH RECURSIVE t AS (\n\tINSERT INTO y\n\t\tSELECT * FROM t\n)\nVALUES(FALSE);\n\n-- no RETURNING in a referenced data-modifying WITH\nWITH t AS (\n\tINSERT INTO y VALUES(0)\n)\nSELECT * FROM t;\n\n-- data-modifying WITH allowed only at the top level\nSELECT * FROM (\n\tWITH t AS (UPDATE y SET a=a+1 RETURNING *)\n\tSELECT * FROM t\n) ss;\n\n-- most variants of rules aren't allowed\nCREATE RULE y_rule AS ON INSERT TO y WHERE a=0 DO INSTEAD DELETE FROM y;\nWITH t AS (\n\tINSERT INTO y VALUES(0)\n)\nVALUES(FALSE);\nDROP RULE y_rule ON y;\n\n-- check that parser lookahead for WITH doesn't cause any odd behavior\n-- create table foo (with baz);  -- fail, WITH is a reserved word\n-- create table foo (with ordinality);  -- fail, WITH is a reserved word\nwith ordinality as (select 1 as x) select * from ordinality;\n"
}