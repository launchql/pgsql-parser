/**
* This file was automatically generated by pg-proto-parser@1.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source proto file,
* and run the pg-proto-parser generate command to regenerate this file.
*/
import { QuerySource, SortByDir, SortByNulls, SetQuantifier, A_Expr_Kind, RoleSpecType, TableLikeOption, DefElemAction, PartitionStrategy, PartitionRangeDatumKind, RTEKind, WCOKind, GroupingSetKind, CTEMaterialize, JsonQuotes, JsonTableColumnType, SetOperation, ObjectType, DropBehavior, AlterTableType, GrantTargetType, VariableSetKind, ConstrType, ImportForeignSchemaType, RoleStmtType, FetchDirection, FunctionParameterMode, TransactionStmtKind, ViewCheckOption, DiscardMode, ReindexObjectType, AlterTSConfigType, PublicationObjSpecType, AlterPublicationAction, AlterSubscriptionType, OverridingKind, OnCommitAction, TableFuncType, ParamKind, CoercionContext, CoercionForm, BoolExprType, SubLinkType, RowCompareType, MinMaxOp, SQLValueFunctionOp, XmlExprOp, XmlOptionType, JsonEncoding, JsonFormatType, JsonConstructorType, JsonValueType, JsonWrapper, JsonBehaviorType, JsonExprOp, NullTestType, BoolTestType, MergeMatchKind, CmdType, JoinType, AggStrategy, AggSplit, SetOpCmd, SetOpStrategy, OnConflictAction, LimitOption, LockClauseStrength, LockWaitPolicy, LockTupleMode, KeywordKind, Token } from "@pgsql/types";
export type Node = ParseResult | ScanResult | Integer | Float | Boolean | String | BitString | List | OidList | IntList | A_Const | Alias | RangeVar | TableFunc | IntoClause | Var | Param | Aggref | GroupingFunc | WindowFunc | WindowFuncRunCondition | MergeSupportFunc | SubscriptingRef | FuncExpr | NamedArgExpr | OpExpr | DistinctExpr | NullIfExpr | ScalarArrayOpExpr | BoolExpr | SubLink | SubPlan | AlternativeSubPlan | FieldSelect | FieldStore | RelabelType | CoerceViaIO | ArrayCoerceExpr | ConvertRowtypeExpr | CollateExpr | CaseExpr | CaseWhen | CaseTestExpr | ArrayExpr | RowExpr | RowCompareExpr | CoalesceExpr | MinMaxExpr | SQLValueFunction | XmlExpr | JsonFormat | JsonReturning | JsonValueExpr | JsonConstructorExpr | JsonIsPredicate | JsonBehavior | JsonExpr | JsonTablePath | JsonTablePathScan | JsonTableSiblingJoin | NullTest | BooleanTest | MergeAction | CoerceToDomain | CoerceToDomainValue | SetToDefault | CurrentOfExpr | NextValueExpr | InferenceElem | TargetEntry | RangeTblRef | JoinExpr | FromExpr | OnConflictExpr | Query | TypeName | ColumnRef | ParamRef | A_Expr | TypeCast | CollateClause | RoleSpec | FuncCall | A_Star | A_Indices | A_Indirection | A_ArrayExpr | ResTarget | MultiAssignRef | SortBy | WindowDef | RangeSubselect | RangeFunction | RangeTableFunc | RangeTableFuncCol | RangeTableSample | ColumnDef | TableLikeClause | IndexElem | DefElem | LockingClause | XmlSerialize | PartitionElem | PartitionSpec | PartitionBoundSpec | PartitionRangeDatum | SinglePartitionSpec | PartitionCmd | RangeTblEntry | RTEPermissionInfo | RangeTblFunction | TableSampleClause | WithCheckOption | SortGroupClause | GroupingSet | WindowClause | RowMarkClause | WithClause | InferClause | OnConflictClause | CTESearchClause | CTECycleClause | CommonTableExpr | MergeWhenClause | TriggerTransition | JsonOutput | JsonArgument | JsonFuncExpr | JsonTablePathSpec | JsonTable | JsonTableColumn | JsonKeyValue | JsonParseExpr | JsonScalarExpr | JsonSerializeExpr | JsonObjectConstructor | JsonArrayConstructor | JsonArrayQueryConstructor | JsonAggConstructor | JsonObjectAgg | JsonArrayAgg | RawStmt | InsertStmt | DeleteStmt | UpdateStmt | MergeStmt | SelectStmt | SetOperationStmt | ReturnStmt | PLAssignStmt | CreateSchemaStmt | AlterTableStmt | ReplicaIdentityStmt | AlterTableCmd | AlterCollationStmt | AlterDomainStmt | GrantStmt | ObjectWithArgs | AccessPriv | GrantRoleStmt | AlterDefaultPrivilegesStmt | CopyStmt | VariableSetStmt | VariableShowStmt | CreateStmt | Constraint | CreateTableSpaceStmt | DropTableSpaceStmt | AlterTableSpaceOptionsStmt | AlterTableMoveAllStmt | CreateExtensionStmt | AlterExtensionStmt | AlterExtensionContentsStmt | CreateFdwStmt | AlterFdwStmt | CreateForeignServerStmt | AlterForeignServerStmt | CreateForeignTableStmt | CreateUserMappingStmt | AlterUserMappingStmt | DropUserMappingStmt | ImportForeignSchemaStmt | CreatePolicyStmt | AlterPolicyStmt | CreateAmStmt | CreateTrigStmt | CreateEventTrigStmt | AlterEventTrigStmt | CreatePLangStmt | CreateRoleStmt | AlterRoleStmt | AlterRoleSetStmt | DropRoleStmt | CreateSeqStmt | AlterSeqStmt | DefineStmt | CreateDomainStmt | CreateOpClassStmt | CreateOpClassItem | CreateOpFamilyStmt | AlterOpFamilyStmt | DropStmt | TruncateStmt | CommentStmt | SecLabelStmt | DeclareCursorStmt | ClosePortalStmt | FetchStmt | IndexStmt | CreateStatsStmt | StatsElem | AlterStatsStmt | CreateFunctionStmt | FunctionParameter | AlterFunctionStmt | DoStmt | InlineCodeBlock | CallStmt | CallContext | RenameStmt | AlterObjectDependsStmt | AlterObjectSchemaStmt | AlterOwnerStmt | AlterOperatorStmt | AlterTypeStmt | RuleStmt | NotifyStmt | ListenStmt | UnlistenStmt | TransactionStmt | CompositeTypeStmt | CreateEnumStmt | CreateRangeStmt | AlterEnumStmt | ViewStmt | LoadStmt | CreatedbStmt | AlterDatabaseStmt | AlterDatabaseRefreshCollStmt | AlterDatabaseSetStmt | DropdbStmt | AlterSystemStmt | ClusterStmt | VacuumStmt | VacuumRelation | ExplainStmt | CreateTableAsStmt | RefreshMatViewStmt | CheckPointStmt | DiscardStmt | LockStmt | ConstraintsSetStmt | ReindexStmt | CreateConversionStmt | CreateCastStmt | CreateTransformStmt | PrepareStmt | ExecuteStmt | DeallocateStmt | DropOwnedStmt | ReassignOwnedStmt | AlterTSDictionaryStmt | AlterTSConfigurationStmt | PublicationTable | PublicationObjSpec | CreatePublicationStmt | AlterPublicationStmt | CreateSubscriptionStmt | AlterSubscriptionStmt | DropSubscriptionStmt | ScanToken;
export interface ParseResult {
  ParseResult: {
    version?: number;
    stmts?: RawStmt[];
  };
}
export interface ScanResult {
  ScanResult: {
    version?: number;
    tokens?: ScanToken[];
  };
}
export interface Integer {
  Integer: {
    ival?: number;
  };
}
export interface Float {
  Float: {
    fval?: string;
  };
}
export interface Boolean {
  Boolean: {
    boolval?: boolean;
  };
}
export interface String {
  String: {
    sval?: string;
  };
}
export interface BitString {
  BitString: {
    bsval?: string;
  };
}
export interface List {
  List: {
    items?: Node[];
  };
}
export interface OidList {
  OidList: {
    items?: Node[];
  };
}
export interface IntList {
  IntList: {
    items?: Node[];
  };
}
export interface A_Const {
  A_Const: {
    ival?: Integer;
    fval?: Float;
    boolval?: Boolean;
    sval?: String;
    bsval?: BitString;
    isnull?: boolean;
    location?: number;
  };
}
export interface Alias {
  Alias: {
    aliasname?: string;
    colnames?: Node[];
  };
}
export interface RangeVar {
  RangeVar: {
    catalogname?: string;
    schemaname?: string;
    relname?: string;
    inh?: boolean;
    relpersistence?: string;
    alias?: Alias;
    location?: number;
  };
}
export interface TableFunc {
  TableFunc: {
    functype?: TableFuncType;
    ns_uris?: Node[];
    ns_names?: Node[];
    docexpr?: Node;
    rowexpr?: Node;
    colnames?: Node[];
    coltypes?: Node[];
    coltypmods?: Node[];
    colcollations?: Node[];
    colexprs?: Node[];
    coldefexprs?: Node[];
    colvalexprs?: Node[];
    passingvalexprs?: Node[];
    notnulls?: bigint[];
    plan?: Node;
    ordinalitycol?: number;
    location?: number;
  };
}
export interface IntoClause {
  IntoClause: {
    rel?: RangeVar;
    colNames?: Node[];
    accessMethod?: string;
    options?: Node[];
    onCommit?: OnCommitAction;
    tableSpaceName?: string;
    viewQuery?: Node;
    skipData?: boolean;
  };
}
export interface Var {
  Var: {
    xpr?: Node;
    varno?: number;
    varattno?: number;
    vartype?: number;
    vartypmod?: number;
    varcollid?: number;
    varnullingrels?: bigint[];
    varlevelsup?: number;
    location?: number;
  };
}
export interface Param {
  Param: {
    xpr?: Node;
    paramkind?: ParamKind;
    paramid?: number;
    paramtype?: number;
    paramtypmod?: number;
    paramcollid?: number;
    location?: number;
  };
}
export interface Aggref {
  Aggref: {
    xpr?: Node;
    aggfnoid?: number;
    aggtype?: number;
    aggcollid?: number;
    inputcollid?: number;
    aggargtypes?: Node[];
    aggdirectargs?: Node[];
    args?: Node[];
    aggorder?: Node[];
    aggdistinct?: Node[];
    aggfilter?: Node;
    aggstar?: boolean;
    aggvariadic?: boolean;
    aggkind?: string;
    agglevelsup?: number;
    aggsplit?: AggSplit;
    aggno?: number;
    aggtransno?: number;
    location?: number;
  };
}
export interface GroupingFunc {
  GroupingFunc: {
    xpr?: Node;
    args?: Node[];
    refs?: Node[];
    agglevelsup?: number;
    location?: number;
  };
}
export interface WindowFunc {
  WindowFunc: {
    xpr?: Node;
    winfnoid?: number;
    wintype?: number;
    wincollid?: number;
    inputcollid?: number;
    args?: Node[];
    aggfilter?: Node;
    runCondition?: Node[];
    winref?: number;
    winstar?: boolean;
    winagg?: boolean;
    location?: number;
  };
}
export interface WindowFuncRunCondition {
  WindowFuncRunCondition: {
    xpr?: Node;
    opno?: number;
    inputcollid?: number;
    wfunc_left?: boolean;
    arg?: Node;
  };
}
export interface MergeSupportFunc {
  MergeSupportFunc: {
    xpr?: Node;
    msftype?: number;
    msfcollid?: number;
    location?: number;
  };
}
export interface SubscriptingRef {
  SubscriptingRef: {
    xpr?: Node;
    refcontainertype?: number;
    refelemtype?: number;
    refrestype?: number;
    reftypmod?: number;
    refcollid?: number;
    refupperindexpr?: Node[];
    reflowerindexpr?: Node[];
    refexpr?: Node;
    refassgnexpr?: Node;
  };
}
export interface FuncExpr {
  FuncExpr: {
    xpr?: Node;
    funcid?: number;
    funcresulttype?: number;
    funcretset?: boolean;
    funcvariadic?: boolean;
    funcformat?: CoercionForm;
    funccollid?: number;
    inputcollid?: number;
    args?: Node[];
    location?: number;
  };
}
export interface NamedArgExpr {
  NamedArgExpr: {
    xpr?: Node;
    arg?: Node;
    name?: string;
    argnumber?: number;
    location?: number;
  };
}
export interface OpExpr {
  OpExpr: {
    xpr?: Node;
    opno?: number;
    opresulttype?: number;
    opretset?: boolean;
    opcollid?: number;
    inputcollid?: number;
    args?: Node[];
    location?: number;
  };
}
export interface DistinctExpr {
  DistinctExpr: {
    xpr?: Node;
    opno?: number;
    opresulttype?: number;
    opretset?: boolean;
    opcollid?: number;
    inputcollid?: number;
    args?: Node[];
    location?: number;
  };
}
export interface NullIfExpr {
  NullIfExpr: {
    xpr?: Node;
    opno?: number;
    opresulttype?: number;
    opretset?: boolean;
    opcollid?: number;
    inputcollid?: number;
    args?: Node[];
    location?: number;
  };
}
export interface ScalarArrayOpExpr {
  ScalarArrayOpExpr: {
    xpr?: Node;
    opno?: number;
    useOr?: boolean;
    inputcollid?: number;
    args?: Node[];
    location?: number;
  };
}
export interface BoolExpr {
  BoolExpr: {
    xpr?: Node;
    boolop?: BoolExprType;
    args?: Node[];
    location?: number;
  };
}
export interface SubLink {
  SubLink: {
    xpr?: Node;
    subLinkType?: SubLinkType;
    subLinkId?: number;
    testexpr?: Node;
    operName?: Node[];
    subselect?: Node;
    location?: number;
  };
}
export interface SubPlan {
  SubPlan: {
    xpr?: Node;
    subLinkType?: SubLinkType;
    testexpr?: Node;
    paramIds?: Node[];
    plan_id?: number;
    plan_name?: string;
    firstColType?: number;
    firstColTypmod?: number;
    firstColCollation?: number;
    useHashTable?: boolean;
    unknownEqFalse?: boolean;
    parallel_safe?: boolean;
    setParam?: Node[];
    parParam?: Node[];
    args?: Node[];
    startup_cost?: number;
    per_call_cost?: number;
  };
}
export interface AlternativeSubPlan {
  AlternativeSubPlan: {
    xpr?: Node;
    subplans?: Node[];
  };
}
export interface FieldSelect {
  FieldSelect: {
    xpr?: Node;
    arg?: Node;
    fieldnum?: number;
    resulttype?: number;
    resulttypmod?: number;
    resultcollid?: number;
  };
}
export interface FieldStore {
  FieldStore: {
    xpr?: Node;
    arg?: Node;
    newvals?: Node[];
    fieldnums?: Node[];
    resulttype?: number;
  };
}
export interface RelabelType {
  RelabelType: {
    xpr?: Node;
    arg?: Node;
    resulttype?: number;
    resulttypmod?: number;
    resultcollid?: number;
    relabelformat?: CoercionForm;
    location?: number;
  };
}
export interface CoerceViaIO {
  CoerceViaIO: {
    xpr?: Node;
    arg?: Node;
    resulttype?: number;
    resultcollid?: number;
    coerceformat?: CoercionForm;
    location?: number;
  };
}
export interface ArrayCoerceExpr {
  ArrayCoerceExpr: {
    xpr?: Node;
    arg?: Node;
    elemexpr?: Node;
    resulttype?: number;
    resulttypmod?: number;
    resultcollid?: number;
    coerceformat?: CoercionForm;
    location?: number;
  };
}
export interface ConvertRowtypeExpr {
  ConvertRowtypeExpr: {
    xpr?: Node;
    arg?: Node;
    resulttype?: number;
    convertformat?: CoercionForm;
    location?: number;
  };
}
export interface CollateExpr {
  CollateExpr: {
    xpr?: Node;
    arg?: Node;
    collOid?: number;
    location?: number;
  };
}
export interface CaseExpr {
  CaseExpr: {
    xpr?: Node;
    casetype?: number;
    casecollid?: number;
    arg?: Node;
    args?: Node[];
    defresult?: Node;
    location?: number;
  };
}
export interface CaseWhen {
  CaseWhen: {
    xpr?: Node;
    expr?: Node;
    result?: Node;
    location?: number;
  };
}
export interface CaseTestExpr {
  CaseTestExpr: {
    xpr?: Node;
    typeId?: number;
    typeMod?: number;
    collation?: number;
  };
}
export interface ArrayExpr {
  ArrayExpr: {
    xpr?: Node;
    array_typeid?: number;
    array_collid?: number;
    element_typeid?: number;
    elements?: Node[];
    multidims?: boolean;
    location?: number;
  };
}
export interface RowExpr {
  RowExpr: {
    xpr?: Node;
    args?: Node[];
    row_typeid?: number;
    row_format?: CoercionForm;
    colnames?: Node[];
    location?: number;
  };
}
export interface RowCompareExpr {
  RowCompareExpr: {
    xpr?: Node;
    rctype?: RowCompareType;
    opnos?: Node[];
    opfamilies?: Node[];
    inputcollids?: Node[];
    largs?: Node[];
    rargs?: Node[];
  };
}
export interface CoalesceExpr {
  CoalesceExpr: {
    xpr?: Node;
    coalescetype?: number;
    coalescecollid?: number;
    args?: Node[];
    location?: number;
  };
}
export interface MinMaxExpr {
  MinMaxExpr: {
    xpr?: Node;
    minmaxtype?: number;
    minmaxcollid?: number;
    inputcollid?: number;
    op?: MinMaxOp;
    args?: Node[];
    location?: number;
  };
}
export interface SQLValueFunction {
  SQLValueFunction: {
    xpr?: Node;
    op?: SQLValueFunctionOp;
    type?: number;
    typmod?: number;
    location?: number;
  };
}
export interface XmlExpr {
  XmlExpr: {
    xpr?: Node;
    op?: XmlExprOp;
    name?: string;
    named_args?: Node[];
    arg_names?: Node[];
    args?: Node[];
    xmloption?: XmlOptionType;
    indent?: boolean;
    type?: number;
    typmod?: number;
    location?: number;
  };
}
export interface JsonFormat {
  JsonFormat: {
    format_type?: JsonFormatType;
    encoding?: JsonEncoding;
    location?: number;
  };
}
export interface JsonReturning {
  JsonReturning: {
    format?: JsonFormat;
    typid?: number;
    typmod?: number;
  };
}
export interface JsonValueExpr {
  JsonValueExpr: {
    raw_expr?: Node;
    formatted_expr?: Node;
    format?: JsonFormat;
  };
}
export interface JsonConstructorExpr {
  JsonConstructorExpr: {
    xpr?: Node;
    type?: JsonConstructorType;
    args?: Node[];
    func?: Node;
    coercion?: Node;
    returning?: JsonReturning;
    absent_on_null?: boolean;
    unique?: boolean;
    location?: number;
  };
}
export interface JsonIsPredicate {
  JsonIsPredicate: {
    expr?: Node;
    format?: JsonFormat;
    item_type?: JsonValueType;
    unique_keys?: boolean;
    location?: number;
  };
}
export interface JsonBehavior {
  JsonBehavior: {
    btype?: JsonBehaviorType;
    expr?: Node;
    coerce?: boolean;
    location?: number;
  };
}
export interface JsonExpr {
  JsonExpr: {
    xpr?: Node;
    op?: JsonExprOp;
    column_name?: string;
    formatted_expr?: Node;
    format?: JsonFormat;
    path_spec?: Node;
    returning?: JsonReturning;
    passing_names?: Node[];
    passing_values?: Node[];
    on_empty?: JsonBehavior;
    on_error?: JsonBehavior;
    use_io_coercion?: boolean;
    use_json_coercion?: boolean;
    wrapper?: JsonWrapper;
    omit_quotes?: boolean;
    collation?: number;
    location?: number;
  };
}
export interface JsonTablePath {
  JsonTablePath: {
    name?: string;
  };
}
export interface JsonTablePathScan {
  JsonTablePathScan: {
    plan?: Node;
    path?: JsonTablePath;
    errorOnError?: boolean;
    child?: Node;
    colMin?: number;
    colMax?: number;
  };
}
export interface JsonTableSiblingJoin {
  JsonTableSiblingJoin: {
    plan?: Node;
    lplan?: Node;
    rplan?: Node;
  };
}
export interface NullTest {
  NullTest: {
    xpr?: Node;
    arg?: Node;
    nulltesttype?: NullTestType;
    argisrow?: boolean;
    location?: number;
  };
}
export interface BooleanTest {
  BooleanTest: {
    xpr?: Node;
    arg?: Node;
    booltesttype?: BoolTestType;
    location?: number;
  };
}
export interface MergeAction {
  MergeAction: {
    matchKind?: MergeMatchKind;
    commandType?: CmdType;
    override?: OverridingKind;
    qual?: Node;
    targetList?: Node[];
    updateColnos?: Node[];
  };
}
export interface CoerceToDomain {
  CoerceToDomain: {
    xpr?: Node;
    arg?: Node;
    resulttype?: number;
    resulttypmod?: number;
    resultcollid?: number;
    coercionformat?: CoercionForm;
    location?: number;
  };
}
export interface CoerceToDomainValue {
  CoerceToDomainValue: {
    xpr?: Node;
    typeId?: number;
    typeMod?: number;
    collation?: number;
    location?: number;
  };
}
export interface SetToDefault {
  SetToDefault: {
    xpr?: Node;
    typeId?: number;
    typeMod?: number;
    collation?: number;
    location?: number;
  };
}
export interface CurrentOfExpr {
  CurrentOfExpr: {
    xpr?: Node;
    cvarno?: number;
    cursor_name?: string;
    cursor_param?: number;
  };
}
export interface NextValueExpr {
  NextValueExpr: {
    xpr?: Node;
    seqid?: number;
    typeId?: number;
  };
}
export interface InferenceElem {
  InferenceElem: {
    xpr?: Node;
    expr?: Node;
    infercollid?: number;
    inferopclass?: number;
  };
}
export interface TargetEntry {
  TargetEntry: {
    xpr?: Node;
    expr?: Node;
    resno?: number;
    resname?: string;
    ressortgroupref?: number;
    resorigtbl?: number;
    resorigcol?: number;
    resjunk?: boolean;
  };
}
export interface RangeTblRef {
  RangeTblRef: {
    rtindex?: number;
  };
}
export interface JoinExpr {
  JoinExpr: {
    jointype?: JoinType;
    isNatural?: boolean;
    larg?: Node;
    rarg?: Node;
    usingClause?: Node[];
    join_using_alias?: Alias;
    quals?: Node;
    alias?: Alias;
    rtindex?: number;
  };
}
export interface FromExpr {
  FromExpr: {
    fromlist?: Node[];
    quals?: Node;
  };
}
export interface OnConflictExpr {
  OnConflictExpr: {
    action?: OnConflictAction;
    arbiterElems?: Node[];
    arbiterWhere?: Node;
    constraint?: number;
    onConflictSet?: Node[];
    onConflictWhere?: Node;
    exclRelIndex?: number;
    exclRelTlist?: Node[];
  };
}
export interface Query {
  Query: {
    commandType?: CmdType;
    querySource?: QuerySource;
    canSetTag?: boolean;
    utilityStmt?: Node;
    resultRelation?: number;
    hasAggs?: boolean;
    hasWindowFuncs?: boolean;
    hasTargetSRFs?: boolean;
    hasSubLinks?: boolean;
    hasDistinctOn?: boolean;
    hasRecursive?: boolean;
    hasModifyingCTE?: boolean;
    hasForUpdate?: boolean;
    hasRowSecurity?: boolean;
    isReturn?: boolean;
    cteList?: Node[];
    rtable?: Node[];
    rteperminfos?: Node[];
    jointree?: FromExpr;
    mergeActionList?: Node[];
    mergeTargetRelation?: number;
    mergeJoinCondition?: Node;
    targetList?: Node[];
    override?: OverridingKind;
    onConflict?: OnConflictExpr;
    returningList?: Node[];
    groupClause?: Node[];
    groupDistinct?: boolean;
    groupingSets?: Node[];
    havingQual?: Node;
    windowClause?: Node[];
    distinctClause?: Node[];
    sortClause?: Node[];
    limitOffset?: Node;
    limitCount?: Node;
    limitOption?: LimitOption;
    rowMarks?: Node[];
    setOperations?: Node;
    constraintDeps?: Node[];
    withCheckOptions?: Node[];
    stmt_location?: number;
    stmt_len?: number;
  };
}
export interface TypeName {
  names?: Node[];
  typeOid?: number;
  setof?: boolean;
  pct_type?: boolean;
  typmods?: Node[];
  typemod?: number;
  arrayBounds?: Node[];
  location?: number;
}
export interface ColumnRef {
  ColumnRef: {
    fields?: Node[];
    location?: number;
  };
}
export interface ParamRef {
  ParamRef: {
    number?: number;
    location?: number;
  };
}
export interface A_Expr {
  A_Expr: {
    kind?: A_Expr_Kind;
    name?: Node[];
    lexpr?: Node;
    rexpr?: Node;
    location?: number;
  };
}
export interface TypeCast {
  TypeCast: {
    arg?: Node;
    typeName?: TypeName;
    location?: number;
  };
}
export interface CollateClause {
  CollateClause: {
    arg?: Node;
    collname?: Node[];
    location?: number;
  };
}
export interface RoleSpec {
  RoleSpec: {
    roletype?: RoleSpecType;
    rolename?: string;
    location?: number;
  };
}
export interface FuncCall {
  FuncCall: {
    funcname?: Node[];
    args?: Node[];
    agg_order?: Node[];
    agg_filter?: Node;
    over?: WindowDef;
    agg_within_group?: boolean;
    agg_star?: boolean;
    agg_distinct?: boolean;
    func_variadic?: boolean;
    funcformat?: CoercionForm;
    location?: number;
  };
}
export interface A_Star {
  A_Star: {};
}
export interface A_Indices {
  A_Indices: {
    is_slice?: boolean;
    lidx?: Node;
    uidx?: Node;
  };
}
export interface A_Indirection {
  A_Indirection: {
    arg?: Node;
    indirection?: Node[];
  };
}
export interface A_ArrayExpr {
  A_ArrayExpr: {
    elements?: Node[];
    location?: number;
  };
}
export interface ResTarget {
  ResTarget: {
    name?: string;
    indirection?: Node[];
    val?: Node;
    location?: number;
  };
}
export interface MultiAssignRef {
  MultiAssignRef: {
    source?: Node;
    colno?: number;
    ncolumns?: number;
  };
}
export interface SortBy {
  SortBy: {
    node?: Node;
    sortby_dir?: SortByDir;
    sortby_nulls?: SortByNulls;
    useOp?: Node[];
    location?: number;
  };
}
export interface WindowDef {
  WindowDef: {
    name?: string;
    refname?: string;
    partitionClause?: Node[];
    orderClause?: Node[];
    frameOptions?: number;
    startOffset?: Node;
    endOffset?: Node;
    location?: number;
  };
}
export interface RangeSubselect {
  RangeSubselect: {
    lateral?: boolean;
    subquery?: Node;
    alias?: Alias;
  };
}
export interface RangeFunction {
  RangeFunction: {
    lateral?: boolean;
    ordinality?: boolean;
    is_rowsfrom?: boolean;
    functions?: Node[];
    alias?: Alias;
    coldeflist?: Node[];
  };
}
export interface RangeTableFunc {
  RangeTableFunc: {
    lateral?: boolean;
    docexpr?: Node;
    rowexpr?: Node;
    namespaces?: Node[];
    columns?: Node[];
    alias?: Alias;
    location?: number;
  };
}
export interface RangeTableFuncCol {
  RangeTableFuncCol: {
    colname?: string;
    typeName?: TypeName;
    for_ordinality?: boolean;
    is_not_null?: boolean;
    colexpr?: Node;
    coldefexpr?: Node;
    location?: number;
  };
}
export interface RangeTableSample {
  RangeTableSample: {
    relation?: Node;
    method?: Node[];
    args?: Node[];
    repeatable?: Node;
    location?: number;
  };
}
export interface ColumnDef {
  ColumnDef: {
    colname?: string;
    typeName?: TypeName;
    compression?: string;
    inhcount?: number;
    is_local?: boolean;
    is_not_null?: boolean;
    is_from_type?: boolean;
    storage?: string;
    storage_name?: string;
    raw_default?: Node;
    cooked_default?: Node;
    identity?: string;
    identitySequence?: RangeVar;
    generated?: string;
    collClause?: CollateClause;
    collOid?: number;
    constraints?: Node[];
    fdwoptions?: Node[];
    location?: number;
  };
}
export interface TableLikeClause {
  TableLikeClause: {
    relation?: RangeVar;
    options?: number;
    relationOid?: number;
  };
}
export interface IndexElem {
  IndexElem: {
    name?: string;
    expr?: Node;
    indexcolname?: string;
    collation?: Node[];
    opclass?: Node[];
    opclassopts?: Node[];
    ordering?: SortByDir;
    nulls_ordering?: SortByNulls;
  };
}
export interface DefElem {
  DefElem: {
    defnamespace?: string;
    defname?: string;
    arg?: Node;
    defaction?: DefElemAction;
    location?: number;
  };
}
export interface LockingClause {
  LockingClause: {
    lockedRels?: Node[];
    strength?: LockClauseStrength;
    waitPolicy?: LockWaitPolicy;
  };
}
export interface XmlSerialize {
  XmlSerialize: {
    xmloption?: XmlOptionType;
    expr?: Node;
    typeName?: TypeName;
    indent?: boolean;
    location?: number;
  };
}
export interface PartitionElem {
  PartitionElem: {
    name?: string;
    expr?: Node;
    collation?: Node[];
    opclass?: Node[];
    location?: number;
  };
}
export interface PartitionSpec {
  PartitionSpec: {
    strategy?: PartitionStrategy;
    partParams?: Node[];
    location?: number;
  };
}
export interface PartitionBoundSpec {
  PartitionBoundSpec: {
    strategy?: string;
    is_default?: boolean;
    modulus?: number;
    remainder?: number;
    listdatums?: Node[];
    lowerdatums?: Node[];
    upperdatums?: Node[];
    location?: number;
  };
}
export interface PartitionRangeDatum {
  PartitionRangeDatum: {
    kind?: PartitionRangeDatumKind;
    value?: Node;
    location?: number;
  };
}
export interface SinglePartitionSpec {
  SinglePartitionSpec: {};
}
export interface PartitionCmd {
  PartitionCmd: {
    name?: RangeVar;
    bound?: PartitionBoundSpec;
    concurrent?: boolean;
  };
}
export interface RangeTblEntry {
  RangeTblEntry: {
    alias?: Alias;
    eref?: Alias;
    rtekind?: RTEKind;
    relid?: number;
    inh?: boolean;
    relkind?: string;
    rellockmode?: number;
    perminfoindex?: number;
    tablesample?: TableSampleClause;
    subquery?: Query;
    security_barrier?: boolean;
    jointype?: JoinType;
    joinmergedcols?: number;
    joinaliasvars?: Node[];
    joinleftcols?: Node[];
    joinrightcols?: Node[];
    join_using_alias?: Alias;
    functions?: Node[];
    funcordinality?: boolean;
    tablefunc?: TableFunc;
    values_lists?: Node[];
    ctename?: string;
    ctelevelsup?: number;
    self_reference?: boolean;
    coltypes?: Node[];
    coltypmods?: Node[];
    colcollations?: Node[];
    enrname?: string;
    enrtuples?: number;
    lateral?: boolean;
    inFromCl?: boolean;
    securityQuals?: Node[];
  };
}
export interface RTEPermissionInfo {
  RTEPermissionInfo: {
    relid?: number;
    inh?: boolean;
    requiredPerms?: bigint;
    checkAsUser?: number;
    selectedCols?: bigint[];
    insertedCols?: bigint[];
    updatedCols?: bigint[];
  };
}
export interface RangeTblFunction {
  RangeTblFunction: {
    funcexpr?: Node;
    funccolcount?: number;
    funccolnames?: Node[];
    funccoltypes?: Node[];
    funccoltypmods?: Node[];
    funccolcollations?: Node[];
    funcparams?: bigint[];
  };
}
export interface TableSampleClause {
  TableSampleClause: {
    tsmhandler?: number;
    args?: Node[];
    repeatable?: Node;
  };
}
export interface WithCheckOption {
  WithCheckOption: {
    kind?: WCOKind;
    relname?: string;
    polname?: string;
    qual?: Node;
    cascaded?: boolean;
  };
}
export interface SortGroupClause {
  SortGroupClause: {
    tleSortGroupRef?: number;
    eqop?: number;
    sortop?: number;
    nulls_first?: boolean;
    hashable?: boolean;
  };
}
export interface GroupingSet {
  GroupingSet: {
    kind?: GroupingSetKind;
    content?: Node[];
    location?: number;
  };
}
export interface WindowClause {
  WindowClause: {
    name?: string;
    refname?: string;
    partitionClause?: Node[];
    orderClause?: Node[];
    frameOptions?: number;
    startOffset?: Node;
    endOffset?: Node;
    startInRangeFunc?: number;
    endInRangeFunc?: number;
    inRangeColl?: number;
    inRangeAsc?: boolean;
    inRangeNullsFirst?: boolean;
    winref?: number;
    copiedOrder?: boolean;
  };
}
export interface RowMarkClause {
  RowMarkClause: {
    rti?: number;
    strength?: LockClauseStrength;
    waitPolicy?: LockWaitPolicy;
    pushedDown?: boolean;
  };
}
export interface WithClause {
  WithClause: {
    ctes?: Node[];
    recursive?: boolean;
    location?: number;
  };
}
export interface InferClause {
  InferClause: {
    indexElems?: Node[];
    whereClause?: Node;
    conname?: string;
    location?: number;
  };
}
export interface OnConflictClause {
  OnConflictClause: {
    action?: OnConflictAction;
    infer?: InferClause;
    targetList?: Node[];
    whereClause?: Node;
    location?: number;
  };
}
export interface CTESearchClause {
  CTESearchClause: {
    search_col_list?: Node[];
    search_breadth_first?: boolean;
    search_seq_column?: string;
    location?: number;
  };
}
export interface CTECycleClause {
  CTECycleClause: {
    cycle_col_list?: Node[];
    cycle_mark_column?: string;
    cycle_mark_value?: Node;
    cycle_mark_default?: Node;
    cycle_path_column?: string;
    location?: number;
    cycle_mark_type?: number;
    cycle_mark_typmod?: number;
    cycle_mark_collation?: number;
    cycle_mark_neop?: number;
  };
}
export interface CommonTableExpr {
  CommonTableExpr: {
    ctename?: string;
    aliascolnames?: Node[];
    ctematerialized?: CTEMaterialize;
    ctequery?: Node;
    search_clause?: CTESearchClause;
    cycle_clause?: CTECycleClause;
    location?: number;
    cterecursive?: boolean;
    cterefcount?: number;
    ctecolnames?: Node[];
    ctecoltypes?: Node[];
    ctecoltypmods?: Node[];
    ctecolcollations?: Node[];
  };
}
export interface MergeWhenClause {
  MergeWhenClause: {
    matchKind?: MergeMatchKind;
    commandType?: CmdType;
    override?: OverridingKind;
    condition?: Node;
    targetList?: Node[];
    values?: Node[];
  };
}
export interface TriggerTransition {
  TriggerTransition: {
    name?: string;
    isNew?: boolean;
    isTable?: boolean;
  };
}
export interface JsonOutput {
  JsonOutput: {
    typeName?: TypeName;
    returning?: JsonReturning;
  };
}
export interface JsonArgument {
  JsonArgument: {
    val?: JsonValueExpr;
    name?: string;
  };
}
export interface JsonFuncExpr {
  JsonFuncExpr: {
    op?: JsonExprOp;
    column_name?: string;
    context_item?: JsonValueExpr;
    pathspec?: Node;
    passing?: Node[];
    output?: JsonOutput;
    on_empty?: JsonBehavior;
    on_error?: JsonBehavior;
    wrapper?: JsonWrapper;
    quotes?: JsonQuotes;
    location?: number;
  };
}
export interface JsonTablePathSpec {
  JsonTablePathSpec: {
    string?: Node;
    name?: string;
    name_location?: number;
    location?: number;
  };
}
export interface JsonTable {
  JsonTable: {
    context_item?: JsonValueExpr;
    pathspec?: JsonTablePathSpec;
    passing?: Node[];
    columns?: Node[];
    on_error?: JsonBehavior;
    alias?: Alias;
    lateral?: boolean;
    location?: number;
  };
}
export interface JsonTableColumn {
  JsonTableColumn: {
    coltype?: JsonTableColumnType;
    name?: string;
    typeName?: TypeName;
    pathspec?: JsonTablePathSpec;
    format?: JsonFormat;
    wrapper?: JsonWrapper;
    quotes?: JsonQuotes;
    columns?: Node[];
    on_empty?: JsonBehavior;
    on_error?: JsonBehavior;
    location?: number;
  };
}
export interface JsonKeyValue {
  JsonKeyValue: {
    key?: Node;
    value?: JsonValueExpr;
  };
}
export interface JsonParseExpr {
  JsonParseExpr: {
    expr?: JsonValueExpr;
    output?: JsonOutput;
    unique_keys?: boolean;
    location?: number;
  };
}
export interface JsonScalarExpr {
  JsonScalarExpr: {
    expr?: Node;
    output?: JsonOutput;
    location?: number;
  };
}
export interface JsonSerializeExpr {
  JsonSerializeExpr: {
    expr?: JsonValueExpr;
    output?: JsonOutput;
    location?: number;
  };
}
export interface JsonObjectConstructor {
  JsonObjectConstructor: {
    exprs?: Node[];
    output?: JsonOutput;
    absent_on_null?: boolean;
    unique?: boolean;
    location?: number;
  };
}
export interface JsonArrayConstructor {
  JsonArrayConstructor: {
    exprs?: Node[];
    output?: JsonOutput;
    absent_on_null?: boolean;
    location?: number;
  };
}
export interface JsonArrayQueryConstructor {
  JsonArrayQueryConstructor: {
    query?: Node;
    output?: JsonOutput;
    format?: JsonFormat;
    absent_on_null?: boolean;
    location?: number;
  };
}
export interface JsonAggConstructor {
  JsonAggConstructor: {
    output?: JsonOutput;
    agg_filter?: Node;
    agg_order?: Node[];
    over?: WindowDef;
    location?: number;
  };
}
export interface JsonObjectAgg {
  JsonObjectAgg: {
    constructor?: JsonAggConstructor;
    arg?: JsonKeyValue;
    absent_on_null?: boolean;
    unique?: boolean;
  };
}
export interface JsonArrayAgg {
  JsonArrayAgg: {
    constructor?: JsonAggConstructor;
    arg?: JsonValueExpr;
    absent_on_null?: boolean;
  };
}
export interface RawStmt {
  RawStmt: {
    stmt?: Node;
    stmt_location?: number;
    stmt_len?: number;
  };
}
export interface InsertStmt {
  InsertStmt: {
    relation?: RangeVar;
    cols?: Node[];
    selectStmt?: Node;
    onConflictClause?: OnConflictClause;
    returningList?: Node[];
    withClause?: WithClause;
    override?: OverridingKind;
  };
}
export interface DeleteStmt {
  DeleteStmt: {
    relation?: RangeVar;
    usingClause?: Node[];
    whereClause?: Node;
    returningList?: Node[];
    withClause?: WithClause;
  };
}
export interface UpdateStmt {
  UpdateStmt: {
    relation?: RangeVar;
    targetList?: Node[];
    whereClause?: Node;
    fromClause?: Node[];
    returningList?: Node[];
    withClause?: WithClause;
  };
}
export interface MergeStmt {
  MergeStmt: {
    relation?: RangeVar;
    sourceRelation?: Node;
    joinCondition?: Node;
    mergeWhenClauses?: Node[];
    returningList?: Node[];
    withClause?: WithClause;
  };
}
export interface SelectStmt {
  SelectStmt: {
    distinctClause?: Node[];
    intoClause?: IntoClause;
    targetList?: Node[];
    fromClause?: Node[];
    whereClause?: Node;
    groupClause?: Node[];
    groupDistinct?: boolean;
    havingClause?: Node;
    windowClause?: Node[];
    valuesLists?: Node[];
    sortClause?: Node[];
    limitOffset?: Node;
    limitCount?: Node;
    limitOption?: LimitOption;
    lockingClause?: Node[];
    withClause?: WithClause;
    op?: SetOperation;
    all?: boolean;
    larg?: SelectStmt;
    rarg?: SelectStmt;
  };
}
export interface SetOperationStmt {
  SetOperationStmt: {
    op?: SetOperation;
    all?: boolean;
    larg?: Node;
    rarg?: Node;
    colTypes?: Node[];
    colTypmods?: Node[];
    colCollations?: Node[];
    groupClauses?: Node[];
  };
}
export interface ReturnStmt {
  ReturnStmt: {
    returnval?: Node;
  };
}
export interface PLAssignStmt {
  PLAssignStmt: {
    name?: string;
    indirection?: Node[];
    nnames?: number;
    val?: SelectStmt;
    location?: number;
  };
}
export interface CreateSchemaStmt {
  CreateSchemaStmt: {
    schemaname?: string;
    authrole?: RoleSpec;
    schemaElts?: Node[];
    if_not_exists?: boolean;
  };
}
export interface AlterTableStmt {
  AlterTableStmt: {
    relation?: RangeVar;
    cmds?: Node[];
    objtype?: ObjectType;
    missing_ok?: boolean;
  };
}
export interface ReplicaIdentityStmt {
  ReplicaIdentityStmt: {
    identity_type?: string;
    name?: string;
  };
}
export interface AlterTableCmd {
  AlterTableCmd: {
    subtype?: AlterTableType;
    name?: string;
    num?: number;
    newowner?: RoleSpec;
    def?: Node;
    behavior?: DropBehavior;
    missing_ok?: boolean;
    recurse?: boolean;
  };
}
export interface AlterCollationStmt {
  AlterCollationStmt: {
    collname?: Node[];
  };
}
export interface AlterDomainStmt {
  AlterDomainStmt: {
    subtype?: string;
    typeName?: Node[];
    name?: string;
    def?: Node;
    behavior?: DropBehavior;
    missing_ok?: boolean;
  };
}
export interface GrantStmt {
  GrantStmt: {
    is_grant?: boolean;
    targtype?: GrantTargetType;
    objtype?: ObjectType;
    objects?: Node[];
    privileges?: Node[];
    grantees?: Node[];
    grant_option?: boolean;
    grantor?: RoleSpec;
    behavior?: DropBehavior;
  };
}
export interface ObjectWithArgs {
  ObjectWithArgs: {
    objname?: Node[];
    objargs?: Node[];
    objfuncargs?: Node[];
    args_unspecified?: boolean;
  };
}
export interface AccessPriv {
  AccessPriv: {
    priv_name?: string;
    cols?: Node[];
  };
}
export interface GrantRoleStmt {
  GrantRoleStmt: {
    granted_roles?: Node[];
    grantee_roles?: Node[];
    is_grant?: boolean;
    opt?: Node[];
    grantor?: RoleSpec;
    behavior?: DropBehavior;
  };
}
export interface AlterDefaultPrivilegesStmt {
  AlterDefaultPrivilegesStmt: {
    options?: Node[];
    action?: GrantStmt;
  };
}
export interface CopyStmt {
  CopyStmt: {
    relation?: RangeVar;
    query?: Node;
    attlist?: Node[];
    is_from?: boolean;
    is_program?: boolean;
    filename?: string;
    options?: Node[];
    whereClause?: Node;
  };
}
export interface VariableSetStmt {
  VariableSetStmt: {
    kind?: VariableSetKind;
    name?: string;
    args?: Node[];
    is_local?: boolean;
  };
}
export interface VariableShowStmt {
  VariableShowStmt: {
    name?: string;
  };
}
export interface CreateStmt {
  CreateStmt: {
    relation?: RangeVar;
    tableElts?: Node[];
    inhRelations?: Node[];
    partbound?: PartitionBoundSpec;
    partspec?: PartitionSpec;
    ofTypename?: TypeName;
    constraints?: Node[];
    options?: Node[];
    oncommit?: OnCommitAction;
    tablespacename?: string;
    accessMethod?: string;
    if_not_exists?: boolean;
  };
}
export interface Constraint {
  Constraint: {
    contype?: ConstrType;
    conname?: string;
    deferrable?: boolean;
    initdeferred?: boolean;
    skip_validation?: boolean;
    initially_valid?: boolean;
    is_no_inherit?: boolean;
    raw_expr?: Node;
    cooked_expr?: string;
    generated_when?: string;
    inhcount?: number;
    nulls_not_distinct?: boolean;
    keys?: Node[];
    including?: Node[];
    exclusions?: Node[];
    options?: Node[];
    indexname?: string;
    indexspace?: string;
    reset_default_tblspc?: boolean;
    access_method?: string;
    where_clause?: Node;
    pktable?: RangeVar;
    fk_attrs?: Node[];
    pk_attrs?: Node[];
    fk_matchtype?: string;
    fk_upd_action?: string;
    fk_del_action?: string;
    fk_del_set_cols?: Node[];
    old_conpfeqop?: Node[];
    old_pktable_oid?: number;
    location?: number;
  };
}
export interface CreateTableSpaceStmt {
  CreateTableSpaceStmt: {
    tablespacename?: string;
    owner?: RoleSpec;
    location?: string;
    options?: Node[];
  };
}
export interface DropTableSpaceStmt {
  DropTableSpaceStmt: {
    tablespacename?: string;
    missing_ok?: boolean;
  };
}
export interface AlterTableSpaceOptionsStmt {
  AlterTableSpaceOptionsStmt: {
    tablespacename?: string;
    options?: Node[];
    isReset?: boolean;
  };
}
export interface AlterTableMoveAllStmt {
  AlterTableMoveAllStmt: {
    orig_tablespacename?: string;
    objtype?: ObjectType;
    roles?: Node[];
    new_tablespacename?: string;
    nowait?: boolean;
  };
}
export interface CreateExtensionStmt {
  CreateExtensionStmt: {
    extname?: string;
    if_not_exists?: boolean;
    options?: Node[];
  };
}
export interface AlterExtensionStmt {
  AlterExtensionStmt: {
    extname?: string;
    options?: Node[];
  };
}
export interface AlterExtensionContentsStmt {
  AlterExtensionContentsStmt: {
    extname?: string;
    action?: number;
    objtype?: ObjectType;
    object?: Node;
  };
}
export interface CreateFdwStmt {
  CreateFdwStmt: {
    fdwname?: string;
    func_options?: Node[];
    options?: Node[];
  };
}
export interface AlterFdwStmt {
  AlterFdwStmt: {
    fdwname?: string;
    func_options?: Node[];
    options?: Node[];
  };
}
export interface CreateForeignServerStmt {
  CreateForeignServerStmt: {
    servername?: string;
    servertype?: string;
    version?: string;
    fdwname?: string;
    if_not_exists?: boolean;
    options?: Node[];
  };
}
export interface AlterForeignServerStmt {
  AlterForeignServerStmt: {
    servername?: string;
    version?: string;
    options?: Node[];
    has_version?: boolean;
  };
}
export interface CreateForeignTableStmt {
  CreateForeignTableStmt: {
    base?: CreateStmt;
    servername?: string;
    options?: Node[];
  };
}
export interface CreateUserMappingStmt {
  CreateUserMappingStmt: {
    user?: RoleSpec;
    servername?: string;
    if_not_exists?: boolean;
    options?: Node[];
  };
}
export interface AlterUserMappingStmt {
  AlterUserMappingStmt: {
    user?: RoleSpec;
    servername?: string;
    options?: Node[];
  };
}
export interface DropUserMappingStmt {
  DropUserMappingStmt: {
    user?: RoleSpec;
    servername?: string;
    missing_ok?: boolean;
  };
}
export interface ImportForeignSchemaStmt {
  ImportForeignSchemaStmt: {
    server_name?: string;
    remote_schema?: string;
    local_schema?: string;
    list_type?: ImportForeignSchemaType;
    table_list?: Node[];
    options?: Node[];
  };
}
export interface CreatePolicyStmt {
  CreatePolicyStmt: {
    policy_name?: string;
    table?: RangeVar;
    cmd_name?: string;
    permissive?: boolean;
    roles?: Node[];
    qual?: Node;
    with_check?: Node;
  };
}
export interface AlterPolicyStmt {
  AlterPolicyStmt: {
    policy_name?: string;
    table?: RangeVar;
    roles?: Node[];
    qual?: Node;
    with_check?: Node;
  };
}
export interface CreateAmStmt {
  CreateAmStmt: {
    amname?: string;
    handler_name?: Node[];
    amtype?: string;
  };
}
export interface CreateTrigStmt {
  CreateTrigStmt: {
    replace?: boolean;
    isconstraint?: boolean;
    trigname?: string;
    relation?: RangeVar;
    funcname?: Node[];
    args?: Node[];
    row?: boolean;
    timing?: number;
    events?: number;
    columns?: Node[];
    whenClause?: Node;
    transitionRels?: Node[];
    deferrable?: boolean;
    initdeferred?: boolean;
    constrrel?: RangeVar;
  };
}
export interface CreateEventTrigStmt {
  CreateEventTrigStmt: {
    trigname?: string;
    eventname?: string;
    whenclause?: Node[];
    funcname?: Node[];
  };
}
export interface AlterEventTrigStmt {
  AlterEventTrigStmt: {
    trigname?: string;
    tgenabled?: string;
  };
}
export interface CreatePLangStmt {
  CreatePLangStmt: {
    replace?: boolean;
    plname?: string;
    plhandler?: Node[];
    plinline?: Node[];
    plvalidator?: Node[];
    pltrusted?: boolean;
  };
}
export interface CreateRoleStmt {
  CreateRoleStmt: {
    stmt_type?: RoleStmtType;
    role?: string;
    options?: Node[];
  };
}
export interface AlterRoleStmt {
  AlterRoleStmt: {
    role?: RoleSpec;
    options?: Node[];
    action?: number;
  };
}
export interface AlterRoleSetStmt {
  AlterRoleSetStmt: {
    role?: RoleSpec;
    database?: string;
    setstmt?: VariableSetStmt;
  };
}
export interface DropRoleStmt {
  DropRoleStmt: {
    roles?: Node[];
    missing_ok?: boolean;
  };
}
export interface CreateSeqStmt {
  CreateSeqStmt: {
    sequence?: RangeVar;
    options?: Node[];
    ownerId?: number;
    for_identity?: boolean;
    if_not_exists?: boolean;
  };
}
export interface AlterSeqStmt {
  AlterSeqStmt: {
    sequence?: RangeVar;
    options?: Node[];
    for_identity?: boolean;
    missing_ok?: boolean;
  };
}
export interface DefineStmt {
  DefineStmt: {
    kind?: ObjectType;
    oldstyle?: boolean;
    defnames?: Node[];
    args?: Node[];
    definition?: Node[];
    if_not_exists?: boolean;
    replace?: boolean;
  };
}
export interface CreateDomainStmt {
  CreateDomainStmt: {
    domainname?: Node[];
    typeName?: TypeName;
    collClause?: CollateClause;
    constraints?: Node[];
  };
}
export interface CreateOpClassStmt {
  CreateOpClassStmt: {
    opclassname?: Node[];
    opfamilyname?: Node[];
    amname?: string;
    datatype?: TypeName;
    items?: Node[];
    isDefault?: boolean;
  };
}
export interface CreateOpClassItem {
  CreateOpClassItem: {
    itemtype?: number;
    name?: ObjectWithArgs;
    number?: number;
    order_family?: Node[];
    class_args?: Node[];
    storedtype?: TypeName;
  };
}
export interface CreateOpFamilyStmt {
  CreateOpFamilyStmt: {
    opfamilyname?: Node[];
    amname?: string;
  };
}
export interface AlterOpFamilyStmt {
  AlterOpFamilyStmt: {
    opfamilyname?: Node[];
    amname?: string;
    isDrop?: boolean;
    items?: Node[];
  };
}
export interface DropStmt {
  DropStmt: {
    objects?: Node[];
    removeType?: ObjectType;
    behavior?: DropBehavior;
    missing_ok?: boolean;
    concurrent?: boolean;
  };
}
export interface TruncateStmt {
  TruncateStmt: {
    relations?: Node[];
    restart_seqs?: boolean;
    behavior?: DropBehavior;
  };
}
export interface CommentStmt {
  CommentStmt: {
    objtype?: ObjectType;
    object?: Node;
    comment?: string;
  };
}
export interface SecLabelStmt {
  SecLabelStmt: {
    objtype?: ObjectType;
    object?: Node;
    provider?: string;
    label?: string;
  };
}
export interface DeclareCursorStmt {
  DeclareCursorStmt: {
    portalname?: string;
    options?: number;
    query?: Node;
  };
}
export interface ClosePortalStmt {
  ClosePortalStmt: {
    portalname?: string;
  };
}
export interface FetchStmt {
  FetchStmt: {
    direction?: FetchDirection;
    howMany?: bigint;
    portalname?: string;
    ismove?: boolean;
  };
}
export interface IndexStmt {
  IndexStmt: {
    idxname?: string;
    relation?: RangeVar;
    accessMethod?: string;
    tableSpace?: string;
    indexParams?: Node[];
    indexIncludingParams?: Node[];
    options?: Node[];
    whereClause?: Node;
    excludeOpNames?: Node[];
    idxcomment?: string;
    indexOid?: number;
    oldNumber?: number;
    oldCreateSubid?: number;
    oldFirstRelfilelocatorSubid?: number;
    unique?: boolean;
    nulls_not_distinct?: boolean;
    primary?: boolean;
    isconstraint?: boolean;
    deferrable?: boolean;
    initdeferred?: boolean;
    transformed?: boolean;
    concurrent?: boolean;
    if_not_exists?: boolean;
    reset_default_tblspc?: boolean;
  };
}
export interface CreateStatsStmt {
  CreateStatsStmt: {
    defnames?: Node[];
    stat_types?: Node[];
    exprs?: Node[];
    relations?: Node[];
    stxcomment?: string;
    transformed?: boolean;
    if_not_exists?: boolean;
  };
}
export interface StatsElem {
  StatsElem: {
    name?: string;
    expr?: Node;
  };
}
export interface AlterStatsStmt {
  AlterStatsStmt: {
    defnames?: Node[];
    stxstattarget?: Node;
    missing_ok?: boolean;
  };
}
export interface CreateFunctionStmt {
  CreateFunctionStmt: {
    is_procedure?: boolean;
    replace?: boolean;
    funcname?: Node[];
    parameters?: Node[];
    returnType?: TypeName;
    options?: Node[];
    sql_body?: Node;
  };
}
export interface FunctionParameter {
  FunctionParameter: {
    name?: string;
    argType?: TypeName;
    mode?: FunctionParameterMode;
    defexpr?: Node;
  };
}
export interface AlterFunctionStmt {
  AlterFunctionStmt: {
    objtype?: ObjectType;
    func?: ObjectWithArgs;
    actions?: Node[];
  };
}
export interface DoStmt {
  DoStmt: {
    args?: Node[];
  };
}
export interface InlineCodeBlock {
  InlineCodeBlock: {
    source_text?: string;
    langOid?: number;
    langIsTrusted?: boolean;
    atomic?: boolean;
  };
}
export interface CallStmt {
  CallStmt: {
    funccall?: FuncCall;
    funcexpr?: FuncExpr;
    outargs?: Node[];
  };
}
export interface CallContext {
  CallContext: {
    atomic?: boolean;
  };
}
export interface RenameStmt {
  RenameStmt: {
    renameType?: ObjectType;
    relationType?: ObjectType;
    relation?: RangeVar;
    object?: Node;
    subname?: string;
    newname?: string;
    behavior?: DropBehavior;
    missing_ok?: boolean;
  };
}
export interface AlterObjectDependsStmt {
  AlterObjectDependsStmt: {
    objectType?: ObjectType;
    relation?: RangeVar;
    object?: Node;
    extname?: String;
    remove?: boolean;
  };
}
export interface AlterObjectSchemaStmt {
  AlterObjectSchemaStmt: {
    objectType?: ObjectType;
    relation?: RangeVar;
    object?: Node;
    newschema?: string;
    missing_ok?: boolean;
  };
}
export interface AlterOwnerStmt {
  AlterOwnerStmt: {
    objectType?: ObjectType;
    relation?: RangeVar;
    object?: Node;
    newowner?: RoleSpec;
  };
}
export interface AlterOperatorStmt {
  AlterOperatorStmt: {
    opername?: ObjectWithArgs;
    options?: Node[];
  };
}
export interface AlterTypeStmt {
  AlterTypeStmt: {
    typeName?: Node[];
    options?: Node[];
  };
}
export interface RuleStmt {
  RuleStmt: {
    relation?: RangeVar;
    rulename?: string;
    whereClause?: Node;
    event?: CmdType;
    instead?: boolean;
    actions?: Node[];
    replace?: boolean;
  };
}
export interface NotifyStmt {
  NotifyStmt: {
    conditionname?: string;
    payload?: string;
  };
}
export interface ListenStmt {
  ListenStmt: {
    conditionname?: string;
  };
}
export interface UnlistenStmt {
  UnlistenStmt: {
    conditionname?: string;
  };
}
export interface TransactionStmt {
  TransactionStmt: {
    kind?: TransactionStmtKind;
    options?: Node[];
    savepoint_name?: string;
    gid?: string;
    chain?: boolean;
    location?: number;
  };
}
export interface CompositeTypeStmt {
  CompositeTypeStmt: {
    typevar?: RangeVar;
    coldeflist?: Node[];
  };
}
export interface CreateEnumStmt {
  CreateEnumStmt: {
    typeName?: Node[];
    vals?: Node[];
  };
}
export interface CreateRangeStmt {
  CreateRangeStmt: {
    typeName?: Node[];
    params?: Node[];
  };
}
export interface AlterEnumStmt {
  AlterEnumStmt: {
    typeName?: Node[];
    oldVal?: string;
    newVal?: string;
    newValNeighbor?: string;
    newValIsAfter?: boolean;
    skipIfNewValExists?: boolean;
  };
}
export interface ViewStmt {
  ViewStmt: {
    view?: RangeVar;
    aliases?: Node[];
    query?: Node;
    replace?: boolean;
    options?: Node[];
    withCheckOption?: ViewCheckOption;
  };
}
export interface LoadStmt {
  LoadStmt: {
    filename?: string;
  };
}
export interface CreatedbStmt {
  CreatedbStmt: {
    dbname?: string;
    options?: Node[];
  };
}
export interface AlterDatabaseStmt {
  AlterDatabaseStmt: {
    dbname?: string;
    options?: Node[];
  };
}
export interface AlterDatabaseRefreshCollStmt {
  AlterDatabaseRefreshCollStmt: {
    dbname?: string;
  };
}
export interface AlterDatabaseSetStmt {
  AlterDatabaseSetStmt: {
    dbname?: string;
    setstmt?: VariableSetStmt;
  };
}
export interface DropdbStmt {
  DropdbStmt: {
    dbname?: string;
    missing_ok?: boolean;
    options?: Node[];
  };
}
export interface AlterSystemStmt {
  AlterSystemStmt: {
    setstmt?: VariableSetStmt;
  };
}
export interface ClusterStmt {
  ClusterStmt: {
    relation?: RangeVar;
    indexname?: string;
    params?: Node[];
  };
}
export interface VacuumStmt {
  VacuumStmt: {
    options?: Node[];
    rels?: Node[];
    is_vacuumcmd?: boolean;
  };
}
export interface VacuumRelation {
  VacuumRelation: {
    relation?: RangeVar;
    oid?: number;
    va_cols?: Node[];
  };
}
export interface ExplainStmt {
  ExplainStmt: {
    query?: Node;
    options?: Node[];
  };
}
export interface CreateTableAsStmt {
  CreateTableAsStmt: {
    query?: Node;
    into?: IntoClause;
    objtype?: ObjectType;
    is_select_into?: boolean;
    if_not_exists?: boolean;
  };
}
export interface RefreshMatViewStmt {
  RefreshMatViewStmt: {
    concurrent?: boolean;
    skipData?: boolean;
    relation?: RangeVar;
  };
}
export interface CheckPointStmt {
  CheckPointStmt: {};
}
export interface DiscardStmt {
  DiscardStmt: {
    target?: DiscardMode;
  };
}
export interface LockStmt {
  LockStmt: {
    relations?: Node[];
    mode?: number;
    nowait?: boolean;
  };
}
export interface ConstraintsSetStmt {
  ConstraintsSetStmt: {
    constraints?: Node[];
    deferred?: boolean;
  };
}
export interface ReindexStmt {
  ReindexStmt: {
    kind?: ReindexObjectType;
    relation?: RangeVar;
    name?: string;
    params?: Node[];
  };
}
export interface CreateConversionStmt {
  CreateConversionStmt: {
    conversion_name?: Node[];
    for_encoding_name?: string;
    to_encoding_name?: string;
    func_name?: Node[];
    def?: boolean;
  };
}
export interface CreateCastStmt {
  CreateCastStmt: {
    sourcetype?: TypeName;
    targettype?: TypeName;
    func?: ObjectWithArgs;
    context?: CoercionContext;
    inout?: boolean;
  };
}
export interface CreateTransformStmt {
  CreateTransformStmt: {
    replace?: boolean;
    type_name?: TypeName;
    lang?: string;
    fromsql?: ObjectWithArgs;
    tosql?: ObjectWithArgs;
  };
}
export interface PrepareStmt {
  PrepareStmt: {
    name?: string;
    argtypes?: Node[];
    query?: Node;
  };
}
export interface ExecuteStmt {
  ExecuteStmt: {
    name?: string;
    params?: Node[];
  };
}
export interface DeallocateStmt {
  DeallocateStmt: {
    name?: string;
    isall?: boolean;
    location?: number;
  };
}
export interface DropOwnedStmt {
  DropOwnedStmt: {
    roles?: Node[];
    behavior?: DropBehavior;
  };
}
export interface ReassignOwnedStmt {
  ReassignOwnedStmt: {
    roles?: Node[];
    newrole?: RoleSpec;
  };
}
export interface AlterTSDictionaryStmt {
  AlterTSDictionaryStmt: {
    dictname?: Node[];
    options?: Node[];
  };
}
export interface AlterTSConfigurationStmt {
  AlterTSConfigurationStmt: {
    kind?: AlterTSConfigType;
    cfgname?: Node[];
    tokentype?: Node[];
    dicts?: Node[];
    override?: boolean;
    replace?: boolean;
    missing_ok?: boolean;
  };
}
export interface PublicationTable {
  PublicationTable: {
    relation?: RangeVar;
    whereClause?: Node;
    columns?: Node[];
  };
}
export interface PublicationObjSpec {
  PublicationObjSpec: {
    pubobjtype?: PublicationObjSpecType;
    name?: string;
    pubtable?: PublicationTable;
    location?: number;
  };
}
export interface CreatePublicationStmt {
  CreatePublicationStmt: {
    pubname?: string;
    options?: Node[];
    pubobjects?: Node[];
    for_all_tables?: boolean;
  };
}
export interface AlterPublicationStmt {
  AlterPublicationStmt: {
    pubname?: string;
    options?: Node[];
    pubobjects?: Node[];
    for_all_tables?: boolean;
    action?: AlterPublicationAction;
  };
}
export interface CreateSubscriptionStmt {
  CreateSubscriptionStmt: {
    subname?: string;
    conninfo?: string;
    publication?: Node[];
    options?: Node[];
  };
}
export interface AlterSubscriptionStmt {
  AlterSubscriptionStmt: {
    kind?: AlterSubscriptionType;
    subname?: string;
    conninfo?: string;
    publication?: Node[];
    options?: Node[];
  };
}
export interface DropSubscriptionStmt {
  DropSubscriptionStmt: {
    subname?: string;
    missing_ok?: boolean;
    behavior?: DropBehavior;
  };
}
export interface ScanToken {
  ScanToken: {
    start?: number;
    end?: number;
    token?: Token;
    keywordKind?: KeywordKind;
  };
}